{"meta":{"title":"Casuor","subtitle":"","description":"","author":"Casuor","url":"https://casuor.top","root":"/"},"pages":[{"title":"about","date":"2018-12-12T14:14:36.000Z","updated":"2020-10-28T09:58:54.893Z","comments":false,"path":"about/index.html","permalink":"https://casuor.top/about/index.html","excerpt":"","text":"[关于] 生活态度 要比自由还自在 要比快乐更痛快 要比无邪还无害 要比放下放得开 生活目标 财务自由，佳人相伴 简约内向观察思考,数据主义,母胎单身,爱好女,处女座 不主动，不被动（两个人的事，都有兴趣才有故事）。不将就,不暧昧（泾渭分明） 世事繁杂，追求真我，爱我所爱 仅文学小说.etc 影视剧冒险悬疑,推理如 .etc 游戏lol忠实粉，吾之初心，永世不忘 jay迷,会唱小部分 爱编程爱阅读 不羁俗世，随性而活 about 了解me(肖像)"},{"title":"comment","date":"2018-12-20T15:13:48.000Z","updated":"2020-10-28T09:58:54.894Z","comments":true,"path":"comment/index.html","permalink":"https://casuor.top/comment/index.html","excerpt":"","text":"念两句诗 叙别梦、扬州一觉。 【宋代】吴文英《夜游宫·人去西楼雁杳》"},{"title":"donate","date":"2018-12-20T15:13:05.000Z","updated":"2020-10-28T09:58:54.895Z","comments":false,"path":"donate/index.html","permalink":"https://casuor.top/donate/index.html","excerpt":"","text":""},{"title":"rss","date":"2018-12-20T15:09:03.000Z","updated":"2020-10-28T09:58:54.896Z","comments":true,"path":"rss/index.html","permalink":"https://casuor.top/rss/index.html","excerpt":"","text":""},{"title":"lab","date":"2019-01-05T13:47:59.000Z","updated":"2020-10-28T11:03:47.143Z","comments":false,"path":"lab/index.html","permalink":"https://casuor.top/lab/index.html","excerpt":"","text":"爷的盘 One Drive Google Drive"},{"title":"links","date":"2018-12-19T15:11:06.000Z","updated":"2020-10-28T09:58:54.896Z","comments":true,"path":"links/index.html","permalink":"https://casuor.top/links/index.html","excerpt":"","text":""},{"title":"theme-sakura","date":"2019-01-04T14:53:25.000Z","updated":"2020-10-28T09:58:54.898Z","comments":false,"path":"theme-sakura/index.html","permalink":"https://casuor.top/theme-sakura/index.html","excerpt":"","text":"Hexo主题Sakura修改自WordPress主题Sakura，感谢原作者Mashiro"},{"title":"Live","date":"2018-12-12T14:14:16.000Z","updated":"2020-10-28T09:58:54.893Z","comments":true,"path":"categories/Live/index.html","permalink":"https://casuor.top/categories/Live/index.html","excerpt":"","text":""},{"title":"Resource","date":"2018-12-12T14:14:16.000Z","updated":"2020-10-28T09:58:54.894Z","comments":true,"path":"categories/Thinking/index.html","permalink":"https://casuor.top/categories/Thinking/index.html","excerpt":"","text":""},{"title":"Resource","date":"2018-12-12T14:14:16.000Z","updated":"2020-10-28T09:58:54.894Z","comments":true,"path":"categories/Resource/index.html","permalink":"https://casuor.top/categories/Resource/index.html","excerpt":"","text":""},{"title":"Geek","date":"2018-12-12T14:14:16.000Z","updated":"2020-10-28T09:58:54.893Z","comments":true,"path":"categories/Geek/index.html","permalink":"https://casuor.top/categories/Geek/index.html","excerpt":"","text":""},{"title":"bangumi","date":"2019-02-10T13:32:48.000Z","updated":"2020-10-28T09:58:54.897Z","comments":false,"path":"tags/Comic/index.html","permalink":"https://casuor.top/tags/Comic/index.html","excerpt":"","text":""},{"title":"comment","date":"2018-12-20T15:13:48.000Z","updated":"2020-10-28T09:58:54.894Z","comments":true,"path":"categories/Transfer/index.html","permalink":"https://casuor.top/categories/Transfer/index.html","excerpt":"","text":"念两句诗 叙别梦、扬州一觉。 【宋代】吴文英《夜游宫·人去西楼雁杳》"},{"title":"tags","date":"2018-12-12T14:14:16.000Z","updated":"2020-10-28T09:58:54.898Z","comments":true,"path":"tags/Reading/index.html","permalink":"https://casuor.top/tags/Reading/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-12-12T14:14:16.000Z","updated":"2020-10-28T09:58:54.897Z","comments":true,"path":"tags/Picture/index.html","permalink":"https://casuor.top/tags/Picture/index.html","excerpt":"","text":""},{"title":"music","date":"2018-12-20T15:14:28.000Z","updated":"2020-10-28T09:58:54.897Z","comments":false,"path":"tags/Music/index.html","permalink":"https://casuor.top/tags/Music/index.html","excerpt":"","text":""}],"posts":[{"title":"Megumi","slug":"pic_megumi","date":"2020-10-27T16:00:00.000Z","updated":"2020-10-29T13:01:41.921Z","comments":true,"path":"2020/10/28/pic_megumi/","link":"","permalink":"https://casuor.top/2020/10/28/pic_megumi/","excerpt":"","text":"直链下载","categories":[],"tags":[{"name":"Picture","slug":"Picture","permalink":"https://casuor.top/tags/Picture/"}]},{"title":"LOL Leesin","slug":"pic_leesin","date":"2020-08-05T16:00:00.000Z","updated":"2020-10-28T09:58:54.888Z","comments":true,"path":"2020/08/06/pic_leesin/","link":"","permalink":"https://casuor.top/2020/08/06/pic_leesin/","excerpt":"","text":"","categories":[],"tags":[{"name":"Picture","slug":"Picture","permalink":"https://casuor.top/tags/Picture/"}]},{"title":"LOL Yasuo","slug":"pic_yasuo","date":"2020-08-05T16:00:00.000Z","updated":"2020-10-28T09:58:54.888Z","comments":true,"path":"2020/08/06/pic_yasuo/","link":"","permalink":"https://casuor.top/2020/08/06/pic_yasuo/","excerpt":"","text":"","categories":[],"tags":[{"name":"Picture","slug":"Picture","permalink":"https://casuor.top/tags/Picture/"}]},{"title":"Pride 2020 flags","slug":"pic_pride2020flags","date":"2020-08-02T16:00:00.000Z","updated":"2020-10-28T09:58:54.888Z","comments":true,"path":"2020/08/03/pic_pride2020flags/","link":"","permalink":"https://casuor.top/2020/08/03/pic_pride2020flags/","excerpt":"","text":"","categories":[],"tags":[{"name":"Picture","slug":"Picture","permalink":"https://casuor.top/tags/Picture/"}]},{"title":"Pride 2020 conversations","slug":"pic_pride2020conversations","date":"2020-08-02T16:00:00.000Z","updated":"2020-10-28T09:58:54.888Z","comments":true,"path":"2020/08/03/pic_pride2020conversations/","link":"","permalink":"https://casuor.top/2020/08/03/pic_pride2020conversations/","excerpt":"","text":"","categories":[],"tags":[{"name":"Picture","slug":"Picture","permalink":"https://casuor.top/tags/Picture/"}]},{"title":"未来简史-尤瓦尔·赫拉利","slug":"reading-未来简史","date":"2020-06-19T16:00:00.000Z","updated":"2020-10-28T09:58:54.889Z","comments":true,"path":"2020/06/20/reading-未来简史/","link":"","permalink":"https://casuor.top/2020/06/20/reading-%E6%9C%AA%E6%9D%A5%E7%AE%80%E5%8F%B2/","excerpt":"","text":"What is Dataism?wikipedia reference 尤瓦尔·诺亚·赫拉利（Yuval Noah Harari）在畅销书《 人类简史：未来简史》（2016）–第9章“数据宗教”中介绍了数据主义的迷人概念，并预见了它作为一种宗教的兴起。 首先，他声称： “数据主义说，宇宙由数据流组成，任何现象或实体的价值取决于其对数据处理的贡献” 首先，他解释了数据专家的观点： 从数据论者的角度来看，我们可以将整个人类解释为一个单一的数据处理系统，而每个人都是其处理芯片。如果是这样，我们还可以通过四种基本方法将整个历史理解为提高该系统效率的过程： 增加处理器数量。拥有10万人口的城市比拥有1000人的村庄拥有更多的计算能力。 增加处理器的种类。不同的处理器可以使用多种方式来计算和分析数据。因此，在单个系统中使用几种处理器可能会增加其动态性和创造力。农民，牧师和医生之间的对话可能会产生新颖的想法，而这在三个狩猎采集者之间的对话中永远不会出现。 增加处理器之间的连接数。如果处理器之间的连接不良，那么仅仅增加处理器的数量和种类就毫无意义。连接十个城市的贸易网络比十个孤立的城市可能带来更多的经济，技术和社会创新。 增加沿现有连接的移动自由度。如果数据不能自由流动，则连接处理器几乎没有用。如果十个城市之间的道路被强盗困扰，或者某些专制的专制制度不允许商人和旅行者按自己的意愿行进，那么修建道路就不会很有用。 到目前为止，有一个合理的，以效率为导向的观点，某种程度上是机械的。然后，他解释了目的： 如果人类确实是一个单一的数据处理系统，其输出是什么？创建了一个全新的，效率更高的数据处理系统，称为万物互联。一旦完成此任务，智人将消失。 因此，例如 资本主义之所以没有击败共产主义，是因为资本主义更具道德性，因为个人自由是神圣的，或者是因为上帝对异教徒感到愤怒。相反，资本主义赢得了冷战，因为至少在加速技术变革的时期，分布式数据处理比集中式数据处理更好。 赫拉利认为，数据主义可能成为一种宗教： 像资本主义一样，数据主义也起初是一种中立的科学理论，但现在正演变成一种声称确定对与错的宗教。这种新宗教的最高价值是“信息流”。如果生命是信息的运动，并且我们认为生命是美好的，那么我们就应该扩展，深化和传播宇宙中的信息流。根据数据论，人类的经验不是神圣的，智人不是创造的顶点，也不是未来某些人类的先驱。人类仅仅是创建万物互联的工具最终可能会从地球上散布开来，覆盖整个银河系甚至整个宇宙。这个宇宙数据处理系统就像上帝。它将无处不在，并将控制一切，人类注定要融入其中。 然后，它陈述了两个主要诫命： 首先，最重要的是，数据专家应该通过连接到越来越多的媒体，以及产生和使用越来越多的信息来最大化数据流。像其他成功的宗教一样，数据主义也是传教士。它的第二条诫命是将所有内容连接到系统，包括不想连接的异端。而且“一切”不仅仅意味着人类。这意味着一切。 因此，他认为： 然后，它陈述了两个主要诫命：​ 首先，最重要的是，数据专家应该通过连接到越来越多的媒体，以及产生和使用越来越多的信息来最大化数据流。像其他成功的宗教一样，数据主义也是传教士。它的第二条诫命是将所有内容连接到系统，包括不想连接的异端。而且“一切”不仅仅意味着人类。这意味着一切。​因此，他认为：数据学家认为，如果经验不能共享，那么它们就毫无价值，而且我们不需要-确实不能-在我们自己内部找到意义。这是生存的问题。我们必须向自己和体系证明我们仍然有价值。价值不在于拥有经验，而在于将这些经验转化为自由流动的数据。 这种说法肯定暗示了社交媒体当前令人上瘾和自恋的用法。然后，他从跨性别的角度 - 历史的角度继续： 数据主义是自1789年以来的第一项运动，它创造了一个真正新颖的价值：信息自由。我们决不能将信息自由与表达自由的旧自由主义理念相混淆。表达自由被赋予了人类，并保护了他们思考和说出自己想要的东西的权利-包括他们闭上嘴和思想对自己的权利。相反，信息自由不给予人类。它被提供给信息。而且，这种新颖的价值可能会通过赋予信息权利在人类拥有数据和限制其移动的权利之上自由流通的权利，来侵犯传统的表达自由。 如果不是一两个世纪，那么Dataist革命可能会花费几十年。但是后来，人文主义革命也并非一朝一夕发生，今天大多数数据学家都说，万物互联是神圣的，因为人类正在创造它来满足人类的需求。但是最终，万物互联本身可能会变得神圣。 再从认识论的角度来看： 数据主义为所有科学家提供了一种通用语言，架起了跨越学术鸿沟的桥梁，并可以轻松地跨学科界限导出见解。音乐学家，政治学家和细胞生物学家最终可以相互理解。在此过程中，数据主义颠覆了传统的学习金字塔。迄今为止，数据仅被视为长智力活动链中的第一步。人们应该将数据分解为信息，将信息分解为知识，将知识分解为智慧。但是，数据学家认为，人类无法再应付海量的数据，因此他们无法将数据分发到信息中，更不用说将其分发到知识或智慧中了。因此，处理数据的工作应委托给电子算法，该算法的能力远远超过人脑。实际上，这意味着数据专家对人类的知识和智慧持怀疑态度，并且更愿意将他们的信任放在大数据和计算机算法上。 在“大数据”辩论中已经对此进行了广泛讨论。但是，他指出了数据主义的另一个基本特征： 数据论最牢固地扎根于其两个母学科：计算机科学和生物学。在这两者中，生物学更为重要。正是数据主义的生物拥护将计算机科学中的有限突破变成了世界性的灾难，可以彻底改变生活的本质。您可能不同意这样的观点，即有机体是算法，而长颈鹿，西红柿和人类只是处理数据的不同方法。但是您应该知道，这是当前的科学教条，它正在改变我们的世界，面目全非。 根据这种观点，后果可能如下： 我们目前的民主体制只是不能足够快地收集和处理相关数据，而且大多数选民对生物学和控制论的理解不够充分，无法形成任何有关的意见。因此，传统的民主政治失去了对事件的控制，也无法为我们提供对未来的有意义的愿景。政府已成为纯粹的政府。它管理国家，但不再领导它。它可以确保教师按时获得报酬，并且污水处理系统不会溢出，但是却不知道该国在20年后的地位。在某种程度上，这是一件非常好的事情。将神似的技术与超级狂妄自大的政治相结合是灾难的根源。 因此， 当算法知道每个人将如何投票时，又知道一个人投票给民主党人而另一个人投票给共和党人的确切神经系统原因时，进行民主选举有什么用？人本主义命令：“听您的感受！” 数据主义现在命令：’听算法！他们知道你的感觉。 总而言之， 在一开始，它可能会加快人本主义对健康，幸福和力量的追求。数据主义通过承诺实现这些人文主义的愿望而传播。为了获得永生，幸福和神圣的创造力，我们需要处理海量数据，远远超出人脑的能力。因此，算法将为我们做到这一点。然而，一旦权威从人类转移到算法，人本主义的项目可能就变得无关紧要了。一旦我们放弃以同中心为中心的世界观，转而以以数据为中心的世界观，人类的健康和幸福就显得不那么重要了。当已经存在更好的模型时，为什么要对过时的数据处理机器那么麻烦呢？ 尽管存在事实错误，许多以前的宗教还是获得了极大的欢迎和力量。如果基督教和共产主义能够做到这一点，为什么不实行数据主义呢？ 好吧，他听起来有些夸张，挑衅甚至是疯狂。我们能否相信自己的重要性以及同时相信数据的重要性？然后：我们不能证明生物不是算法吗？这是反乌托邦。然而，数据主义确实可能成为一种宗教。实际上，当今的寡头垄断平台可能正好在倡导互联网。换句话说，它会代表的，为了使互联网监管合法化，从而规范我们的社会，政治和心理生活，以满足他们自己的需求并遵循自己的规则，最终将互联网视为一个市场，在这个市场中，数据/信息（如以前的钱）在中心，而不是个人。尽管如此，网络还是被许多人设想并用作公共领域–我不会说最多。但是，确实趋势正在以这种方式发展。不幸的是，赫拉利的愿景不是幻想。正如他所说：“ 对数据主义教条的 严格审查不仅可能是二十世纪最大的科学挑战，而且也是最紧迫的政治和经济项目。”","categories":[],"tags":[{"name":"Reading","slug":"Reading","permalink":"https://casuor.top/tags/Reading/"}]},{"title":"必知必会的Powershell指令","slug":"geek_pwshshell","date":"2020-05-21T16:00:00.000Z","updated":"2020-10-28T09:58:54.885Z","comments":true,"path":"2020/05/22/geek_pwshshell/","link":"","permalink":"https://casuor.top/2020/05/22/geek_pwshshell/","excerpt":"","text":"必知必会的Powershell指令Get-Command gcm 获取全部命令 Get-Help Get-Help 指令名 查看某一命令的具体使用方法 Clear-Host clear/cls 清屏 Get-Location gl/pwd 输出当前所在目录 Set-Location sl/cd cd ~ #返回根目录 cd.. #返回上级目录 设置当前所在目录 Get-ChildItem dir/ls 输出当前目录子项 Get-Item gi 文件/目录名 获取子项信息 gi x* 使用*通配符筛选文件,相当于linux find指令 New-Item ni 文件名 创建文件 mkdir md创建目录 Move-Item mv 文件名 目录名 移动文件 mv 目录名 目录名 移动目录 Copy-Item cp 文件名 目录名 将文件复制到某目录 Rename-Item ren 原文件名 新文件名 重命名文件或目录 Remove-Item rm 文件名/or目录/文件名 删除文件或目录 Add-Content ac 文件名 文件追加内容 Set-Content sc 文件名 设置文件内容，会覆盖原内容 Clear-Content clc 文件名 清楚文件内容 Get-Service gsv 获取当前运行的服务 Get-Process gps 获取当前运行的进程 Stop-Process kill/spss 进程名 关掉相应的进程 Start-Process start 进程名/或其他参数 start . 资源管理器打开当前所在目录 开启某个进程 Get-Alias alias 输出当前存在的别名 设置别名Set-Alias(sal)","categories":[{"name":"Geek","slug":"Geek","permalink":"https://casuor.top/categories/Geek/"}],"tags":[]},{"title":"Awesome Wallpapers","slug":"res_awesomewall","date":"2020-05-16T16:00:00.000Z","updated":"2020-10-28T09:58:54.891Z","comments":true,"path":"2020/05/17/res_awesomewall/","link":"","permalink":"https://casuor.top/2020/05/17/res_awesomewall/","excerpt":"","text":"优质壁纸站，get 一下？速览 Wallhave Wallpaperhub wallls Wallpaper Abyss Wallhavehttps://wallhaven.cc/ 特点 正如网站【Title】所展示的awesome wallpapers，确实当之无愧（壁纸网站，而不是爬虫引擎），它提供有[latest，toplist,random]等多种筛选外，当然还有search，识图，多种tags,特别的是可通过颜色筛选相类似的壁纸，并且可以裁切任意比例，壁纸大都是设计者上传，网站链接也是固定格式的，很容易按需嘿嘿嘿 Wallpaperhubhttps://wallpaperhub.app/ 特点 网站弱弱的写了一句：Designed and built by Michael Gillett，google了一下写着：Aside from being an MVP and a keen follower I am in no way affiliated with Microsoft, the same is true of my work 害，都是泪，回归正题：本站比较单一，但绝逼是不简单呐（设计精品啊），谁说微软不牛逼呢！！！ Walllshttp://wallls.com/ 特点 本站Features:[上火],开玩笑，这个是按什么列出壁纸清单的，咳咳，不得而知，猜一下，或许是访问量😜，哈哈哈 本站特点:资源可能不是很多，但是包您满意，search，tags以及Browse by color，记得以上三点不是重点，你懂的，嘿嘿嘿 Wallpaper Abysshttps://wall.alphacoders.com/ 特点 80万张壁纸的的聚集地，看了一下热门搜索，惊了😲，什么火影，海贼，鬼灭，本站更偏向社区化，可以查看注册用户数以及Api,允许使用本站构建app等，维护者是来自世界各地的small team,具体呢tldr，详情访问以上链接即可，绝对发现新大陆","categories":[{"name":"Resource","slug":"Resource","permalink":"https://casuor.top/categories/Resource/"}],"tags":[]},{"title":"html/css framework","slug":"geek_htmlcss","date":"2020-05-05T16:00:00.000Z","updated":"2020-10-28T09:58:54.883Z","comments":true,"path":"2020/05/06/geek_htmlcss/","link":"","permalink":"https://casuor.top/2020/05/06/geek_htmlcss/","excerpt":"","text":"","categories":[{"name":"Geek","slug":"Geek","permalink":"https://casuor.top/categories/Geek/"}],"tags":[]},{"title":"Typora and PicGo-Core Custom cli","slug":"geek_typora&picgocli","date":"2020-05-05T16:00:00.000Z","updated":"2020-10-28T09:58:54.886Z","comments":true,"path":"2020/05/06/geek_typora&picgocli/","link":"","permalink":"https://casuor.top/2020/05/06/geek_typora&picgocli/","excerpt":"","text":"PicGo-Core via node package manager (Requires NodeJS runtime)npm install picgo -g picgo --help picgo use cd .\\.picgo\\ cat .\\config.json { &quot;picBed&quot;: { &quot;current&quot;: &quot;github&quot;, &quot;uploader&quot;: &quot;github&quot;, &quot;github&quot;: { &quot;repo&quot;: &quot;GithubName/RepoName&quot;, &quot;branch&quot;: &quot;master&quot;, &quot;token&quot;: &quot;&quot;, &quot;path&quot;: &quot;img/&quot;, &quot;customUrl&quot;: &quot;&quot; }, &quot;transformer&quot;: &quot;path&quot; }, &quot;picgoPlugins&quot;: {} }typora custom cliwindows linuxwhich node which picgo #拼接自定义上传命令如下 nodepath picgopath upload","categories":[{"name":"Geek","slug":"Geek","permalink":"https://casuor.top/categories/Geek/"}],"tags":[]},{"title":"Developer-roadmap","slug":"trans-developer-roadmap","date":"2020-05-05T16:00:00.000Z","updated":"2020-10-28T09:58:54.892Z","comments":true,"path":"2020/05/06/trans-developer-roadmap/","link":"","permalink":"https://casuor.top/2020/05/06/trans-developer-roadmap/","excerpt":"","text":"referencehttps://hub.fastgit.org/kamranahmedse/developer-roadmap developer-roadmap Roadmap to becoming a web developer in 2020 Frontend Roadmap Backend Roadmap DevOps Roadmap","categories":[{"name":"Geek","slug":"Geek","permalink":"https://casuor.top/categories/Geek/"}],"tags":[]},{"title":"小记白嫖Microsoft365","slug":"res_小记白嫖Microsoft365","date":"2020-05-02T16:00:00.000Z","updated":"2020-10-28T09:58:54.891Z","comments":true,"path":"2020/05/03/res_小记白嫖Microsoft365/","link":"","permalink":"https://casuor.top/2020/05/03/res_%E5%B0%8F%E8%AE%B0%E7%99%BD%E5%AB%96Microsoft365/","excerpt":"","text":"小记白嫖Office365Reference美国.edu教育邮箱申请 - Zwen Topic在线申请地址：https://bergen.edu/applynow 1.申请美国卑尔根社区学院edu邮箱，建议使用新泽西州美国人信息资料。点击“New/Visiting Students Apply Now”新生/来访的学生立即申请，在点击“Create Account”创建一个帐户。 2.申请(申请随便填)提交后大约等待半天左右的时间，您会收到卑尔根社区学院发送的一封标题为「Bergen Community College – New User Account」的邮件，内含您的学生ID、用户名、初始密码规则。初始密码是您的姓氏的前两个字母，首字母为大写+ 6位数字学生ID（不包括学生ID首位零）。例如：您的姓氏（Last Name）是Smith，学生ID为0123456，初始密码即为：Sm123456. 3.登陆：https://www.outlook.com/me.bergen.edu 登陆会跳转到卑尔根社区学院帐户登录统一认证页面。 邮箱前缀是您的用户名和密码即可登录（密码不支持修改）。 卑尔根社区学院EDU邮箱托管于Microsoft Office 365，支持Microsoft Office 365桌面版的安装。可以通过Microsoft Imagine学生账号验证，Microsoft Azure学生账号激活需要通过美国电话实体卡进行身份验证。","categories":[{"name":"Resource","slug":"Resource","permalink":"https://casuor.top/categories/Resource/"}],"tags":[]},{"title":"American identity","slug":"res_AmericanIdentity","date":"2020-05-01T16:00:00.000Z","updated":"2020-10-28T09:58:54.891Z","comments":true,"path":"2020/05/02/res_AmericanIdentity/","link":"","permalink":"https://casuor.top/2020/05/02/res_AmericanIdentity/","excerpt":"","text":"美国人身份信息所需相关网站如下 https://fakena.me/ https://www.fakenamegenerator.com/advanced.php http://www.haoweichi.com/ https://www.fakeaddressgenerator.com/ https://www.ssn-verify.com/ https://www.ssnregistry.org/validate/","categories":[{"name":"Geek","slug":"Geek","permalink":"https://casuor.top/categories/Geek/"}],"tags":[]},{"title":"git-usages","slug":"geek_gitusages","date":"2020-04-24T16:00:00.000Z","updated":"2020-10-28T09:58:54.883Z","comments":true,"path":"2020/04/25/geek_gitusages/","link":"","permalink":"https://casuor.top/2020/04/25/geek_gitusages/","excerpt":"","text":"Git常用命令参考手册reference https://github.com/xjh22222228/git-manual转载学习 目录 配置 生成SSH_Key 初始化本地仓库 文件状态 日志 克隆 查看分支 切换分支 创建分支 删除分支 重命名分支 代码合并 暂存 删除 提交 推送 拉取最新内容 查看文件的改动 回滚版本 撤销 标签 Rebase Git Flow 子模块 帮助 其他 配置# 查看全局配置列表 git config -l # 查看局部配置列表 git config --local --list # 查看已设置的全局用户名/邮箱 git config --global --get user.name git config --global --get user.email # 设置全局用户名/邮箱 git config --global user.name &quot;xiejiahe&quot; git config --global user.email &quot;example@example.com&quot; # 设置本地当前工作区仓库用户名/邮箱 git config --local user.name &quot;xiejiahe&quot; git config --local user.email &quot;example@example.com&quot; # 将默认文本编辑器设置为 emacs git config --global core.editor emacs # 将默认差异化分析工具设置为 vimdiff git config --global merge.tool vimdiff生成SSH_Key# 1、粘贴以下命令，替换为您的GitHub电子邮件地址 ssh-keygen -t rsa -b 4096 -C &quot;your_email@example.com&quot; # 2、当提示“输入要在其中保存密钥的文件”时，按Enter。接受默认文件位置。 &gt; Enter a file in which to save the key (/Users/you/.ssh/id_rsa): [Press enter] # 3、在提示符下，键入一个安全密码。 &gt; Enter passphrase (empty for no passphrase): [Type a passphrase] &gt; Enter same passphrase again: [Type passphrase again] 最后需要将生成的 SSH Key 添加到 `ssh config` 中 # 1、编辑 vim ~/.ssh/config # 2、粘贴下面到 config 文件中 Host * AddKeysToAgent yes UseKeychain yes IdentityFile ~/.ssh/id_rsa初始化仓库`git init` 创建一个空的Git仓库或重新初始化一个现有的仓库 # 会在当前目录生成.git git init # 以安静模式创建，只会打印错误或警告信息 git init -q # 创建一个裸仓库, 我们一般不会用到这个命令 git init --bare文件状态# 完整查看文件状态 git status # 以短格式给出输出 git status -s # 忽略子模块 git status --ignore-submodules日志# 查看完整历史提交记录 git log # 查看前N次提交记录 commit message git log -2 # 查看前N次提交记录，包括diff git log -p -2 # 搜索关键词 git log -S Java # 只显示合并日志 git log --merges # 以图形查看日志记录, --oneline 可选 git log --graph --oneline # 列出提交者贡献数量, 只会打印作者和贡献数量 git shortlog -sn # 以提交贡献数量排序并打印出message git shortlog -n # 采用邮箱格式化的方式进行查看贡献度 git shortlog -e # 查看 README.md 文件的修改历史记录，包括时间、作者以及内容 git blame README.md克隆# https 协议 git clone https://github.com/xjh22222228/git-manual.git # SSH协议 git clone git@github.com:xjh22222228/git-manual.git # 克隆某个分支， -b 指定分支名字 git clone -b master https://github.com/xjh22222228/git-manual.git # 递归克隆，如果项目包含子模块就非常有用 git clone --recursive git@github.com:xjh22222228/git-manual.git # 克隆深度为1, 不会把历史的记录也克隆，这样可以节省克隆时间 git clone --depth=1 https://github.com/xjh22222228/git-manual.git 查看分支# 查看所有分支 git branch --all # 查看本地分支 git branch # 查看远端分支 git branch -r切换分支# 2种方法，切换到master分支 git checkout master git switch master # 切换上一个分支 git checkout - # 切换远端分支 git checkout -t origin/dev创建分支# 创建develop本地分支 git branch develop # 创建本地develop分支并切换 git checkout -b develop # 创建远程分支, 实际上创建本地分支然后推送 git checkout -b develop git push origin develop # 创建一个空的分支, 不继承父分支，历史记录是空的，一般至少需要执行4步 git checkout --orphan develop # 这一步可选，如果你真的想创建一个没有任何文件的分支 git rm -rf . # 添加并提交，否则分支是隐藏的 （执行这一步之前需要注意当前工作区必须保留一个文件，否则无法提交） git add -A &amp;&amp; git commit -m &quot;提交&quot; # 推送到远程 git push --set-upstream origin develop删除分支# 删除本地分支 git branch -d &lt;branchName&gt; # 删除远程分支 git branch -d -r origin/&lt;branchName&gt; git push origin :&lt;branchName&gt;重命名分支# 重命名当前分支 git branch -m &lt;branchName&gt; 代码合并# 两步法, 将 feature/v1.0.0 分支代码合并到 develop git checkout develop git merge feature/v1.0.0 # 或者一步法 git merge feature/v1.0.0 develop # 以安静模式合并, 把develop分支合并到当前分支并不输出任何信息 git merge develop -q暂存# 暂存所有 git add -A # 暂存某个文件 git add ./README.md # 添加当前目录所有改动文件 git add . # 暂存一系列文件 git add 1.txt 2.txt ...删除git add 的反向操作 # 删除1.txt 文件 git rm 1.txt # 删除当前所有文件, 与rm -rf 命令不同的是不会删除 .git 目录 git rm -rf . # 清除当前工作区缓存，但不会删除文件，通常用于修改文件名不生效问题 git rm -r --cached .提交# -m 提交的信息 git commit -m &quot;changes log&quot; # 提交并显示diff变化 git commit -v # 允许提交空消息，通常必须指定 -m 参数 git commit --allow-empty-message # 重写上一次提交信息，确保当前工作区没有改动 git commit --amend -m &quot;新的提交信息&quot;推送# 推送内容到主分支 git push -u origin master # 本地分支推送到远程， 本地分支:远程分支 git push origin &lt;branchName&gt;:&lt;branchName&gt; # 简写，默认推送当前分支 git push # 强制推送, -f 是 --force 缩写 git push -f 拉取最新内容# 推荐，因为不会做自动合并 git fetch origin master # 相当于git fetch 然后 git merge git pull # 后面的意思是： 远程分支名:本地分支名 git pull origin master:master # 如果是要与本地当前分支合并，则冒号后面的&lt;本地分支名&gt;可以不写 git pull origin master 查看文件的改动# 查看所有文件改动 git diff # 查看具体文件的改动 git diff README.md # 查看某个版本的改动, 后面那一窜是commitId， git log后就能看到 git diff d68a1ef2407283516e8e4cb675b434505e39dc54 # 查看某个文件的历史修改记录 git log README.md git show d68a1ef2407283516e8e4cb675b434505e39dc54 README.md 回滚版本# 回滚上一个版本 git reset --hard HEAD^ # 回滚上两个版本 git reset --hard HEAD^^ # 回退到指定版本，git log 就能看到commit id了 git reset --hard &apos;commit id&apos; # 回滚版本是不保存在 git log，如果想查看使用 git reflog 撤销# 撤销当前目录下所有文件的改动 git checkout -- . # 撤销指定文件修改 git checkout -- README.md # 暂存区回到工作区, 指定 ./README.md 文件从暂存区回到工作区 git reset HEAD ./README.md # 撤销commit, 回到工作区, 一般commit id 是前一个 git reset &lt;commit_id&gt; # 撤销commit, 并且把修改同时撤销 git reset --hard &lt;commit_id&gt;标签# 列出本地所有标签 git tag # 列出远程所有标签 git ls-remote --tags origin # 按照特定模式查找标签, `*` 模板搜索 git tag -l &quot;v1.0.0*&quot; # 创建带有附注标签 git tag -a v1.1.0 -m &quot;标签描述&quot; # 创建轻量标签, 不需要带任何参数 git tag v1.1.0 # 后期打标签, 假设之前忘记打标签了，可以通过git log查看commit id git log git tag -a v1.1.0 &lt;commit_id&gt; # 推送到远程，默认只是本地创建 git push origin v1.1.0 # 一次性推送所有标签到远程 git push origin --tags # 删除标签, 你需要再次运行 git push origin v1.1.0 才能删除远程标签 git tag -d v1.1.0 # 删除远程标签 git push origin --delete v1.1.0 # 检查标签 git checkout v1.1.0 # 查看本地某个标签详细信息 git show v1.1.0Rebase`git rebase` 主要作用可以将多个commit记录合并为一条 # 操作最近4次提交 git rebase -i HEAD~4 # 或者以 commit_id 进行操作 git rebase -i e88835de905ad396f61a0dc8c040a8ac8a34f3f8 # 放弃 git rebase 操作 git rebase --abort # 此命令主要用于解决冲突后继续执行 git rebase --continue参考：git rebase将多次commit合并为一条 GitFlowGit Flow 不是内置命令，需要单独安装 **初始化** 每个仓库都必须初始化一次 # 通常直接回车以完成默认设置 git flow init **功能** # 开启新的功能 git flow feature start v1.1.0 # 推送到远程, 在团队协作中这一步少不了 git flow feature publish v1.1.0 # 完成功能, 会将当前分支合并到 develop 然后删除分支，回到 develop git flow feature finish v1.1.0 **打补丁** hotfix是针对 `master` 进行打补丁的 # 开启新的 hotfix git flow hotfix start v1.1.0_hotifx # 推送到远程 git flow hotfix publish v1.1.0_hotifx # 完成新的hotfix, 将当前分支合并到 master 和 develop，然后删除分支，回到 develop git flow hotfix finish v1.1.0_hotifx **发布** # 开启新的 release git flow release start v1.1.0 # 推送到远程 git flow release publish v1.1.0 # 完成, 将当前分支合并到 master 和 develop，删除当前分支然后回到 develop git flow release finish v1.1.0Git flow schema 子模块具体使用还可以看这里 git submodule子模块使用教程 # 添加子模块 git submodule add https://github.com/xjh22222228/git-manual.git # 更新，有2种方法 # 一步到位 git submodule update --remote # 或者进入到子模块项目再拉取 git pull # 修复子模块分支指向 detached head git submodule foreach -q --recursive &apos;git checkout $(git config -f $toplevel/.gitmodules submodule.$name.branch || echo master)&apos; # 删除子模块 common 为子模块名称，一般删除需要三部 git submodule deinit &lt;common&gt; # 清除子模块缓存 git rm --cached common # 提交代码并推送 git commit -am &quot;Remove a submodule&quot; &amp;&amp; git push帮助# 详细打印所有git命令 git help # 打印所有git命令, 此命令不会有详细信息，更清晰一些 git help -a # 列出所有可配置的变量 git help -c其他# 查看git版本 git --version # 查看远程仓库地址 git remote -v # 记住提交账号密码 git config --global credential.helper store # 清除git已保存的用户名和密码 # windows git credential-manager uninstall # mac linux git config --global credential.helper &quot;&quot; # 或者 git config --global --unset credential.helper # 清除本地git缓存 git rm -r --cached . 附上一张鹅厂的 git 思维导图 LicenseMIT","categories":[{"name":"Geek","slug":"Geek","permalink":"https://casuor.top/categories/Geek/"}],"tags":[]},{"title":"scoop","slug":"geek_scoop","date":"2020-04-05T16:00:00.000Z","updated":"2020-10-28T09:58:54.886Z","comments":true,"path":"2020/04/06/geek_scoop/","link":"","permalink":"https://casuor.top/2020/04/06/geek_scoop/","excerpt":"","text":"reference 123456789101112131415#修改hosts#github140.82.114.3 github.com185.199.110.153 assets-cdn.github.com199.232.69.194 github.global.ssl.fastly.net199.232.68.133 raw.githubusercontent.comSet-ExecutionPolicy RemoteSigned -scope CurrentUser$env:SCOOP&#x3D;&#39;D:\\Scoop&#39;[Environment]::SetEnvironmentVariable(&#39;SCOOP&#39;, $env:SCOOP, &#39;User&#39;)$env:SCOOP_GLOBAL&#x3D;&#39;D:\\GlobalScoopApps&#39;[Environment]::SetEnvironmentVariable(&#39;SCOOP_GLOBAL&#39;, $env:SCOOP_GLOBAL, &#39;Machine&#39;) #此步骤管理员运行#确保raw.githubusercontent.com可以访问Invoke-Expression (New-Object System.Net.WebClient).DownloadString(&#39;https:&#x2F;&#x2F;get.scoop.sh&#39;) 123456789101112131415scoop install sudo -g#ssr代理scoop config proxy 127.0.0.1:1080#scoop config rm proxyscoop install aria2 #喵的死活下不动scoop install gitscoop updateSet-ItemProperty &#39;HKLM:\\SYSTEM\\CurrentControlSet\\Control\\FileSystem&#39; -Name &#39;LongPathsEnabled&#39; -Value 1scoop install innounpscoop install darkscoop checkupscoop bucket add extrasscoop install typorascoop install vscodecode $env:LocalAppData\\Packages\\Microsoft.WindowsTerminal_8wekyb3d8bbwe\\LocalState\\settings.json 12345678910111213141516171819scoop install figletscoop install cowsayscoop bucket add dorado https://github.com/h404bi/doradosudo scoop install trash -gsudo scoop install nvm -gscoop bucket add Ash258 'https://github.com/Ash258/Scoop-Ash258.git'scoop install carnacscoop bucket add iszy 'https://github.com/ZvonimirSun/scoop-iszy.git'scoop install wechatscoop install qq-dreamcastscoop install utoolsscoop install switchhostsscoop install scoop bucket add my-scoop-bucket https://github.com/destinyenvoy/my-scoop-bucketscoop install gvim#设置别名scoop alias add i 'scoop install $args[0]'scoop alias add rm 'scoop uninstall $args[0]'scoop alias add ls 'scoop list' 'List installed apps'scoop alias add up 'scoop update $args[0]' 'Update apps, or Scoop itself' 7zip 19.00 anaconda3 2020.02 [dorado] aria2 1.35.0-1 carnac 2.3.13 [extras] clash-for-windows failed ColorTool 1904.29002 cowsay 0.2013.07.19 dark 3.11.2 dismplusplus 10.1.1001.10 [extras] everything 1.4.1.969 [extras] fiddler 5.0.20202.18177 [extras] figlet 1.0-go firefox current [extras] git 2.26.2.windows.1 github 2.5.2 [extras] googlechrome 81.0.4044.138 [extras] gow 0.8.0 innounp 0.49 jetbrains-toolbox 1.17.7018 [extras] kate 20.04.1-893 [extras] mubu 1.2.4 [dorado] mysql 8.0.20 netease-music 2.7.1.198242 [iszy] nircmd 2.86 global notion 2.0.8 [Ash258] nvm 1.1.7 global oraclejdk8 8u231 [iszy] powertoys 0.18.2 [extras] pwsh-preview 7.1.0-preview.3 [Ash258] python 3.8.3 QtScrcpy 1.3.5 [dorado] rufus 3.10 [extras] screentogif 2.24.2 [extras] sudo 0.2020.01.26 global switchhosts 3.5.4 [extras] trash 2.0.0 global [dorado] typora 0.9.89 [extras] vscode 1.46.1 [extras] wechat nightly-20200515 [dorado]","categories":[{"name":"Geek","slug":"Geek","permalink":"https://casuor.top/categories/Geek/"}],"tags":[]},{"title":"亚里士多德名言","slug":"reading-亚里士多德名言英文","date":"2020-03-31T16:00:00.000Z","updated":"2020-10-28T09:58:54.889Z","comments":true,"path":"2020/04/01/reading-亚里士多德名言英文/","link":"","permalink":"https://casuor.top/2020/04/01/reading-%E4%BA%9A%E9%87%8C%E5%A3%AB%E5%A4%9A%E5%BE%B7%E5%90%8D%E8%A8%80%E8%8B%B1%E6%96%87/","excerpt":"","text":"亚里士多德名言1、Happiness is good。幸福就是至善。 2、Evil is the cause of evil。邪恶事件起因于邪恶。 3、Beauty is a gift from God。美是上帝赐予的礼物。 4、Beauty is a natural advantage。美是一种自然优势。 5、Knowledge is human nature。求知是人类的本性。 6、Education is cheap defense。教育是廉价的国防。 7、Happiness comes from our own。幸福来源于我们自己。 8、I love my teacher， I love the truth。我爱我师，我更爱真理。 9、Even God cannot change the past。即使上帝也无法改变过去。 10、Memory is the mother of wisdom。记忆为智慧之母。 11、No one can grasp the truth。没有一个人能全面把握真理。 12、Habits can make second nature。习惯能造就第二天性。 13、Happiness lies in the autonomy。幸福在于自主自足之中。 14、A genius and a madman。天才必然和疯子结成亲密的联盟。 15、Man is a natural social animal。人类是天生社会性动物。 16、Man is a natural social animal。人类是天生社会性的动物。 17、Happiness belongs to meet the people。幸福属于满足的人们。 18、The purpose of the work is to get leisure。劳动的目的是为了获得闲暇。 19、A barking dog is better than a sleeping lion with。吠犬之用，胜于睡狮。 20、Happiness lies in being self-sufficient。幸福在于自给自足之中。 21、The purpose of the work is to get free。工作的目的便是获得空闲。 22、The purpose of the war must be peace。**的目的必须是为了和平。 23、Every field of nature is wonderful。大自然的每一个领域都是美妙绝伦的。 24、Knowledge is the best food for elderly。知识是为老年准备的最好的食粮。 25、The greatest honor is to defend the country。最大的荣誉是保卫祖国的荣誉。 26、Happiness is for those who are easy to meet。幸福属于那些容易感到满足的人。 27、I love my teacher， but I love the truth。我爱我的老师，但我更爱真理。 28、Justice is the virtue of punishment in Gongming。公正是赏罚公明者的美德。 29、Courage is the path of confidence and fear。勇敢乃是自信与害怕中间之道。 30、The same bird， self converging together。羽毛相同的鸟，自会聚在一起。 31、Bad habits are formed in the unconscious。坏习惯是在不知不觉中形成的。 32、Keep oneself to oneself， not a beast or a God。离群索居者，不是野兽，便是神灵。 33、A true friend is a soul in two bodies。真正的朋友，是一个灵魂孕育在两个躯体里。 34、Real people have high Hiroyuki can benefit mankind。真正高宏之人，必能造福于人类。 35、All art， religion is only natural appendages。一切艺术、宗教都不过是自然的附属物。 36、The cause is the vivid unification of idea and practice。事业是理念和实践的生动统一。 37、Law is order， and good law is good order。法律就是秩序，有好的法律才有好的秩序。 38、Friends， they will not put the scales in their midst。是朋友，就不会把秤放在他们中间。 39、The most lucid style is formed by common language。最明晰的风格是由普通语言形成的。 40、The roots of education are bitter， but the fruit is sweet。教育的根是苦的，但其果实是甜的。 41、To overcome the fear of people to get real freedom。克服了恐惧的人才能获得真正的自由。 42、Who are friends， the essence of who are not friends。对谁都是朋友，实质对谁都不是朋友。 43、Beautiful appearance and elegant demeanor is a long。美丽的相貌和优雅的风度是一封长。 44、Live a happy life in accordance with moral standards。遵照道德准则生活就是幸福的生活。 45、The accuracy of language is the foundation of a good style。语言的准确性，是优良风格的基础。 46、Happiness is to put the soul in the most appropriate place。幸福是把灵魂安放在最适当的位置。 47、There is no man with a mad character， no great talent。没有疯狂性格的人，绝没有庞大的天才。 48、Beauty is a kind of good， and it is good for pleasure。美是一种善，其所以引起快感，正因为它善。 49、The so-called equality， is the poor do not account for the rich。所谓平等，就是穷人不占富人的便宜。 50、Education is an ornament to the rich， and a refuge for the poor。教育是富人的装饰品，穷人的避难所。 51、Education is an ornament in prosperity， adversity is a refuge。教育在顺境中是装饰品，在逆境中是避难所。 52、Human knowledge has three： theory， practical， identification。人类所需要的知识有三：理论、实用、鉴别。 53、It is only one road， the road can have many of the evil。人们为善的道路只有一条，作恶的道路可以有许多条。 54、If the evil completely becomes unbearable， it will self destruct。如果恶完全变成不堪忍受的，它也将自灭。 55、The truth will deviate from the original course， in the end is wrong。最初偏离真理毫厘，到头来就会谬之千里。 56、Intellectuals are better than illiteracy， as the living is better than dead。知识分子优于文盲，如同活人优于死人。 57、A bad man is a man who is afraid to obey， a good man is subject to love。坏人因畏惧而服从，好人因爱而服从。 58、A long， idle， and most of the time to make one’s failure and destruction。长期的无所事事最能使人衰竭和毁灭。 59、only to overcome their fear， it is possible to obtain real freedom。只有克服了自己的恐惧，才可能获得真正的自由。 60、Good is happiness。 Moderation is the highest good and extreme beauty。善就是幸福。中庸是最高的善和极端的美。 61、Education does not change human nature， can only improve human nature。教育并不能改变人性，只能改良人性。 62、Education should be provided by law， and should be the country’s affairs。教育应由法律规定，并且应是国家的事务。 63、Beautiful looks and graceful manners are a long - term recommendation。美丽的相貌和优雅的风度是一封长效的推荐信。 64、The ultimate value of life is to wake up and think， not only to survive。人生最终的价值在于觉醒和思考的，而不只在于生存。 65、People think I am the most intelligent， but I know that I do not know what。人以为我最聪明，但是我自己知道我是什么都不知。 66、The revolution should not trivial， but it is originated from the trivial things。**应不是琐细小事，但它却是起源于琐细事物。 67、Matter and form are abstract concepts， and a concrete object contains both。物质与形式是抽象概念，一个具体的事物包含着两者。 68、In any case， the form is more important than material， because it can be created。形式无论如何也比物质更重要，因为形式是可以创造的。 69、Goodness is the noble and is praiseworthy for one’s excellent conduct， worthy of praise。善性是难能可贵的，也是高尚和值得称赞的。 70、The arbitrator shall be based on equity， and the judge shall take the law as the criterion。仲裁人要以衡平法为依据，法官要以法律为准绳。 71、A good impression is a prerequisite for friendship， but it can not be confused with the two。好感是友谊的先决条件，但不能把两者混为一谈。 72、Relaxation and recreation， which are considered to be an indispensable element of life。放松与娱乐，被认为是生活中不可缺少的要素。 73、I think， and the victory over the enemy， compared to the desire of the people to fight more bravely。我认为，与战胜敌人的人相比，战胜欲望的人更加勇敢。 74、A man who loves the truth， who loves the truth when he is in no danger， loves the truth in danger。热爱真理的人在没有危险时爱着真理，在危险时更爱真理。 75、People should begin to explore from ancient to modern times， originated in the natural world of wonder。古往今来人们开始探索，都应起源于对自然万物的惊异。 1、细节决定成败。 2、成功是细节之子。 3、奥秘全在细微处。 4、天下大事，必作于细。 5、细节承载着社会的文明。 6、关注细节，成就大事。 7、机会往往隐藏在细节之中。 8、沉沉的黑夜都是白天的前奏。 9、做事不贪大，做人不计小。 10、人生最大的浪费是选择的浪费。 11、当失败不可避免时，失败也是伟大的。 12、至广大而精细微（胆要大、心要细）。 13、人的意志力是由责任感决定的。 14、个人素质一小步，民族素质一大步。 15、职场箴言：天下大事，必做于细。 16、简单的招式炼到极至就是绝招。 17、小事成就大事，细节成就完美。 18、失败就是迈向成功应付出的代价。 19、成功＝艰苦的劳动＋正确的方法＋少说空话。 20、细节成为产品或服务质量的最有力的表现形式。 21、成功=正确的定位+坚定的步伐+快乐的行进。 22、人的聪明和自己的明智及道路的选择，往往在失败以后。 23、使人疲惫不堪的不是远方的高山，而是鞋里的一粒沙子。 24、一个企业家要有明确的经营理念和对细节无限的爱。 25、无视细节的企业，它的发展必定在粗糙的砾石中停滞。 26、永远向竞争对手学习，学习每一个先进的“细节”。 27、失败也是我需要的，它与成功对我一样有价值。 28、一次失败，只是证明我们成功的决心还够坚强。 29、大事皆由小事累积而成，没有小事的积累，也难成大事。 30、为伟大的事业捐躯，从来就不能算作是失败。 31、一个不经意的细节，往往能够反映出一个人深层次的修养。 32、细节始于计划，计划同时也是一种细节，是很重要的细节。 33、任何事情，只有做到100%才是合格，99分都是不合格。 34、不放过细节。无视细节的企业，它的发展必定在粗糙的砾石中停滞。 35、细节不是“细枝末节”，而是用心，是一种认真的态度和科学的精神。 36、成功的人是跟别人学习经验，失败的人只跟自己学习经验。 37、世界上到处都是散漫粗心的人，只有那善始善终者是供不应求的。 38、没有条理、做事没有秩序的人，无论做哪一种事业都没有功效可言。 39、把每一件简单的事做好就是不简单，把每一件平凡的事做好就是不平凡。 40、有条理、有秩序的人，即使才能平庸，他的事业也往往有相当的成就。 41、普通人，大量的日子，很显然都在做一些小事，怕小事也做不好，小事也做不到位。 42、实际情况往往是这样的：想法是好的，但却没有人愿意和能够把每一件小事做透。 43、障碍与失败，是通往成功最稳靠的踏脚石，肯研究利用它们，便能从失败中培养出成功。 44、细节总是容易为人所忽视，所以往往最能反映一个人的真实状态，因而也最能表现一个人的修养。 45、当生活像一首歌那样轻快流畅时，笑颜常开乃易事；而在一切事都不妙时仍能微笑的人，才活得有价值。 46、什么是不简单？把每一件简单的事情做好就是不简单；什么是不平凡？把每一件平凡的事情做好就是不平凡。 47、世界上最难遵循的规则是度，度源于素养，而素养则来源于日常生活一点一滴的细节的积累，这种积累是一种功夫。 48、考虑到细节、注重细节的人，不仅认真对待工作，将小事做细，而且注重在做事的细节中找到机会，从而使自己走向成功之路。 49、德国企业就是凭着一丝不苟、精细严谨的做事风格，成就了一大批世界级企业巨头，打造了“德国制造”这个产品品质保证代名词的国家品牌。 50、注意细节其实是一种功夫，这种功夫是靠日积夜累培养出来的。谈到日积夜累，就不能不涉及到习惯，因为人的行为的95%都是受习惯影响的，在习惯中培养功夫，培养素质。 1、不怕学不会，只怕不肯钻。Not afraid， not afraid to drill。 2、时间是脑力劳动者的资本。Time is the capital of the brain。 3、勤能补拙是良训，一分辛苦一分才。Is a good training， a hard one before。 4、汗水换来丰收，勤学取得知识。Sweat harvest， hard to get knowledge。 5、天才无非是长久的忍耐，努力吧！Genius is nothing but a long endurance！ 6、早起多长一智，晚睡多增一闻。An early night more than a smell of wisdom。 7、平时不好学，临考悔已迟。Usually not easy to learn， too late to regret the exam。 8、灵感是从来不拜访懒汉的。Inspiration is never called on the sluggard。 9、书籍是横渡时间大海的航船。The book is the ship crossing the sea of time。 10、不怕学不成，只怕心不诚。Not afraid， afraid of heart is not sincere。 11、只要是有益的话，小孩的话也要听。As long as it is good， the child will listen to it。 12、忘记今天的人将被明天忘记。Forget today’s people will be forgotten tomorrow。 13、黑发不如勤学早，白发方悔读书迟。Black as time， white square regret later reading。 14、你若需要时间，还得自己把他造出来。If you need time， you have to make it yourself。 15、好学而不勤问非真好学者。Good learning and not often asked not to really good scholar。 16、刻苦学习的人总能实现自己的愿望。People who study hard can always achieve their wishes。 17、少年不知勤学早，白首方悔读书迟。Boy no time， white square regret later reading。 18、学成巧，总是巧；装成巧，惹人笑。They always pretend to be clever， clever； smart， funny。 19、钟不敲不鸣，人不学不灵。Don’t knock the clock not singing， people do not learn。 20、文学之知识乃是学问之门禁。Knowledge of literature is the access control of learning。 21、靠父亲的学识成不了学者。By his father’s knowledge can not become a scholar。 22、怕问路，要迷路。嘴勤不走冤枉路。Afraid to ask， get lost。 Mouth do not go astray。 23、勤奋是聪明的土壤，勤学是聪明的钥匙。Diligence is the smart is smart key soil， logistics。 24、愈学习，愈发现自己无知。The more learning， the more you find yourself ignorant。 25、水滴石穿，绳锯木断。Dripping water wears through a stone。， Little strokes fell great oaks。 26、黑发不知勤学早，白首方悔读书迟。Energy-saving， white square regret later reading。 27、聪明靠努力学习，知识靠平日积累。Smart by hard learning， knowledge on weekdays accumulation。 28、赶脚的对头是脚懒，学习的对头是自满。My head is foot lazy， complacency is the enemy of learning。 29、讷讷寡言者未必愚，喋喋利口者未必智。only silence may not be foolish， just not wise liqueur。 30、读书破万卷，下笔如有神。Having read more than ten thousand books， writing if there is god。 31、活到老，学到老，一生一世学不了。It is never too late to learn， to learn， one’s whole life。 32、人不劳动没出息，人不学习没长进。People do not work for nothing， people do not learn no progress。 33、手指有长有短，知识有高有低。学无前后，达者为师。Finger length， knowledge。 No， as teachers。 34、黄金时代是在我们的前面，而不在我们的后面。The golden age is before us， not behind us。 35、年华一去不复返，事业放弃在难成。Time gone， cause to give up in difficult to become。 36、边学边问，才有学问。若要精，人前听。Learn to ask， learned。 To be fine， people listen to。 37、刀不快，石上磨。人不会，世上学。Knife is not quick， stone grinding。 No one can go to school。 38、喜欢吹嘘的人犹如一面大鼓，响声大腹中空。Like people who brag is like a drum， the hollow sound。 39、没有加倍的勤奋，就既没有才能，也没有天才。There is no talent， no talent， no more diligent。 40、要学蜜蜂采百花，问遍百家成行家。To learn the bees gather flowers， asked all over 100 experts。 41、一分耕耘，一分收获。一艺之成，当尽毕生之力。A hard， a harvest。 A skill， when the power of life。 42、不能则学，不知则问，耻于问人，决无长进。Not to learn， I asked， ashamed to ask people， no。 43、用宝珠打扮自己，不如用知识充实自己。Dress with pearls， as to enrich themselves with knowledge。 44、劳动是知识的源泉；知识是生活的指南。Labor is the source of knowledge； knowledge is the guide to life。 45、学而不思则罔，思而不学则殆。Learning without thought is labor lost， thought without learning is perilous。 46、蜂采百花酿甜蜜，人读群书明真理。Bee stuffed sweet flowers， group of people reading the book out the truth。 47、智者千虑，必有一失；愚者千虑，必有一得。It is a wise man， there must be a loss； a fool， there will be one。 48、树不修，长不直；人不学，没知识。The tree does not repair， long not straight； people do not learn， no knowledge。 49、山有路勤为径，学海无涯苦作舟。The mountain road to the size， no end for learning suffering for the boat。 50、可得一夜安眠；勤劳一生，勤劳一日。可得幸福长眠。But a night’s sleep； a hard life， one day。 A happy death。 51、博学之，审问之，慎思之，明辩之，笃行之。Erudite， questioning， deliberative， distinguish， and faithful。 52、吹嘘自己有知识的人，等于在宣扬自己的无知。He who boasts of his knowledge is equal to his own ignorance。 53、鸟欲高飞先振翅，人求上进先读书。The bird to fly first wings， who seek to improve themselves to reading。 54、井淘三遍吃好水，人从三师武艺高。Wells wash three times to eat water， people from the three division Wu Yi high。 55、谦虚是学习的朋友，自满是学习的敌人。Humility is the learning of a friend， complacency is the enemy of study。 56、言过其实，终无大用。知识愈浅，自信愈深。No big exaggerate。 The more shallow knowledge， the more deep the confidence。 57、学问渊博的人，懂了还要问；学问浅薄的人，不懂也不问。A learned man， a man who knows not， but a man who has no knowledge。 58、不向前走，不知路远；不努力学习，不明白真理。Do not move forward， not far； don’t study hard， do not understand the truth。 59、山不厌高，水不厌深。骄傲是跌跤的前奏。The mountain is too high， the water too deep。 Pride is the prelude to fall。 60、水不流，会发臭；人不学，会落后。The water does not flow， will stink； people do not learn， will be left behind。 61、成就是谦虚者前进的阶梯，也是骄傲者后退的滑梯。Step forward achievement is modest， is proud of the slide back。 62、学问二字，须要拆开看，学是学，问是问。Learning two words， need to open to see， learning is to learn， ask is to ask。 63、一分耕耘，一分收获；要收获的好，必须耕耘的好。A point of hard work， a harvest； to gain good， must work well。 64、水满则溢，月满则亏；自满则败，自矜则愚。The water overflows， over the loss； complacency is defeated， blinded fool。 65、没有任何动物比蚂蚁更勤奋，然而它却最沉默寡言。The ant is the most industrious animal， but it most be scanty of words。 66、发奋识遍天下字，立志读尽人间书。To know the word all over the world， determined to make the world read the book。 67、心坚石也穿。好记性不如烂笔头。勤勉是成功之母。Heart stone also wear。 Forget it。 Diligence is the mother of success。 68、才华是血汗的结晶。才华是刀刃，辛苦是磨刀石。Talent is the crystallization of sweat。 Talent is the blade， hard whetstone。 69、刀钝石上磨，人笨人前学。以人为师能进步。A blunt knife grinding stone， a former school people。 To make progress by the human。 70、业精于勤荒于嬉，行成于思毁于随。Efficiency comes from diligence。 shortage in the play， was destroyed along with the line into si。 71、如果不想在世界上虚度一生，那就要学习一辈子。If you don’t want to waste your life in the world， you need to study for a lifetime。 72、书，是人类共同的精神财富，是人类进步的阶梯。Books， is the common spiritual wealth of mankind， is the ladder of human progress。 73、精神的浩瀚、想象的活跃、心灵的勤奋：就是天才。The spirit of the vast， the imagination of active， the mind of the diligence： is a genius。 74、如果有了胡子就算学识渊博，那么，山羊也可以讲课了。If the beard even so， goats can also have a large stock of information， lecture。 75、老姜辣味大，老人经验多。请教别人不折本，舌头打个滚。Ginger spicy， old experience。 Ask others not to lose money， the tongue play a roll。 76、人生有一道难题，那就是如何使一寸光阴等于一寸生命。Life has a problem， that is how to make an inch of time is an inch of life。 77、知识象烛光，能照亮一个人，也能照亮无数人。Knowledge is like a candle， it can illuminate a person， also can illuminate countless people。 78、三更灯火五更鸡，正是男儿读书时；黑发不知勤学早，白首方悔读书迟。The night， is the man； energy-saving， white square regret later reading。 79、业精于勤，荒于嬉，行成于思，毁于随。Efficiency comes from diligence。， shortage in the play， the line into Si， destroyed with。 80、包子有肉，不在皮上；人有学问，不挂嘴上。The steamed stuffed bun with meat， not on the skin； people have the knowledge， not on the mouth。 81、虚心的人，常想己之短；骄傲的人，常夸己之长。An open-minded person， often think oneself is short； proud of people， often boast of their long。 82、吾尝终日不食，终夜不寝，以思无益，不如学也。I try not eat all day long， all night without sleep， to think of useless, it is better to school。 83、试试并非受罪，问问并不吃亏。善于发问的人，知识丰富。Try not to suffer, ask does not suffer。 The man who is good at asking questions, knowledge is rich。 84、做一个积极主动的人，最重要的是心，热爱生命，勤奋实干，开放进取。To be a positive person, the most important is the heart, love life, hard work, open up。 85、学在苦中求，艺在勤中练。不怕学问浅，就怕志气短。Learn in the pain, art in the ground to practice. Not afraid of shallow knowledge, short ambition. 86、泰山不是垒的，学问不是吹的。天不言自高，地不语自厚。Taishan is not a barrier, learning is not blowing. Day never from, not a word from the thick. 87、贵有恒何必三更眠五更起，最无益只怕一日曝十日寒。Thank you why sleep before midnight, the most useless if one day ten day of cold exposure. 88、汗水和丰收是忠实的伙伴，勤学和知识是一对最美丽的情侣。Sweat and harvest is a faithful companion, learning and knowledge is one of the most beautiful couple. 89、不实心不成事，不虚心不知事。不自是者博闻，不自满者受益。Don’t not do not know solid things, with an open mind. Not since the CMP is no room for complacency, benefit. 90、好高骛远的一无所得，埋头苦干的获得知识。百艺通，不如一艺精。Ambitious be nowhere to acquire knowledge, work with quiet hard application. One hundred arts, as an art. 91、只有努力攀登顶峰的人，才能把顶峰踩在脚下。困难是人的教科书。only by trying to reach the top can the top step at the foot of the mountain. Difficult is the textbook of human. 92、人唯虚，始能知人。满招损，谦受益。满必溢，骄必败。only empty, can only be people. Pride hurts modesty benefits. Full will overflow, pride comes before a fall. 93、上如阶尽管费力，却一步比一步高。不经过琢磨，宝石也不会发光。On the first step, if the effort, but one step higher than one step. Not after pondering, the gem will not shine. 94、虚心使人进步，骄傲使人落后。虚心的人学十算一，骄傲的人学一当十。Modesty helps one to progress, conceit makes one lag behind. An open-minded person studies ten, a proud man, when ten. 95、学习如钻探石油，钻得愈深，愈能找到知识的精髓。先学爬，然后学走。Learning such as drilling, drilling deeper, more able to find the essence of knowledge. Learn to crawl before you go. 96、强中更有强中手，莫向人前自夸口。满足现在的成就，就窒息了未来。Diamond cut diamond., Mo to the people before the glory. To meet the present achievements, the future of suffocation. 97、说大话的人像爆竹，响一声就完了。鉴难明，始能照物；衡唯平，始能权物。Talk like firecrackers, a sound. Kam Ming was difficult, as matter； balance can only be the right thing Weiping. 98、日日行，不怕千万里；时时学，不怕千万卷。多练多乖，不练就呆。Every day, not afraid of thousands of miles； always learn, not afraid of ten million volumes. Practice good, do not have to stay. 99、宽阔的河平静，博学的人谦虚。秀才不怕衣衫破，就怕肚子没有货。The wide river is quiet, the learned man is humble. Not afraid of breaking the scholar clothes, but the stomach is not available. 100、一个不想蹚过小河的人，自然不想远涉重洋。针越用越明，脑越用越灵。One does not want to wade the stream of people, naturally do not want to travel across many seas. The more using the needle, the more the brain uses.","categories":[{"name":"Geek","slug":"Geek","permalink":"https://casuor.top/categories/Geek/"}],"tags":[]},{"title":"质数的孤独","slug":"reading-质数的孤独","date":"2020-03-31T16:00:00.000Z","updated":"2020-10-28T09:58:54.889Z","comments":true,"path":"2020/04/01/reading-质数的孤独/","link":"","permalink":"https://casuor.top/2020/04/01/reading-%E8%B4%A8%E6%95%B0%E7%9A%84%E5%AD%A4%E7%8B%AC/","excerpt":"","text":"质数的孤独【1】：哪种比较孤独：是活在自己的世界里，谁也不爱，还是心里爱着一个人，却始终无法向爱靠近？ –保罗·乔尔达诺 《质数的孤独》 【2】：越长大，越觉得孤独竟是生命的必然，每个人都是质数列中孤单却特别的存在。或许，说不上特别，也就算个普普通通，再或者说，用＂普通＂都夸张了些。我们都是那孤独的质数，我们都承受着质数的孤独。 –保罗·乔尔达诺 《质数的孤独》 【3】：选择只是几秒钟的事，然后用余下时间来还债。 –保罗·乔尔达诺 《质数的孤独》 【4】：与人交往都是一样的，就像一盘棋的开局，没有必要别出心裁，那毫无用处，因为两个人想要达到的目的是一样的，接下来这盘棋会自动往下进行，只有到了这个时候，谋略才能排得上用场。 –保罗·乔尔达诺 《质数的孤独》 【5】：那些我们不爱的人对我们的爱只停留在表面，很快就会挥发掉。 –保罗·乔尔达诺 《质数的孤独》 【6】：质数只能被一和它自身整除。在自然数的无穷序列中，它们处于自己的位置上，和其他所有数字一样，被前后两个数字挤着，但它们彼此间的距离却比其他数字更远一步。它们是多疑而又孤独的数字，正是由于这一点，马蒂亚觉得它们非常奇妙….. 在大学一年级的一门课上，马蒂亚知道，在质数当中还有一些更加特别的成员，数学家称之为“孪生质数”，它们是离得很近的一对质数，几乎是彼此相邻。 –保罗·乔尔达诺 《质数的孤独》 【7】：世上多余的事情，不管以什么形式出现，都与他毫无关系，当这些事与他内心的平衡以及他理性的判断发生抵触时，他宁愿视而不见，轻而易举地装作它们并不存在。如果一个障碍物出现在他面前，阻挡了他的道路，他会绕过障碍继续前进，一丝一毫也不会改变自己前行的步伐，而且会很快忘掉这个障碍。他几乎从来没有犹豫过。 –保罗·乔尔达诺 《质数的孤独》 【8】：她以一种冷漠的猎奇心理看着自己的软弱与偏执再次暴露出来，这一次她完全听任它们的摆布，反正她已是无能为力了。与自己的某些方面过不去只能落得个徒劳无功的下场，爱丽丝告诫自己，同时惬意地回想着自己的少女时代。 –保罗·乔尔达诺 《质数的孤独》 【9】：他联想到一种已经耗尽的潜力，还想到磁场中一条条看不见的磁力线，原来它们还通过空气维系在一起，而如今已荡然无存。 –保罗·乔尔达诺 《质数的孤独》 【10】：Choices are made in brief seconds and paid for in the time that remains. 用几秒钟作出选择，然后用余生为此付出代价。 –保罗·乔尔达诺 《质数的孤独》 【11】：质数只能被一和它自身整除。在自然数的无穷序列中，它们处于自己的位置上，和其他的所有数字一样，被前后两个数字挤着，但它们彼此间的距离却比其他所有数字更远一步。它们是多疑而又孤独的数字。 –保罗·乔尔达诺 《质数的孤独》 【12】：最近一年，在她和马丁分手之后，就开始感到自己与这个地方格格不入，也开始感觉到彻骨的寒冷。寒风吹干了她的皮肤，即便到了夏天也不能完全恢复弹性，然而，真要离开这里，她又下不了决心，她已经对这个地方产生了依赖，被这里深深地感染了，通常，只有那些对身体有害的东西才能让人如此上瘾。 –保罗·乔尔达诺 《质数的孤独》 【13】：在他们两人的头上浮现出一个巨大的对话框，里面写满了他们要说的话，但他们都竭力回避，双目低垂。 –保罗·乔尔达诺 《质数的孤独》 【14】：他知道这个世界只会越来越混乱，噪音最终会大到覆盖住所所有的信号，但是他相信，只要注意约束好自己的每一个动作，就会减少一些使世界缓慢解体的罪恶。 –保罗·乔尔达诺 《质数的孤独》 【15】：她用力压平双眼，想把眼球从眼眶里挤出来，让它们化作锋利的碎片，刺入每一个与她的目光相遇的男孩子的肺腑、她希望自己的目光不放过任何一个人，从而给他们留下挥之不去的印记。 –保罗·乔尔达诺 《质数的孤独》 【16】：法比奥似乎确切地掌握了献殷勤之道，他遵守时间，还会掌握说话的分寸，就像在奉行着某种外交礼仪。他能洞悉爱丽丝那深深的痛苦，但只作为旁观者，处在边缘。世上多余的事情，不管以什么形式出现，都与他毫无干系，当这些事与他内心的平衡以及他理性的判断发生抵触时，他宁愿视而不见，轻而易举地装作它们并不存在。如果一个障碍出现在他面前，阻挡了他的道路，他会绕过障碍继续前行，一丝一毫也不会改变自己前行的步伐，而且会很快忘掉这个障碍。他几乎从来没有犹豫过。 –保罗·乔尔达诺 《质数的孤独》 【17】：他们二人的宇宙正经历着缓慢而难以察觉的相互渗透，就像两颗行星在围绕同一个轴心运行，它们的轨道越来越近，注定会在时空的某一点上相会。 –保罗·乔尔达诺 《质数的孤独》 【18】：她想起那次躺在山谷里，被积雪掩埋的样子。想起那种天籁般的寂静。现在也和那时一样，没人知道她在哪里。这一次也同样没人会来，但她已不再有任何期待了。 –保罗·乔尔达诺 《质数的孤独》 【19】：然而，他越是努力把问题简单化，就越觉得混乱。他觉得自己像一只小虫被黏在了黏黏糊糊的蜘蛛网上，越是想挣脱，就被缠得越紧。 –保罗·乔尔达诺 《质数的孤独》 【20】：他的这个秘密有着一个恐怖的名字，它就像一块尼龙布一样，遮蔽住他全部的思维，使他透不过气来。他待在那里，脑子里反复思量着这件事，就像在考虑一桩他迟早要为之付出代价的罪责。……一种罪恶感从天而降，落在他身上，就好像在用脏水淋浴一样。这些脏水透入他的皮肤，隐藏在他的脏腑中，就像屋檐吞噬着老房子的墙壁那样，让他慢慢腐烂。 –保罗·乔尔达诺 《质数的孤独》 【21】：日子一天天地过去，就像溶液一样流过皮肤，每天都会从爱丽丝的文身上和他们两人的记忆中冲刷掉薄薄的一层颜色，但是文身的轮廓就像生活的环境一样依然存在着，黑色线条依然清晰，只是其中的颜色已经彼此混合在一起，最终褪成一种暗淡、单一的色调，几乎失去了任何意义。 –保罗·乔尔达诺 《质数的孤独》 【22】：平时他们也很少说话，却在一起消磨时光，他们各自专注着只属于自己的那道深渊，与对方既形影不离，又互不侵犯，不需要费很多口舌。 –保罗·乔尔达诺 《质数的孤独》 【23】：质数只能被一和它自身整除。在自然数的无穷序列中，它们处于自己的位置上，和其他所有数字一样，被前后两个数字挤着，但它们彼此间的距离却比其他数字更远一步。它们是多疑而又孤独的数字，正是由于这一点，马蒂亚觉得它们非常奇妙。有时候他会认为，它们是误入到这个序列中的，就像是串在一条项链上的小珍珠一样被禁锢在那里。有时候他也会怀疑，也许它们希望像其他所有数字一样普普通通，只是出于某种原因无法如愿。这后一种想法经常在晚间光顾他的大脑，夹杂在睡梦前凌乱而交错的各种形象之中，这个时候，他的大脑会非常疲顿，不愿再编织谎言。 –保罗·乔尔达诺 《质数的孤独》 【24】：马蒂亚的声音再也不会令他的胃搅动了，但他对马蒂亚的那种意思依然存在，而且还将永远保留，并成为他今后所有感情的唯一真实的参考标准。 –保罗·乔尔达诺 《质数的孤独》 【25】：他们俩谁也没提议放点儿音乐听。他们什么也不想做，只是待在那里，等待着星期天下午渐渐逝去，等待着到时间做那些非做不可的事，比如吃饭，睡觉和迎接新的一周。九月焦黄的日光从敞开的窗子里透射进来，街上断断续续的细碎声响也随后飘进了房间。 –保罗·乔尔达诺 《质数的孤独》","categories":[{"name":"Reading","slug":"Reading","permalink":"https://casuor.top/categories/Reading/"}],"tags":[]},{"title":"Joplin & Yosoro","slug":"res_Joplin&Yosoro","date":"2020-03-31T16:00:00.000Z","updated":"2020-10-28T09:58:54.891Z","comments":true,"path":"2020/04/01/res_Joplin&Yosoro/","link":"","permalink":"https://casuor.top/2020/04/01/res_Joplin&Yosoro/","excerpt":"","text":"JoplinJoplin is a free, open source note taking and to-do application, which can handle a large number of notes organised into notebooks. The notes are searchable, can be copied, tagged and modified either from the applications directly or from your own text editor. The notes are in Markdown format. Notes exported from Evernote via .enex files can be imported into Joplin, including the formatted content (which is converted to Markdown), resources (images, attachments, etc.) and complete metadata (geolocation, updated time, created time, etc.). Plain Markdown files can also be imported. The notes can be synchronised with various cloud services including Nextcloud, Dropbox, OneDrive, WebDAV or the file system (for example with a network directory). When synchronising the notes, notebooks, tags and other metadata are saved to plain text files which can be easily inspected, backed up and moved around. The application is available for Windows, Linux, macOS, Android and iOS (the terminal app also works on FreeBSD). A Web Clipper, to save web pages and screenshots from your browser, is also available for Firefox and Chrome. installationwindows others YosoroA beautiful Markdown Cloud Drive notebook desktop application. installationhttps://github.com/IceEnd/Yosoro","categories":[{"name":"Resource","slug":"Resource","permalink":"https://casuor.top/categories/Resource/"}],"tags":[]},{"title":"Windows10必备自启动效率工具","slug":"res-Tools","date":"2020-03-12T16:00:00.000Z","updated":"2020-10-28T09:58:54.890Z","comments":true,"path":"2020/03/13/res-Tools/","link":"","permalink":"https://casuor.top/2020/03/13/res-Tools/","excerpt":"","text":"windows10 必备自启动效率工具QuickLook开源地址https://github.com/QL-Win/QuickLook 功能简介 移植mac的一键预览功能 1.下载 建议直接在Microsoft Store搜索下载 2.使用 3.支持文件类型 PS:插件安装等详情需前往官网查看 EarTrumpet开源地址https://github.com/File-New-Project/EarTrumpet 功能简介 Volume Control for Windows 1.下载 建议直接在Microsoft Store搜索下载 2.使用 ①自定义快捷键 ②鼠标滚轮调节音量 3.预览 Snipaste开源地址https://zh.snipaste.com/ 功能简介 截图 + 贴图 1.下载 建议直接在Microsoft Store搜索下载 2.使用 截图默认为 F1，贴图为 F3 Snipaste更多高阶技巧 uTools官网https://u.tools/ PS:基于electron前端开发,社区贡献者巨多,并非开源,但也不收费 功能简介 程序快速启动器+庞大的插件系统 1.下载 [官网直达] 2.使用 [alt+space]无限可能 uTools更多技巧 3.预览 天若OCR开源版开源地址https://github.com/AnyListen/tianruoocr PS:作者基于@天若幽心 开源的代码进行完善制作而成,已停止维护. 作者维护的同类型项目:树洞ocr 功能简介 简单来说:文字识别提取,翻译,排版等 1.下载 天若OCR开源版 树洞OCR 2.使用","categories":[{"name":"Resource","slug":"Resource","permalink":"https://casuor.top/categories/Resource/"}],"tags":[]},{"title":"Taylor Swift","slug":"pic-Taylor","date":"2020-03-11T16:00:00.000Z","updated":"2020-10-28T09:58:54.887Z","comments":true,"path":"2020/03/12/pic-Taylor/","link":"","permalink":"https://casuor.top/2020/03/12/pic-Taylor/","excerpt":"","text":"声明: 本图源自:WallpaperAbyss一个不错的搜图网站","categories":[],"tags":[{"name":"Picture","slug":"Picture","permalink":"https://casuor.top/tags/Picture/"}]},{"title":"Oh-my-posh for Windows","slug":"geek_ohmyposhl","date":"2020-01-23T16:00:00.000Z","updated":"2020-10-28T09:58:54.885Z","comments":true,"path":"2020/01/24/geek_ohmyposhl/","link":"","permalink":"https://casuor.top/2020/01/24/geek_ohmyposhl/","excerpt":"","text":"oh my posh for windowsmaininstall&amp;config for powershellInstall-Module posh-git -Scope CurrentUser Install-Module oh-my-posh -Scope CurrentUser $profile cd C:\\Users\\16877\\Documents\\WindowsPowerShell\\ ls New-Item &quot;Microsoft.PowerShell_profile.ps1&quot; -type file code Microsoft.PowerShell_profile.ps1 Import-Module posh-git Import-Module oh-my-posh Set-Theme Paradoxdetail for teminal{ &quot;$schema&quot;: &quot;https://aka.ms/terminal-profiles-schema&quot;, &quot;globals&quot; : { &quot;alwaysShowTabs&quot; : true, &quot;copyOnSelect&quot; : false, &quot;defaultProfile&quot;: &quot;{61c54bbd-c2c6-5271-96e7-009a87ff44bf}&quot;, &quot;initialCols&quot; : 90, &quot;initialRows&quot; : 30, &quot;requestedTheme&quot; : &quot;system&quot;, &quot;showTabsInTitlebar&quot; : true, &quot;showTerminalTitleInTitlebar&quot; : true, &quot;wordDelimiters&quot; : &quot; ./\\\\()\\&quot;&apos;-:,.;&lt;&gt;~!@#$%^&amp;*|+=[]{}~?\\u2502&quot; }, &quot;profiles&quot;: [ { &quot;guid&quot;: &quot;{61c54bbd-c2c6-5271-96e7-009a87ff44bf}&quot;, &quot;name&quot;: &quot;Windows PowerShell&quot;, &quot;commandline&quot;: &quot;powershell.exe&quot;, &quot;hidden&quot;: false, &quot;acrylicOpacity&quot;: 0.9, &quot;colorScheme&quot;: &quot;MaterialDark&quot;, &quot;cursorColor&quot;: &quot;#ffea2e&quot;, &quot;cursorShape&quot;: &quot;filledBox&quot;, &quot;fontFace&quot;: &quot;Hack&quot;, &quot;fontSize&quot;: 12, &quot;historySize&quot;: 9001, &quot;padding&quot;: &quot;0, 0, 0, 0&quot;, &quot;snapOnInput&quot;: true, &quot;startingDirectory&quot;: &quot;%USERPROFILE%&quot;, &quot;useAcrylic&quot;: true }, { &quot;guid&quot;: &quot;{0caa0dad-35be-5f56-a8ff-afceeeaa6101}&quot;, &quot;name&quot;: &quot;cmd&quot;, &quot;commandline&quot;: &quot;cmd.exe&quot;, &quot;hidden&quot;: false }, { &quot;guid&quot;: &quot;{b453ae62-4e3d-5e58-b989-0a998ec441b8}&quot;, &quot;hidden&quot;: false, &quot;name&quot;: &quot;Azure Cloud Shell&quot;, &quot;source&quot;: &quot;Windows.Terminal.Azure&quot; } ], &quot;schemes&quot;: [ { &quot;name&quot;: &quot;Solarized Dark - Patched&quot;, &quot;black&quot;: &quot;#002831&quot;, &quot;red&quot;: &quot;#d11c24&quot;, &quot;green&quot;: &quot;#738a05&quot;, &quot;yellow&quot;: &quot;#a57706&quot;, &quot;blue&quot;: &quot;#2176c7&quot;, &quot;purple&quot;: &quot;#c61c6f&quot;, &quot;cyan&quot;: &quot;#259286&quot;, &quot;white&quot;: &quot;#eae3cb&quot;, &quot;brightBlack&quot;: &quot;#475b62&quot;, &quot;brightRed&quot;: &quot;#bd3613&quot;, &quot;brightGreen&quot;: &quot;#475b62&quot;, &quot;brightYellow&quot;: &quot;#536870&quot;, &quot;brightBlue&quot;: &quot;#708284&quot;, &quot;brightPurple&quot;: &quot;#5956ba&quot;, &quot;brightCyan&quot;: &quot;#819090&quot;, &quot;brightWhite&quot;: &quot;#fcf4dc&quot;, &quot;background&quot;: &quot;#001e27&quot;, &quot;foreground&quot;: &quot;#708284&quot; }, { &quot;background&quot;: &quot;#282C34&quot;, &quot;black&quot;: &quot;#282C34&quot;, &quot;blue&quot;: &quot;#61AFEF&quot;, &quot;brightBlack&quot;: &quot;#5A6374&quot;, &quot;brightBlue&quot;: &quot;#61AFEF&quot;, &quot;brightCyan&quot;: &quot;#56B6C2&quot;, &quot;brightGreen&quot;: &quot;#98C379&quot;, &quot;brightPurple&quot;: &quot;#C678DD&quot;, &quot;brightRed&quot;: &quot;#E06C75&quot;, &quot;brightWhite&quot;: &quot;#DCDFE4&quot;, &quot;brightYellow&quot;: &quot;#E5C07B&quot;, &quot;cyan&quot;: &quot;#56B6C2&quot;, &quot;foreground&quot;: &quot;#DCDFE4&quot;, &quot;green&quot;: &quot;#98C379&quot;, &quot;name&quot;: &quot;One Half Dark&quot;, &quot;purple&quot;: &quot;#C678DD&quot;, &quot;red&quot;: &quot;#E06C75&quot;, &quot;white&quot;: &quot;#DCDFE4&quot;, &quot;yellow&quot;: &quot;#E5C07B&quot; }, { &quot;name&quot;: &quot;Material&quot;, &quot;black&quot;: &quot;#002831&quot;, &quot;red&quot;: &quot;#b7141f&quot;, &quot;green&quot;: &quot;#457b24&quot;, &quot;yellow&quot;: &quot;#f6981e&quot;, &quot;blue&quot;: &quot;#134eb2&quot;, &quot;purple&quot;: &quot;#560088&quot;, &quot;cyan&quot;: &quot;#0e717c&quot;, &quot;white&quot;: &quot;#efefef&quot;, &quot;brightBlack&quot;: &quot;#424242&quot;, &quot;brightRed&quot;: &quot;#e83b3f&quot;, &quot;brightGreen&quot;: &quot;#7aba3a&quot;, &quot;brightYellow&quot;: &quot;#ffea2e&quot;, &quot;brightBlue&quot;: &quot;#54a4f3&quot;, &quot;brightPurple&quot;: &quot;#aa4dbc&quot;, &quot;brightCyan&quot;: &quot;#26bbd1&quot;, &quot;brightWhite&quot;: &quot;#d9d9d9&quot;, &quot;background&quot;: &quot;#eaeaea&quot;, &quot;foreground&quot;: &quot;#232322&quot; }, { &quot;name&quot;: &quot;MaterialDark&quot;, &quot;black&quot;: &quot;#212121&quot;, &quot;red&quot;: &quot;#b7141f&quot;, &quot;green&quot;: &quot;#457b24&quot;, &quot;yellow&quot;: &quot;#f6981e&quot;, &quot;blue&quot;: &quot;#134eb2&quot;, &quot;purple&quot;: &quot;#560088&quot;, &quot;cyan&quot;: &quot;#0e717c&quot;, &quot;white&quot;: &quot;#efefef&quot;, &quot;brightBlack&quot;: &quot;#424242&quot;, &quot;brightRed&quot;: &quot;#e83b3f&quot;, &quot;brightGreen&quot;: &quot;#7aba3a&quot;, &quot;brightYellow&quot;: &quot;#ffea2e&quot;, &quot;brightBlue&quot;: &quot;#54a4f3&quot;, &quot;brightPurple&quot;: &quot;#aa4dbc&quot;, &quot;brightCyan&quot;: &quot;#26bbd1&quot;, &quot;brightWhite&quot;: &quot;#d9d9d9&quot;, &quot;background&quot;: &quot;#001e27&quot;, &quot;foreground&quot;: &quot;#e5e5e5&quot; } ], &quot;keybindings&quot;: [ { &quot;command&quot;: &quot;closePane&quot;, &quot;keys&quot;: [ &quot;ctrl+w&quot; ] }, { &quot;command&quot;: &quot;copy&quot;, &quot;keys&quot;: [ &quot;ctrl+c&quot; ] }, { &quot;command&quot;: &quot;duplicateTab&quot;, &quot;keys&quot;: [ &quot;ctrl+shift+d&quot; ] }, { &quot;command&quot;: &quot;newTab&quot;, &quot;keys&quot;: [ &quot;ctrl+N&quot; ] }, { &quot;command&quot;: &quot;newTabProfile0&quot;, &quot;keys&quot;: [ &quot;ctrl+shift+1&quot; ] }, { &quot;command&quot;: &quot;newTabProfile1&quot;, &quot;keys&quot;: [ &quot;ctrl+shift+2&quot; ] }, { &quot;command&quot;: &quot;newTabProfile2&quot;, &quot;keys&quot;: [ &quot;ctrl+shift+3&quot; ] }, { &quot;command&quot;: &quot;newTabProfile3&quot;, &quot;keys&quot;: [ &quot;ctrl+shift+4&quot; ] }, { &quot;command&quot;: &quot;newTabProfile4&quot;, &quot;keys&quot;: [ &quot;ctrl+shift+5&quot; ] }, { &quot;command&quot;: &quot;newTabProfile5&quot;, &quot;keys&quot;: [ &quot;ctrl+shift+6&quot; ] }, { &quot;command&quot;: &quot;newTabProfile6&quot;, &quot;keys&quot;: [ &quot;ctrl+shift+7&quot; ] }, { &quot;command&quot;: &quot;newTabProfile7&quot;, &quot;keys&quot;: [ &quot;ctrl+shift+8&quot; ] }, { &quot;command&quot;: &quot;newTabProfile8&quot;, &quot;keys&quot;: [ &quot;ctrl+shift+9&quot; ] }, { &quot;command&quot;: &quot;nextTab&quot;, &quot;keys&quot;: [ &quot;ctrl+tab&quot; ] }, { &quot;command&quot;: &quot;openNewTabDropdown&quot;, &quot;keys&quot;: [ &quot;ctrl+shift+space&quot; ] }, { &quot;command&quot;: &quot;openSettings&quot;, &quot;keys&quot;: [ &quot;ctrl+,&quot; ] }, { &quot;command&quot;: &quot;paste&quot;, &quot;keys&quot;: [ &quot;ctrl+shift+v&quot; ] }, { &quot;command&quot;: &quot;prevTab&quot;, &quot;keys&quot;: [ &quot;ctrl+shift+tab&quot; ] }, { &quot;command&quot;: &quot;scrollDown&quot;, &quot;keys&quot;: [ &quot;ctrl+shift+down&quot; ] }, { &quot;command&quot;: &quot;scrollDownPage&quot;, &quot;keys&quot;: [ &quot;ctrl+shift+pgdn&quot; ] }, { &quot;command&quot;: &quot;scrollUp&quot;, &quot;keys&quot;: [ &quot;ctrl+shift+up&quot; ] }, { &quot;command&quot;: &quot;scrollUpPage&quot;, &quot;keys&quot;: [ &quot;ctrl+shift+pgup&quot; ] }, { &quot;command&quot;: &quot;switchToTab0&quot;, &quot;keys&quot;: [ &quot;ctrl+alt+1&quot; ] }, { &quot;command&quot;: &quot;switchToTab1&quot;, &quot;keys&quot;: [ &quot;ctrl+alt+2&quot; ] }, { &quot;command&quot;: &quot;switchToTab2&quot;, &quot;keys&quot;: [ &quot;ctrl+alt+3&quot; ] }, { &quot;command&quot;: &quot;switchToTab3&quot;, &quot;keys&quot;: [ &quot;ctrl+alt+4&quot; ] }, { &quot;command&quot;: &quot;switchToTab4&quot;, &quot;keys&quot;: [ &quot;ctrl+alt+5&quot; ] }, { &quot;command&quot;: &quot;switchToTab5&quot;, &quot;keys&quot;: [ &quot;ctrl+alt+6&quot; ] }, { &quot;command&quot;: &quot;switchToTab6&quot;, &quot;keys&quot;: [ &quot;ctrl+alt+7&quot; ] }, { &quot;command&quot;: &quot;switchToTab7&quot;, &quot;keys&quot;: [ &quot;ctrl+alt+8&quot; ] }, { &quot;command&quot;: &quot;switchToTab8&quot;, &quot;keys&quot;: [ &quot;ctrl+alt+9&quot; ] } ] }ExtrafontHackCascadia Code colortoolscoop install colortool # 注：-s 代表 schemes colortool -s # 临时查看 colortool &lt;主题名称&gt; # 定义默认值 colortool -d &lt;主题名称&gt;preview ReferenceOh my posh","categories":[{"name":"Geek","slug":"Geek","permalink":"https://casuor.top/categories/Geek/"}],"tags":[]},{"title":"Oh-my-zsh for Manjaro","slug":"geek_oh-my-zsh","date":"2020-01-12T16:00:00.000Z","updated":"2020-10-28T09:58:54.885Z","comments":true,"path":"2020/01/13/geek_oh-my-zsh/","link":"","permalink":"https://casuor.top/2020/01/13/geek_oh-my-zsh/","excerpt":"","text":"oh my zshinstallinstall zsh#查看是否已安装 zsh --version ＃查看已安装的shell cat /etc/shells #安装zsh yay -S zsh #pacman -S zsh #切换为zsh #chsh -s /bin/zsh chsh -s $(which zsh) #查看当前shell #$SHELL --version echo $SHELLinstall oh-my-zshsh -c &quot;$(curl -fsSL https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh)&quot; sh -c &quot;$(wget https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh -O -)&quot;themedirectorycd ~/.oh-my-zsh/themes lschangenano ~/.zshrc #ZSH_THEME=&quot;agnoster&quot; #为agnoster添加时间显示 echo &quot;RPROMPT=&apos;[%*]&apos;&quot; &gt;&gt; $ZSH/themes/agnoster.zsh-theme source ~/.zshrcedit zsh-themeagnoster.zsh-theme confcode agnoster.zsh-theme [Powerline-patched font]In order for this theme to render correctly, you will need a [Powerline-patched font] PS:已经有了，不用安装 [Solarized theme]默认为dark,可切换light [Show informations]Like most prompts, it will only show git information when in a git working directory.However, it goes a step further: everything from the current user andhostname to whether the last call exited with an error to whether backgroundjobs are running in this shell will all be displayed automatically whenappropriate. PS:并非所有theme显示时间 edit# Context: user@hostname (who am I and where am I) #user@hostname &lt;=&gt; %n@%m #太长删其一即可 prompt_context() { if [[ &quot;$USER&quot; != &quot;$DEFAULT_USER&quot; || -n &quot;$SSH_CLIENT&quot; ]]; then prompt_segment black default &quot;%(!.%{%F{yellow}%}.)%n@%m&quot; fi } pluginsｄefault＃tlsr cd ~/.oh-my-zsh/plugins ls启用插件nano ~/.zshrc #plugins=(git zsh-syntax-highlighting zsh-autosuggestions git-open vscode npm npx sublime z)PS:空格问题 custome Also follow these steps if you want to override plugins that ship with your oh-my-zsh installation. To override a plugin with a custom version, put your custom version at $ZSH_CUSTOM/plugins//. For example, if it’s the rvm plugin you want to override, create the directory custom/plugins/rvm and place a file called rvm.plugin.zsh inside of it. PS:dont remember add &lt;plugin_name&gt; to .zshrc example1.Clone this repository in oh-my-zsh’s plugins directory: git clone https://github.com/zsh-users/zsh-syntax-highlighting.git ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-syntax-highlightingPS:自定义plugins-locationgit clone url ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/plugins-name,额不早为啥这样写，应该是和~/.zshrc文件相关 2.Activate the plugin in ~/.zshrc: plugins=( [plugins...] zsh-syntax-highlighting)3.Restart zsh (such as by opening a new instance of your terminal emulator). last preview","categories":[{"name":"Geek","slug":"Geek","permalink":"https://casuor.top/categories/Geek/"}],"tags":[]},{"title":"Manjaro install","slug":"geek_manjaroinstall","date":"2020-01-09T16:00:00.000Z","updated":"2020-10-28T09:58:54.884Z","comments":true,"path":"2020/01/10/geek_manjaroinstall/","link":"","permalink":"https://casuor.top/2020/01/10/geek_manjaroinstall/","excerpt":"","text":"manjaro config sudo pacman-mirrors -i -c China -m rank sudo pacman -Syy sudo pacman -S nano nano /etc/pacman.conf [archlinuxcn] SigLevel = Optional TrustedOnly Server = https://mirrors.ustc.edu.cn/archlinuxcn/$arch sudo pacman -S archlinuxcn-keyring sudo pacman -Syyu sudo pacman -S fcitx-im #全部安装 sudo pacman -S fcitx-configtool sudo pacman -S fcitx-sogoupinyin nano ~/.xprofile export GTK_IM_MODULE=fcitx export QT_IM_MODULE=fcitx export XMODIFIERS=&quot;@im=fcitx&quot; #restart sudo pacman -S yay yay -S octopi[application list]latte-dock layout latte-dock typora chrome visual studio code jetbrains-toolbox wps-office sudo pacman -S wps-office-mui-zh-cn sudo pacman -S ttf-wps-fonts electron-netease-cloud-music bleachbit baidunetdisk spotify zsh sudo nano /etc/hosts 199.232.28.133 raw.githubusercontent.com sh -c &quot;$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)&quot; sh -c &quot;$(wget -O- https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)&quot; git clone https://github.com/zsh-users/zsh-syntax-highlighting.git ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-syntax-highlighting git clone git://github.com/zsh-users/zsh-autosuggestions $ZSH_CUSTOM/plugins/zsh-autosuggestions git clone https://github.com/paulirish/git-open.git $ZSH_CUSTOM/plugins/git-open git clone https://github.com/lukechilds/zsh-nvm ~/.oh-my-zsh/custom/plugins/zsh-nvm #Zsh plugin for installing, updating and loading nvm #地址：https://github.com/lukechilds/zsh-nvm sudo pacman -S autojump #plugins=(git zsh-syntax-highlighting zsh-autosuggestions git-open vscode sublime z zsh-nvm autojump) #source ~/.zshrc nvm install 12.16.2 npm install nrm -g nrm use taobao [ssr配置](https://www.jianshu.com/p/1a1bbff13e22) wget http://www.djangoz.com/ssr#//github.com/the0demiurge/CharlesScripts/blob/master/charles/bin/ssr sudo mv ssr /usr/local/bin sudo chmod 766 /usr/local/bin/ssr ssr install ssr config #设置开机启动 #在/usr/lib/systemd/system/中加入ssr.service [Unit] Description=AutoRunSSR [Service] Type=forking ExecStart=ssr start [Install] WantedBy=multi-user.target systemctl enable ssr.service systemctl start ssr.service #查看状态 systemctl status ssr.service","categories":[{"name":"Geek","slug":"Geek","permalink":"https://casuor.top/categories/Geek/"}],"tags":[]},{"title":"跨平台开发NW.js与Electron(二)","slug":"geek_NWjs&Electron2","date":"2019-12-28T16:00:00.000Z","updated":"2020-10-28T09:58:54.880Z","comments":true,"path":"2019/12/29/geek_NWjs&Electron2/","link":"","permalink":"https://casuor.top/2019/12/29/geek_NWjs&Electron2/","excerpt":"","text":"为桌面应用搭建基础架构工序 构建用户使用路径创建线框图编写测试更新线框图编码确认应用工作正确 安装npm install nw npm install electron创建工作空间(略)package.json cnpm install osenv --save cnom install async --saveindex.html &lt;html&gt; &lt;head&gt; &lt;title&gt;Lorikeet&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;style.css&quot; /&gt; &lt;script src=&quot;app.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;template id=&quot;item-template&quot;&gt; &lt;div class=&quot;item&quot;&gt; &lt;img class=&quot;icon&quot; /&gt; &lt;div class=&quot;filename&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/template&gt; &lt;div id=&quot;toolbar&quot;&gt; &lt;div id=&quot;current-folder&quot;&gt; &lt;script&gt; document.write(getUsersHomeFolder()); &lt;/script&gt; &lt;/div&gt; &lt;/div&gt; &lt;div id=&quot;main-area&quot;&gt;&lt;/div&gt; &lt;/body&gt; &lt;/html&gt;app.js &apos;use strict&apos;; //cnpm install osenv --save //返回个人用户文件夹模块osenv //加载osenv模块 const osenv = require(&apos;osenv&apos;); //加载node.js文件系统模块 const fs = require(&apos;fs&apos;); //加载async模块和Node.js path模块 const async = require(&apos;async&apos;); const path = require(&apos;path&apos;); //获取个人用户文件夹路径 function getUsersHomeFolder() { return osenv.home(); } //getFilesInFoler(),获取文件夹下的列表信息 function getFilesInFoler(folderPath, cb) { fs.readdir(folderPath, cb); } //使用path模块获取文件名 function inspectAndDescribeFile(filePath, cb) { let result = { file: path.basename(filePath), path: filePath, type: &apos;&apos; }; //调用fs.stat会返回一个对象,包含文件类型 fs.stat(filePath, (err, stat) =&gt; { if (err) { cb(err); } else { if (stat.isFile()) { result.type = &apos;file&apos;; } if (stat.isDirectory()) { result.type = &apos;directory&apos;; } cb(err, result); } }); } //使用async模块调用异步函数并收集结果 function inspectAndDescribeFiles(folderPath, files, cb) { async.map(files, (file, asyncCb) =&gt; { let resolvedFilePath = path.resolve(folderPath, file); inspectAndDescribeFile(resolvedFilePath, asyncCb); }, cb); } //创建displayFile函数渲染模版实例 function displayFile(file) { const mainArea = document.getElementById(&apos;main-area&apos;); const template = document.querySelector(&apos;#item-template&apos;); let clone = document.importNode(template.content, true); clone.querySelector(&apos;img&apos;).src = `images/${file.type}.svg`; clone.querySelector(&apos;.filename&apos;).innerText = file.file; mainArea.appendChild(clone); } //创建displayFiles函数来显示列表信息 function displayFiles(err, files) { if (err) { return alert(&apos;对不起,无法显示此文件&apos;); } files.forEach(displayFile); //在displayFiles中将文件信息传递给displayFile函数 } //main(),调用该函数并将用户个人文件夹路径作为参数传递进去, //再将获取到的包含所有文件绝对路径的列表在控制台打印出来 function main() { let folderPath = getUsersHomeFolder(); getFilesInFoler(folderPath, (err, files) =&gt; { if (err) { return alert(&apos;对不起,无法加载你的Home&apos;); } inspectAndDescribeFiles(folderPath, files, displayFiles); }); } main();style.css body { padding: 0; margin: 0; font-family: &apos;Helvetica&apos;, &apos;Arial&apos;, &apos;sans&apos;; } #toolbar { top: 0px; position: fixed; background: rgb(12, 59, 97); width: 100%; z-index: 2; } #current-folder { float: left; color: white; background: rgba(0, 0, 0, 0.5); padding: 0.5em 1em; min-width: 10em; border-radius: 0.2em; margin: 1em; } #main-area { clear: both; margin: 2em; margin-top: 3em; z-index: 1; } .item { position: relative; float: left; padding: 1em; margin: 1em; width: 6em; height: 6em; text-align: center; } .item .filename { padding-top: 1em; font-size: 10pt; }","categories":[{"name":"Geek","slug":"Geek","permalink":"https://casuor.top/categories/Geek/"}],"tags":[]},{"title":"epub格式解析","slug":"geek_epub格式解析","date":"2019-12-25T16:00:00.000Z","updated":"2020-10-28T09:58:54.882Z","comments":true,"path":"2019/12/26/geek_epub格式解析/","link":"","permalink":"https://casuor.top/2019/12/26/geek_epub%E6%A0%BC%E5%BC%8F%E8%A7%A3%E6%9E%90/","excerpt":"","text":"epub格式解析Referenceepub格式解析生成Kindle可读的mobi和PDF电子书 Content一个标准的未加密的 epub 电子书大致由以下三部分组成： META-INF文件夹:包含container.xmlOEBPS文件夹:包含 images，xhtml文件，css样式和 content.opf 文件mimetype:内容为 application/epub+zip META-INF文件夹META-INF 用于存放电子书信息，默认情况包含一个 container.xml 文件： &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;container version=&quot;1.0&quot; xmlns=&quot;urn:oasis:names:tc:opendocument:xmlns:container&quot;&gt; &lt;rootfiles&gt; &lt;rootfile full-path=&quot;OEBPS/content.opf&quot; media-type=&quot;application/oebps-package+xml&quot;/&gt; &lt;/rootfiles&gt; &lt;/container&gt;该文件告诉电子书阅读器，文件的根文件路径和格式。除去 container.xml 文件外，标准还规定了其他可选文件： manifest.xml 文件列表metadata.xml 元数据sigatures.xml 数字签名encryption.xml 加密rights.xml 权限管理 OEBPS文件夹OPF文件opf 文件是 epub 最为重要的文件，是标准的 xml 文件，文件的根元素是 &lt;package&gt; &lt;package version=&quot;2.0&quot; unique-identifier=&quot;BookId&quot; xmlns=&quot;http://www.idpf.org/2007/opf&quot;&gt;此文件的主要内容由下面组成： 第一部分，&lt;metadata&gt; 元数据，包含书籍的出版信息，主要由两个子元素组成 dc:metadata 元素，使用 Dublin Core， 包含 15 项核心元素：dc:titledc:creator 责任者dc:subject 主题关键词dc:descriptiondc:publisherdc:contributordc:datedc:typedc:formatdc:identifierdc:source 来源dc:languagedc:relationdc:coverage 覆盖范围dc:rights 权限描述 meta 标签，扩展元素，如果有信息在上面标签中无法描述，则扩展到该meta中 举例 &lt;metadata xmlns:opf=&quot;http://www.idpf.org/2007/opf&quot; xmlns:dc=&quot;http://purl.org/dc/elements/1.1/&quot;&gt; &lt;dc:language&gt;zh-CN&lt;/dc:language&gt; &lt;dc:title&gt;圣殿春秋&lt;/dc:title&gt; &lt;dc:creator opf:role=&quot;aut&quot; opf:file-as=&quot;雨浪飘零&quot;&gt;『英』肯·福莱特&lt;/dc:creator&gt; &lt;dc:publisher&gt;上海译文出版社&lt;/dc:publisher&gt; &lt;meta content=&quot;0.9.6&quot; name=&quot;Sigil version&quot; /&gt; &lt;dc:date xmlns:opf=&quot;http://www.idpf.org/2007/opf&quot; opf:event=&quot;modification&quot;&gt;2016-07-16&lt;/dc:date&gt; &lt;dc:identifier opf:scheme=&quot;UUID&quot; id=&quot;BookId&quot;&gt;urn:uuid:97cabb7a-2ab9-4fe2-a56b-c075114f2187&lt;/dc:identifier&gt; &lt;meta name=&quot;cover&quot; content=&quot;cover.jpg&quot; /&gt; &lt;/metadata&gt;第二部分为 &lt;mainfest&gt; 文件列表，该列表中包含出版物的所有文件，每一行由一个item构成 &lt;item id=&quot;ncx&quot; href=&quot;toc.ncx&quot; media-type=&quot;application/x-dtbncx+xml&quot;/&gt;其中： id 为文件 id href 为文件相对路径 media-type 为文件的媒体类型 &lt;manifest&gt; &lt;item id=&quot;ncx&quot; href=&quot;toc.ncx&quot; media-type=&quot;application/x-dtbncx+xml&quot;/&gt; &lt;item id=&quot;Preface03.xhtml&quot; href=&quot;Text/Preface03.xhtml&quot; media-type=&quot;application/xhtml+xml&quot;/&gt; &lt;item id=&quot;Part00.xhtml&quot; href=&quot;Text/Part00.xhtml&quot; media-type=&quot;application/xhtml+xml&quot;/&gt; &lt;item id=&quot;Part01.xhtml&quot; href=&quot;Text/Part01.xhtml&quot; media-type=&quot;application/xhtml+xml&quot;/&gt; &lt;item id=&quot;Part02.xhtml&quot; href=&quot;Text/Part02.xhtml&quot; media-type=&quot;application/xhtml+xml&quot;/&gt; &lt;item id=&quot;appendix.xhtml&quot; href=&quot;Text/appendix.xhtml&quot; media-type=&quot;application/xhtml+xml&quot;/&gt; &lt;item id=&quot;main.css&quot; href=&quot;Styles/main.css&quot; media-type=&quot;text/css&quot;/&gt; &lt;item id=&quot;Title.xhtml&quot; href=&quot;Text/Title.xhtml&quot; media-type=&quot;application/xhtml+xml&quot;/&gt; &lt;item id=&quot;Intro1.xhtml&quot; href=&quot;Text/Intro1.xhtml&quot; media-type=&quot;application/xhtml+xml&quot;/&gt; &lt;item id=&quot;Author.html&quot; href=&quot;Text/Author.html&quot; media-type=&quot;application/xhtml+xml&quot;/&gt; &lt;item id=&quot;Preface01.xhtml&quot; href=&quot;Text/Preface01.xhtml&quot; media-type=&quot;application/xhtml+xml&quot;/&gt; &lt;item id=&quot;cover.xhtml&quot; href=&quot;Text/cover.xhtml&quot; media-type=&quot;application/xhtml+xml&quot;/&gt; &lt;item id=&quot;part01.jpg&quot; href=&quot;Images/part01.jpg&quot; media-type=&quot;image/jpeg&quot;/&gt; &lt;item id=&quot;Part06_17.xhtml&quot; href=&quot;Text/Part06_17.xhtml&quot; media-type=&quot;application/xhtml+xml&quot;/&gt; &lt;item id=&quot;chapter.png&quot; href=&quot;Images/chapter.png&quot; media-type=&quot;image/png&quot;/&gt; &lt;item id=&quot;logo.png&quot; href=&quot;Images/logo.png&quot; media-type=&quot;image/png&quot;/&gt; &lt;item id=&quot;cover.jpg&quot; href=&quot;Images/cover.jpg&quot; media-type=&quot;image/jpeg&quot;/&gt; &lt;item id=&quot;cover_slim.jpg&quot; href=&quot;Images/cover~slim.jpg&quot; media-type=&quot;image/jpeg&quot;/&gt; &lt;item id=&quot;Monarch.ttf&quot; href=&quot;Fonts/Monarch.ttf&quot; media-type=&quot;application/x-font-ttf&quot;/&gt; &lt;item id=&quot;backcover.xhtml&quot; href=&quot;Text/backcover.xhtml&quot; media-type=&quot;application/xhtml+xml&quot;/&gt; &lt;item id=&quot;backcover.jpg&quot; href=&quot;Images/backcover.jpg&quot; media-type=&quot;image/jpeg&quot;/&gt; &lt;item id=&quot;backcover_slim.jpg&quot; href=&quot;Images/backcover~slim.jpg&quot; media-type=&quot;image/jpeg&quot;/&gt; &lt;item id=&quot;Info.xhtml&quot; href=&quot;Text/Info.xhtml&quot; media-type=&quot;application/xhtml+xml&quot;/&gt; &lt;/manifest&gt;第三部分为&lt;spine toc=&quot;ncx&quot;&gt;提供图书线性阅读的次序，由子元素 itemref 组成 &lt;itemref idref=&quot;cover.xhtml&quot;&gt;其中 idref 为 manifest 中列出的 id &lt;spine toc=&quot;ncx&quot;&gt; &lt;itemref idref=&quot;cover&quot; /&gt; &lt;itemref idref=&quot;copyright&quot; /&gt; &lt;/spine&gt;第四部分为 &lt;guide&gt; ，列出了电子书的特定页面，比如封面，目录，序言等等，属性值指向文件地址。该部分可选。 &lt;guide&gt; &lt;reference type=&quot;cover&quot; title=&quot;封面&quot; href=&quot;Text/cover.xhtml&quot;/&gt; &lt;/guide&gt;第五部分，&lt;tour&gt; 导读，根据读者的不同水平，按照一定次序选择电子书部分页面组成导读，可选。 NCX文件ncx文件也是 epub 中非常重要的文件，该文件用于电子书的目录，文件命名通常为 toc.ncx，ncx 文件也是一个 xml 文件。ncx 全称为 Navigation Center eXtended。 ncx文件中最主要的节点是 navMap，navMap节点又由很多 navPoint 节点组成，navPoint 节点由 navLabel 和 content 节点组成。 &lt;navMap&gt; &lt;navPoint id=&quot;navPoint-1&quot; playOrder=&quot;1&quot;&gt; &lt;navLabel&gt; &lt;text&gt;圣殿春秋&lt;/text&gt; &lt;/navLabel&gt; &lt;content src=&quot;Text/cover.xhtml&quot;/&gt; &lt;navPoint id=&quot;navPoint-2&quot; playOrder=&quot;2&quot;&gt; &lt;navLabel&gt; &lt;text&gt;作品简介&lt;/text&gt; &lt;/navLabel&gt; &lt;content src=&quot;Text/Intro1.xhtml&quot;/&gt; &lt;/navPoint&gt; ... &lt;navPoint id=&quot;navPoint-7&quot; playOrder=&quot;7&quot;&gt; &lt;navLabel&gt; &lt;text&gt;前言&lt;/text&gt; &lt;/navLabel&gt; &lt;content src=&quot;Text/Preface03.xhtml&quot;/&gt; &lt;/navPoint&gt; &lt;/navPoint&gt; &lt;/navMap&gt; navPoint 节点中，playOrder 属性定义当前项在目录中的次序，text 子节点则定义了目录的名字 content 子节点 src 属性定义了章节文件的具体位置 navPoint 节点可以嵌套，形成了整本书的层级结构。 opf 文件定义了读者在顺序阅读时用到的章节和顺序，而 ncx 文件则定义了目录中用到的章节和顺序。如果存在附录形式的内容，希望在目录中出现，而不希望在正文中出现时，而已通过设置两个不同来达到目的。 在了解了这些标准内容之后，解析 epub 格式就比较简单了，python 可以使用 ebooklib 这个库。他的使用相对比较简单，也就一个 epub 类，具体使用可以参考 GitHub，不过需要注意的是很多 epub 格式的书并没有完全按照标准生成，所以有些地方还得自己 hack。","categories":[{"name":"Geek","slug":"Geek","permalink":"https://casuor.top/categories/Geek/"}],"tags":[]},{"title":"知乎-什么样的男生注定单身?","slug":"trans-知乎-什么样的男生注定单身","date":"2019-12-25T16:00:00.000Z","updated":"2020-10-28T09:58:54.892Z","comments":true,"path":"2019/12/26/trans-知乎-什么样的男生注定单身/","link":"","permalink":"https://casuor.top/2019/12/26/trans-%E7%9F%A5%E4%B9%8E-%E4%BB%80%E4%B9%88%E6%A0%B7%E7%9A%84%E7%94%B7%E7%94%9F%E6%B3%A8%E5%AE%9A%E5%8D%95%E8%BA%AB/","excerpt":"","text":"State文章内容转载自:知乎-什么样的男生注定单身?侵删,联系方式 Content 1、目测条件一般，有自己的想法和见地，看过一些书，情商也不低，不会显得急不可待，语出惊人。看上去介于单调和闷之间，但内心怀有强烈的情感。一般不会显得浮躁，在熟人面前幽默感爆棚，在陌生人面前不会特意表现自己，但跟女生一说话，就有种难以掩饰的微尬和不自然。 2、不会帅得在人群中引起骚动，也不会丑得让人扭头就走，看上去就不太像个有故事的人。可能穿得比较干净，但一定不潮，内心深处，想摆脱肤浅，容易自省，跟大家吐槽的俗low男不沾边，动不动容易觉得特别。 3、不擅长KTV，篮球，可能会喜欢跑步，看书，思想逻辑类的事物，但优点都不具备那种直观可展示性，常常沦为大型聚会的配角，但也不会夸张的卖弄自己。 4、内心戏很丰富，对所追求的爱情，脑海中有一幅自己的想象蓝图。没事不会主动找女生，对有感觉的女生，在微信聊天中对用到的表情包，标点，波浪线都有思考，并且使之尽量看起来装作随性自然，不敢喋喋不休地打扰，很怕被嫌弃，越界，导致很少产生亲密关系。 5、在精神和道德上容易自我感觉良好，常常要用尊严掩饰自卑，学不会不要脸，无法像舔狗一样存活，但生活也没给他一个机会来检验自己是不是舔狗。 6、对感情上有洁癖，对爱情本身的向往超过爱一个具体的人，内心多年保持一种在精神层面对美好事物的追求，不想随便找一个女朋友破坏了自己内心多年来对爱情的想象。 7、看着青春气数已尽，在岁月狂奔的途中，有情人结成眷侣的背景下，会回过头来观察自己，发现自己一直是孤家寡人，而别人一不小心已经有了前前任了。会冷静或者极度失望地对自己挑刺，容易感到气馁无望，进一步增长对情感和未来的焦虑和渴求。 8、工作和生活以及爱好，稳定得像一潭死水，生活中连公车时刻表都难得出错，更不会有意外的人事出现打破你的生活轨迹，难有一个可撬动的点来系统的改变些什么，感情空白或者一直处于空白状态是大几率事件。 9、明明没什么情感经历，生活也平淡如水，但随着年龄渐长，不知不觉熬出了身心的沧桑感。 10、常年容易装作不屑，也容易孤单，在生活中一点一点被动妥协后，容易失去存在感，容易漫不经心，在皆随他去和求而不得中，平静如日，不出意外的话可以一举单身到70岁。 discuss 很有趣,评论也是有趣,说是巴纳姆效应又称福勒效应，星相效应，是1948年由心理学家伯特伦·福勒通过试验证明的一种心理学现象，人们常常认为一种笼统的、一般性的人格描述十分准确地揭示了自己的特点，当人们用一些普通、含糊不清、广泛的形容词来描述一个人的时候，人们往往很容易就接受这些描述，并认为描述中所说的就是自己。 个人观点:是生活中有如上描述的人,举个例子哈：比如他他他他，额好了，而这个效应也不是适用所有类似的人。心理学上这是个不错的方法，嘿嘿嘿。","categories":[{"name":"Transfer","slug":"Transfer","permalink":"https://casuor.top/categories/Transfer/"}],"tags":[]},{"title":"跨平台开发NW.js与Electron(一)","slug":"geek_NWjs&Electron1","date":"2019-12-24T16:00:00.000Z","updated":"2020-10-28T09:58:54.879Z","comments":true,"path":"2019/12/25/geek_NWjs&Electron1/","link":"","permalink":"https://casuor.top/2019/12/25/geek_NWjs&Electron1/","excerpt":"","text":"Node.js桌面应用优势之一 通常，开发桌面应用要求开发者们精通像C++、Objective-C，或者C#这样的语言以及像.NET、Qt、Cocoa或者GTK这样的框架。对于部分开发者而言，准入门槛有点高，很可能会放弃使用这些技术来构建桌面应用。像Electron和NWjs这样的Nodejs桌面应用框架最棒的地方就在于它&gt;们大大降低了开发者的准入门槛。支持开发者使用HTML、CSS和J&gt;avaScript开发桌面应用，而且还可以在Web应用和桌面应用之间共享同一份代码，这无异于是给Web开发者打开了一扇通往成为桌面应用开发者的门。 缘起Referencebook:跨平台桌面应用开发 基于Electron与NW.JS site:历史细节Electron Is Electron originally forked from NW.js, or is it just inspired by NW.js (if so, is it a fork of any existing repository) ?两框架对比技术差异NW.js vs electronNW.js中文网演变node-webkit—&gt;NW.jsAtom Shell —&gt;Electron NW.jsReferenceCross Platform Desktop Applications NW.js介绍安装NW.js cnpm install -g nw构建hello-world应用package.json { &quot;name&quot; : &quot;hello world nwjs&quot;, &quot;main&quot; : &quot;index.html&quot;, &quot;version&quot; : &quot;1.0.0&quot; }index.html &lt;html&gt; &lt;head&gt; &lt;title&gt;Hello World&lt;/title&gt; &lt;style&gt; body { background-image: linear-gradient(45deg, #EAD790 0%, #EF8C53 100%); text-align: center; } button { background: rgba(0,0,0,0.40); box-shadow: 0px 0px 4px 0px rgba(0,0,0,0.50); border-radius: 8px; color: white; padding: 1em 2em; border: none; font-family: &apos;Roboto&apos;, sans-serif; font-weight: 100; font-size: 14pt; position: relative; top: 40%; cursor: pointer; outline: none; } button:hover { background: rgba(0,0,0,0.30); } &lt;/style&gt; &lt;link href=&apos;https://fonts.googleapis.com/css?family=Roboto:300&apos; rel=&apos;stylesheet&apos; type=&apos;text/css&apos;&gt; &lt;script&gt; function sayHello () { alert(&apos;Hello World&apos;); } &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;button onclick=&quot;sayHello()&quot;&gt;Say Hello&lt;/button&gt; &lt;/body&gt; &lt;/html&gt;nw即可运行 NW.js有哪些特性 通过JS访问操作系统原生的UI和API 控制应用视窗的大小和行为在应用视窗中显示菜单项的工具条在用户右击的时候，在应用视窗中添加上下文菜单。在操作系统托盘菜单中添加应用的菜单项。访问操作系统的剪贴板，读写其中的内容。使用计算机中默认指定的应用打开文件、文件夹以及URL。通过操作系统的通知系统显示通知。 在应用中使用Node.js和npm应用 web应用与NW.js开发的桌面应用的区别，后者，前后端代码的界限很模糊，因为同一段JavaScript代码共享了前后端的上下文 https://github.com/nw-cn/awesome-nwjshttps://github.com/sindresorhus/awesome 同一份代码构建支持多操作系统的应用app-&gt;npm install -g nw-builder&amp;nwbuild app/-&gt;build Electron介绍Electron是GitHub开发的桌面应用开发框架。它最早的名字叫Atom Shell，是为GitHub的文本编辑器Atom构建的。它支持使用HTML、CSS和JavaScript来构建跨平台的桌面应用。自它2013年11月发布以来，越来越流行，不少创业公司和大公司都纷纷用它来构建他们的桌面应用。不仅Atom在用Electron，连聊天应用Slack（https:/www.slack.com）的桌面客户端应用也在用，这家创业公司截至2016年4月估值已达38亿美金。 Electron是如何工作的以及它和NW.js的区别是什么1.整合chromium和Node.js的方式不同 在NW.js中,chromium是直接被打补丁打进去的,因此Node.js和chromium共享了同一个JavaScript上下文.在electron中而是通过chromium的Content API以及使用了Node.js的node_bindings 2.处理JavaScript上下文时和NW.js不同 在NW.js中,维护一个共享的JavaScript上下文在electron中,多个独立的JavaScript上下文(main&amp;renderer进程) 3.入口不同 在NW.js中,html文件为入口在electron中,js文件为入口 安装Electron cnpm install electron cnpm install nodemon构建electron hello world 应用 package.json { &quot;name&quot;: &quot;hello_world&quot;, &quot;main&quot;: &quot;main.js&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;scripts&quot;: { &quot;start&quot;: &quot;nodemon --watch main.js --exec electron .&quot; } }main.js &apos;use strict&apos;; const electron = require(&apos;electron&apos;); const app = electron.app; const BrowserWindow = electron.BrowserWindow; let mainWindow = null; app.on(&apos;window-all-closed&apos;, () =&gt; { if (process.platform !== &apos;darwin&apos;) app.quit(); }); app.on(&apos;ready&apos;, () =&gt; { mainWindow = new BrowserWindow(); mainWindow.loadURL(`file://${__dirname}/index.html`); mainWindow.on(&apos;closed&apos;, () =&gt; { mainWindow = null; }); });index.html 同上 cnpm start Electron 有哪些特性支持创建多视窗，而且每个视窗都有自己独立的JavaScript上下文。通过shell和screenAPI整合了桌面操作系统的特性。支持获取计算机电源状态。支持阻止操作系统进入省电模式（对于演示文稿类应用非常有用）。支持创建托盘应用。支持创建菜单和菜单项。支持为应用增加全局键盘快捷键。支持通过应用更新来自动更新应用代码。支持汇报程序崩溃。支持自定义Dock菜单项。支持操作系统通知。支持为应用创建启动安装器。 NW.js和Electron支持创建哪类应用ListNW.js APPSElectron APPS","categories":[{"name":"Geek","slug":"Geek","permalink":"https://casuor.top/categories/Geek/"}],"tags":[]},{"title":"Wallhaven Spider","slug":"geek-wallhavenspider","date":"2019-12-20T16:00:00.000Z","updated":"2020-10-28T09:58:54.877Z","comments":true,"path":"2019/12/21/geek-wallhavenspider/","link":"","permalink":"https://casuor.top/2019/12/21/geek-wallhavenspider/","excerpt":"","text":"referencehttps://www.cnblogs.com/simple-li/p/11202461.html 说明:初学Python,目前再啃廖雪峰的教程 额,这个写的有点问题,所以以下是改造吧,额不使用lxml也是可以的,就简单的拼接字符串问题,但效率可能慢点 otherlxml etree的用法 python中去除字符串中空白字符的最简单方法 string=&quot;hello world &quot; string.replace(&quot; &quot;,&quot;&quot;)delete blank Problem1.文件下载进程随时会出现假死状态,需要大改,并封装一下搜索下载,美滋滋 2.pychram控制台接收一个输入的网址,回车自动跳到浏览器 分析​ 1.文件读写 ​ 2.抓包,解析文件地址 ​ 3.下载文件 实现代码# 爬取某网站的壁纸图片 import os import random import requests from lxml import etree import time # 伪装浏览器 headers = { &quot;User-Agent&quot;: &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_5)AppleWebKit/537.36 (KHTML, like Gecko) Chrome/59.0.3071.104 Safari/537.36&quot;, } # 定义创建文件路径函数，将下载的文件存储到该路径 def CreatePath(filepath): if not os.path.exists(filepath): os.makedirs(filepath) # 获取壁纸首页网页信息并解析 def getUrlText(url): respons = requests.get(url, headers=headers) # 获取网页信息 urlText = respons.text html = etree.HTML(urlText) # 使用lxml解析网页 return html # 提取壁纸链接地址列表 def getWallUrl(url): hrefUrl = getUrlText(url) section = hrefUrl.xpath(&apos;//section[@class=&quot;thumb-listing-page&quot;]&apos;)[0] # 获取section标签 hrefList = section.xpath(&apos;./ul//@href&apos;) # 获取首页图片对应链接地址 return hrefList # 获取当前时间 def getTime(): nowtime = time.strftime(&apos;%Y-%m-%d %H:%M:%S&apos;, time.localtime(time.time())) return nowtime # 解析壁纸下载地址 def downWall(url, page): &apos;&apos;&apos; :param url: 网页地址 :param page: 下载页数 :return: 下载结束提醒 &apos;&apos;&apos; global i, n m = 0 page += 1 for i in range(1, page): hrefList = getWallUrl(url + str(i)) print(&apos;第&apos; + str(i) + &apos;页&apos;) print(hrefList) n = 0 print(&apos;开始下载第{}页壁纸&apos;.format(i)) for href in hrefList: n += 1 imgUrl = getUrlText(href) # 获取壁纸链接网页信息并解析 imgSrc = imgUrl.xpath(&apos;//img[@id=&quot;wallpaper&quot;]/@src&apos;)[0].strip() print(imgSrc) try: res = requests.get(imgSrc) print(res, res.status_code) pic_path = &apos;/wallpaper/Picture/&apos; + imgSrc[31:] print(pic_path) with open(pic_path, &apos;wb&apos;) as f: f.write(res.content) f.close() print(&apos;{}:第{}页第{}张壁纸下载完成&apos;.format(getTime(), i, n)) time.sleep(random.uniform(0, 3)) except Exception as e: print(repr(e)) m = m + n return print(&apos;{}:所有壁纸已下载完成，一共{}页{}张&apos;.format(getTime(), i, m)) # url = &apos;https://wallhaven.cc/search?q=id%3A711&amp;ref=fp&amp;tdsourcetag=s_pcqq_aiomsg&amp;page=&apos; def main(): filepath = (&apos;/wallpaper/Picture/&apos;) # 存储路径。 page = int(input(&apos;请输入你想下载的页数:&apos;)) CreatePath(filepath) downWall(&apos;https://wallhaven.cc/search?q=id%3A3799&amp;page=&apos;, page) if __name__ == &apos;__main__&apos;: main()","categories":[{"name":"Geek","slug":"Geek","permalink":"https://casuor.top/categories/Geek/"}],"tags":[]},{"title":"Beautiful girl","slug":"pic_beautifulgirl","date":"2019-12-20T16:00:00.000Z","updated":"2020-10-28T09:58:54.887Z","comments":true,"path":"2019/12/21/pic_beautifulgirl/","link":"","permalink":"https://casuor.top/2019/12/21/pic_beautifulgirl/","excerpt":"","text":"声明: 本图源爬取自wallhave,有任何问题联系删除","categories":[],"tags":[{"name":"Picture","slug":"Picture","permalink":"https://casuor.top/tags/Picture/"}]},{"title":"寂寞的游戏-袁哲生","slug":"reading-寂寞的游戏","date":"2019-12-19T16:00:00.000Z","updated":"2020-10-28T09:58:54.889Z","comments":true,"path":"2019/12/20/reading-寂寞的游戏/","link":"","permalink":"https://casuor.top/2019/12/20/reading-%E5%AF%82%E5%AF%9E%E7%9A%84%E6%B8%B8%E6%88%8F/","excerpt":"","text":"寂寞的游戏-袁哲生 这本书前几天了解到,吃饭时,哔哩哔哩的一个纪录片节目[但是还有书籍],胡歌配音,第一集便聊到了这本书,索性我也去瞧瞧 人一旦开始躲藏就很难停下来了,这点我始终深信不疑. 自序 ​ 很久以前，我曾听朋友说过，从前在某地有某些人做了一个实验，他们聚集在一起，守候着一个进入弥留状态的人，在他快要断气之前和刚刚死去之后各秤了一次体重，结果发现前后相差若干毫克，证明人的生命确实有灵魂存在。那若干毫克便是灵魂的体重。 这样的实验和结论未免有些草率，我当时心想，人的身体随时都在散发汗气，那位被实验者死前可能因为紧张或者痛苦而忙得满头大汗也说不定，损失掉的若干毫克并不能全记在灵魂的账上。但是朋友来自一个热衷精神生活的家庭，若不能证明“人类确有灵魂”一事，也许会带给他心理上极大的恐慌，因此我便对他表达了我的坚信不疑。如果我的演技还可以的话，相信当时在我闪烁的眼神中，大概也曾经短暂地发散出一丝信仰的光辉吧！ 另外，我还有一位热衷锻炼身体的朋友，他是镇上有名的田径选手，专攻百米短跑。那时，我们同在一所国中念书，每到朝会集合或是放学打扫的时间，都可以在操场的一隅，看见朋友不分冷热晴雨，总是身着一件雪白的紧身背心，和一条短到不能再短的运动裤，脚上是一双跑起来刷刷响的钉鞋。他在体育老师的细心呵护，和全校女生的注目之下，一遍又一遍反复地练习起跑、抬腿、冲刺等动作。在那样理想的状况之下，有史以来，我首次诚心地联想到，人类有可能是地球上最美丽的生物之一。 有一天，朋友请我在学校旁的冰果室吃冰，他看起来很兴奋，因为那天他的速度进步了零点零几秒（正确的数字我忘记了）；我也颇为得意，因为角落里有一群女生对我投来一种既羡慕又嫉妒的眼光。这种感受很奇怪，好像那些女生的眼神都有重量似的，每一双眼睛各放射出若干毫克，再乘上某种凌厉的速度向我横扫而来，一碗冰吃得我满头大汗。 就这样，我的早期生活便慢慢地陷入这种对“若干毫克”或是“零点零几秒”的轻微迷惑之中。当周遭的朋友以愈来愈频繁的次数询问我有关“生命的意义”，或是“人为什么而活”的问题时，我便一步一步地踏入了那古老而坚固的迷宫之中了。久了之后，这样伤感情的问题便很少听人提起了，除了用所谓“习惯成自然”的适应能力来解释之外——或者还有另外一个很重要的原因，那便是朋友愈来愈少了。 令人难忘的是，当年我的朋友们在肯定了人的灵魂确实重量若干，或是奔跑的速度竟然可以如何的时候，脸上所洋溢出的神圣光彩。这么些年来，这两个谜题我始终还想不清楚，也不知该走向哪一边。我不知该如何计算自己的正确体重，也没有努力地锻炼过双腿。幸好，朋友是愈来愈少了。 或者说，年岁渐长之后，交朋友的方式就慢慢变得不一样了。 前一阵子，途经一处风景地区，在一个不太起眼的民宅神坛前，看到一群人围在一个乩童模样的人身旁，他们在一种诡异而敏感的气氛中期待着。那个人盘腿端坐在一张矮桌上，上身赤裸发红，一手持羽扇，一手执米酒，身体微微晃动着；他偶尔会睁开迷蒙的双眼，灌一口酒，然后又迅速合上眼，嘴角不时地抽动着。那些围在他身旁的男男女女似乎很渴望他开口说话，因此，一旦见他嘴上稍有异状，便探头探脑地向前推挤起来，待乩童闭口不语之后，接着又是一大段沉默。 我已经很多年不曾看到有人这样认真地去聆听别人说话了。当时，若不是因为室内已经太过拥挤的关系，我也很希望能置身其间。我期盼可以意外地，透过乩童的口，听到某个老朋友的声音；那时候，或许那位乩童的体重会莫名其妙地增加了若干毫克也说不定。 那次经历，让我对乩童这个行业产生了一种很亲切的感受。那是一种很古老而充满失望的能量，它让人们维系了一份非常间接的友谊关系。我始终忘不了那个满身酒气，表情扭曲，端坐在矮桌上左摇右晃的身影。在众目睽睽之下，他就像一台破旧的老收音机，不断地发出滋滋响的杂讯，只偶然地，在最理想的状况下，勉强接收到几句话，或是写下一句费人猜疑的诗行…… 这本《寂寞的游戏》让我又回到了老路上，当然，也遇到了一些“老问题”和“老朋友”；我很高兴自己能有机会多走几步路，如果人真的还有来生，希望下辈子我可以不费吹灰之力地再次想起“他们”的点点滴滴。","categories":[],"tags":[{"name":"Reading","slug":"Reading","permalink":"https://casuor.top/tags/Reading/"}]},{"title":"Windows的奇技淫巧","slug":"res-windows","date":"2019-10-27T16:00:00.000Z","updated":"2020-10-28T09:58:54.891Z","comments":true,"path":"2019/10/28/res-windows/","link":"","permalink":"https://casuor.top/2019/10/28/res-windows/","excerpt":"","text":"[TOC] 浏览器Chrome EDGE Firefxo 通信telegram TG群reference1reference2 截图Snipaste 视频播放器Potplayer爱奇艺万能联播MPC-HC 网络电视ZY Player柠檬影视 在线视频(大都是个人维护,易失效,这类网站巨多)919yy影视在线影视 音频播放器GrooveMusicPlayer 音乐播放器网易云音乐&amp;解锁灰色歌曲QQ音乐 系统工具Dism++ Windows10Manager Geek Uninstaller 360驱动大师 图像处理泼辣修图||PhotoShop 图床工具PicGo 配合Github搭建自己的CDN 录屏&amp;Gif班迪录屏&amp;screentogif OfficeOfficeTool 系统下载激活工具microsoft-iso-downloader 建议配合IDM使用 下载工具IDM 搜索工具Everything UTools 输入法手心输入法 Rime 办公同步协作石墨文档 seafile PDF阅读器&amp;编辑器sumatrapdf MovaviPDF Editor 思维导图Xmind Mindmaster 护眼软件护眼宝 手机控制电脑Hipc OCR识别工具天若OCR文字识别 远程控制TeamViewer 电子书转换Calibre cloudconvert PS:电子书下载 文档下载 Markdown 编辑器Typora Sublime Text 3 图表工具Draw.io PS:有UWP版的 Microsoft Whiteboard https://tableconvert.com/ 文件云同步onedrive(教育版5T) PS:配合RaiDrive使用 坚果云 磁力工具FDM WebTorrent Desktop 基于 node.js、WebRTC 的开源技术，任何人都可以通过 Github 获取源码并搭建一个视频网站 😂 然而这个太折腾了。https://webtorrent.io/desktop/ 如果碰到无法播放的情况 https://instant.io/ 批处理工具去除快捷方式角标 reg add &quot;HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Icons&quot; /v 29 /d &quot;%systemroot%\\system32\\imageres.dll,197¡å /t reg_sz /f taskkill /f /im explorer.exe attrib -s -r -h &quot;%userprofile%\\AppData\\Local\\iconcache.db&quot; del &quot;%userprofile%\\AppData\\Local\\iconcache.db&quot; /f /q start explorer pause去除小盾牌 reg add &quot;HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Icons&quot; /v 29 /d &quot;%systemroot%\\system32\\imageres.dll,197&quot; /t reg_sz /f reg add &quot;HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Icons&quot; /v 77 /d &quot;%systemroot%\\system32\\imageres.dll,197&quot; /t reg_sz /f taskkill /f /im explorer.exe attrib -s -r -h &quot;%userprofile%\\AppData\\Local\\iconcache.db&quot; del &quot;%userprofile%\\AppData\\Local\\iconcache.db&quot; /f /q start explorer +美化工具致美化 PS:先看教程再使用 Wallhaven Wallpaper PS:如何爬取wallhaven图片 TODOMicrosoft TODO","categories":[{"name":"Resource","slug":"Resource","permalink":"https://casuor.top/categories/Resource/"}],"tags":[]},{"title":"社区资源(一)","slug":"live_socialotes1","date":"2019-10-15T16:00:00.000Z","updated":"2020-10-28T09:58:54.887Z","comments":true,"path":"2019/10/16/live_socialotes1/","link":"","permalink":"https://casuor.top/2019/10/16/live_socialotes1/","excerpt":"","text":"Never go out there to see what happens,go out there to make things happen. 天气晴🌞,微风 🍓杂记 图床 https://imgchr.com/ Blog plugins https://aplayer.js.org/#/ highlight.js https://highlightjs.org/ Table Convert https://tableconvert.com/ 就业情况爬虫 http://yehe.37he.cn/job/#/education 妹子图爬虫 https://github.com/chenjiandongx/mzitu 百度网盘提取码 https://github.com/wu-dada/baidupankey https://pnote.net/pan/ 树洞ocr https://github.com/AnyListen/tools-ocr Markdown语法 https://spec.commonmark.org/0.29/ scrcpy gui https://github.com/Tomotoes/scrcpy-gui/blob/master/README.zh_CN.md 电子书下载 http://ireadweek.com/ 电子书转换 https://cloudconvert.com/ Auto.js https://hyb1996.github.io/AutoJs-Docs/#/ github DNS https://www.ipaddress.com/","categories":[{"name":"Live","slug":"Live","permalink":"https://casuor.top/categories/Live/"}],"tags":[]},{"title":"网易云音乐去灰色","slug":"res-cloudmusic","date":"2019-10-13T16:00:00.000Z","updated":"2020-10-28T09:58:54.890Z","comments":true,"path":"2019/10/14/res-cloudmusic/","link":"","permalink":"https://casuor.top/2019/10/14/res-cloudmusic/","excerpt":"","text":"reference必应搜索unblockmusic即可,项目已开源,去fuck吧 come here网易云音乐去灰色原理: 屏蔽网易DNS解析+换源 工具: 太极https://www.coolapk.com/apk/me.weishu.expunblock music pro 2.7https://github.com/nining377/UnblockMusicPro_Xposed/releases 网易云音乐6.1(其他没修改的版本也可以)链接:https://pan.baidu.com/s/1USpV_WsPG10YXFZXHuGZxw 提取码:9123 操作: 文字教程☞ 1.三个都安装好 2.打开太极，将网易云音乐安装到太极中 3.在模块页面勾选ump2.7(简写) 4.重启网易云音乐(后台终止)，即ok了 视频教程☞链接:https://pan.baidu.com/s/1h5mwNGeaP9yEvLFSysAqgQ 提取码:7508PS:视频教程由网友提供。 新增云村清洁工:使用同ump2.7,打开显示未激活，忽略. 链接:https://pan.baidu.com/s/1zM3mu0pMU7l-CGgxk1BLSw 提取码:0ct3效果图","categories":[{"name":"Resource","slug":"Resource","permalink":"https://casuor.top/categories/Resource/"}],"tags":[]},{"title":"Electron Notes","slug":"geek_Electron入门","date":"2019-09-27T16:00:00.000Z","updated":"2020-10-28T09:58:54.877Z","comments":true,"path":"2019/09/28/geek_Electron入门/","link":"","permalink":"https://casuor.top/2019/09/28/geek_Electron%E5%85%A5%E9%97%A8/","excerpt":"","text":"Electorn技术栈环境搭建1.Node.js 2.GitNVM常用命令： 123456789101112nvm arch #版本64or32nvm install [version] [arch] #安装nvm list [available] #显示安装版本或已经安装的版本nvm on nvm offnvm proxy [url]nvm node_mirror [url]nvm npm_mirror[url]nvm uninstall &lt;version&gt;nvm use [version] [arch]nvm root [path]nvm version npm初始化 12345678910#查看部分配置信息npm config ls#修改全局Node moudle位置初始位置：prefix = \"C:\\\\Users\\\\16877\\\\AppData\\\\Roaming\\\\npm\"cache = \"C:\\\\Users\\\\16877\\\\AppData\\\\Roaming\\\\npm-cache\"修改：npm config set prefix \"F:\\Develop_Node.js\\Gobal_Npm_Module\"npm config set cache \"F:\\Develop_Node.js\\Gobal_Npm_Cache\"#修改Npm cache位置 PS:其他也可以设置 安装cnpm 123npm install -g cnpm --registry=https://registry.npm.taobao.org#此外需添加环境变量cnpm -v PS :problem: 1The process cannot access the file because it is being used by another process. 方案1：淘宝镜像 12nvm node_mirror https://npm.taobao.org/mirrors/node/nvm npm_mirror https://npm.taobao.org/mirrors/npm/ 方案2：直接下载个exe安装到nvm所指定的路径名称改为(LTS版本：’v12.13.1’) 3.Electorn (1)克隆示例项目的仓库 1git clone https://github.com/electron/electron-quick-start (2)进入仓库 1cd electron-quick-start (3)安装依赖并启动 123456cnpm install or npm installnpm start#使用npm卡住需在.npmrc文件添加registry=https://registry.npm.taobao.orgelectron_mirror=\"https://npm.taobao.org/mirrors/electron/\"PS:install.js文件中有electron_mirror这一项，使用cnpm没问题 npm地址 进程和线程什么是进程什么是线程进程与线程的区别1.内存使用方面的区别2.通信机制方面的区别3.量级方面的区别 Electorn 主进程和渲染进程chrom 多进程管理{主进程+渲染进程}main process使用和系统对接的Electorn API-创建菜单,创建菜单,上传文件等创建渲染进程-Render Process全面支持Node.js有且只有一个程序入口点Render Process可以有多个,每个对应一个窗口每个都是一个单独的进程全面支持Node.js和Dom API可使用部分Electron 进程Multi-process Architecture 创建Browser Windowcnpm install –save-dev nodemonEdit package.json 1234567891011121314151617181920212223&#123; \"name\": \"electron-quick-start\", \"version\": \"1.0.0\", \"description\": \"A minimal Electron application\", \"main\": \"main.js\", \"scripts\": &#123; \"start\": \"nodemon --watch main.js --exec electron .\" &#125;, \"repository\": \"https://github.com/electron/electron-quick-start\", \"keywords\": [ \"Electron\", \"quick\", \"start\", \"tutorial\", \"demo\" ], \"author\": \"GitHub\", \"license\": \"CC0-1.0\", \"devDependencies\": &#123; \"electron\": \"^7.1.2\", \"nodemon\": \"^2.0.1\" &#125;&#125; Main.js 123456789101112131415// Modules to control application life and create native browser window//common.jsconst &#123;app, BrowserWindow&#125; = require('electron')app.on('ready', () =&gt; &#123; let mainWindow = new BrowserWindow( &#123; width: 800, height: 500, webPreferences: &#123; nodeIntegration:true &#125; &#125; ) mainWindow.loadFile('index.html')&#125;) 进程间的通信Electron使用IPC(interprocess communication)进行通信 开发者工具: DevtronAn Electron DevTools Extension 123456# Install Devtron$ npm install --save-dev devtron# Run the following from the Console tab of your app's DevToolsrequire('devtron').install()# You should now see a Devtron tab added to the DevTools 使用IPC进行通信ipcMainipcRenderer 使用remote实现跨进程访问react特性声明式写法组件化一次学习,随处编写 react install 1234npx create-react-app my-app#为何不使用npm install -g create-react-appcd my-appnpm start npx的用法 npx说明 12#node_moudles/.bin/nodemon --versionnpx nodemon --version","categories":[{"name":"Geek","slug":"Geek","permalink":"https://casuor.top/categories/Geek/"}],"tags":[]},{"title":"GNU Wget for Windows","slug":"geek_gnuweget","date":"2019-09-25T16:00:00.000Z","updated":"2020-10-28T09:58:54.883Z","comments":true,"path":"2019/09/26/geek_gnuweget/","link":"","permalink":"https://casuor.top/2019/09/26/geek_gnuweget/","excerpt":"","text":"GNU WegetIntroductionGNU Wget是一个免费软件包，可使用HITP，HTTPS，FTP和FTPS等最广泛使用的Internet协议来检索文件。 它是一种非交互式的命令行工具，因此可以很容易地从脚本，cron jobs,不支持X-Windows的终端等中调用它。GNU Wget具有许多使检索大型文件或镜像整个Web或FTP站点变得容易的功能，包括： 可以使用REST和RANGE恢复中止的下载 可以使用文件名通配符并递归镜像目录 基于NLS的消息文件，适用于多种语言 (可选)将已加载文档中的绝对链接转换为相对链接，以便已卸载文档可以在本地彼此链接 在大多数类似UNIX的操作系统以及Microsoft Windows上运行 支持HTTP代理·支持HTTP cookie 支持持久的HTTP连接 无人值守/后台操作 使用本地文件时间戳确定镜像时是否需要重新下载文档GNU Wget是根据GNU通用公共许可证发行的。 Install镜像 UsereferenceFSF社区手册 https://builtvisible.com/download-your-website-with-wget/ https://www.cnblogs.com/Randy0528/archive/2011/10/21/2219831.html otherGUN项目 推荐书籍unix编程艺术 名人了解: 理查德·马修·斯托曼 Ken Thompson 时间:1969 最初的unix是一个第三系统,由兼容分时系统(ctss,compatible time-sharing system)系统演变而成,Unix的父辈是颇具开拓性的Multics项目,该项目视图建立一个具备众多功能的信息功用体/应用工具(information utility),能够很漂亮地支持大群用户对大型计算机的交互式分时使用.Multics最后因不堪自身重负崩溃但Unix诞生了.","categories":[{"name":"Geek","slug":"Geek","permalink":"https://casuor.top/categories/Geek/"}],"tags":[]},{"title":"电子书聚合","slug":"res-books","date":"2019-09-25T16:00:00.000Z","updated":"2020-10-28T09:58:54.890Z","comments":true,"path":"2019/09/26/res-books/","link":"","permalink":"https://casuor.top/2019/09/26/res-books/","excerpt":"","text":"电子书分类及阅读工具科普常见的电子书格式主要有：pdf、epub、mobi、azw3、caj、pdg、pdz、djvu、uvz、umd、keb、chm、ceb、txt、ps等 手机上epub格式推荐用掌阅iReader、fbreader等来阅读，mobi格式推荐用Kindle App阅读。 iOS上(iPhone、iPad)阅读azw3格式可使用MOBI Reader (https:/itunes.apple.com/us/app/mobi-reader-reader-for-mobi/id1007491919%3Fmt%3D8)，支持的电子书文件格式包括mobi, azw, azw3等… Android上，请参阅 Bravo Yeung：Android 上有什么功能比较强大的阅读器？ (https://www.zhihu.com/question/20833061/answer/44334041) 电脑上可以用Calibre、fbreader、SumatraPDF进行阅读，其中Calibre能阅读大多数格式(pdf、epub、mobi、azw3、caj、txt等)的电子书，还能进行各种格式电子书的转换。据说azw3后缀可改为Mobi格式喔，表示暂未试过~ sumatraPDF能打开epub、mobi、PDF、djvu、txt、chm、ps(单页的ps文件、多页的ps文件都支持)等格式的电子书。 epub掌阅精品需用掌阅iReader阅读，caj格式需用CAJviewer打开，pdz格式需用超星阅读器打开，解密过的pdg或uvz格式需用Unicorn viewer打开，djvu推荐用WinDjView打开。 长话短说就是：mobi或epub格式的在电脑上可以用软件Calibre或sumatraPDF打开，手机上推荐kindle App或掌阅，电子书格式转换请用Calibre… 中文电子书 ePUBee电子书库 http://cn.epubee.com/books/ 这个网站的电子书应有尽有，先免费注册个账号，还有公众号’ePUBee电子书’，在公众号中回复书名即可下载、或发送到邮箱、或发送到kindle~ 不过，本人首推在电脑浏览器中下载的方法： Step 1: 搜索到文件后，点文件下方的“保存到Cloud ID”; Step 2: 用同一个浏览器打开个人文件列表 http://cn.epubee.com/files.aspx ; Step 3: 点击Step 2的图中的文件格式(epub、mobi、azw3、PDF等，如红框所示)就可以下载了，但现在非VIP用户每天共可下载3个文件。 Readfree·me http://readfree.me/ PS:有惊喜 书舟-免费电子书分享平台 http://kindle.archiew.top Calibre-web | Recently Added Books http://book.cnxile.com/ Readfree·me http://readfree.me/ 我的小书屋-最新最全电子书免费下载 http://mebook.cc/ 云海免费电子图书馆| 免费电子图书下载 http://www.pdfbook.cn/ 苦瓜书盘 https://kgbook.com/ kindle免费电子书资源下载推送_支持mobi格式 - kindle178 http://www.kindle178.com/ 周读：提供免费电子书下载、分享。包括mobi、epud、pdf、txt格式 http://www.ireadweek.com/ 走读派 - Kindle电子书瀑布流 http://zoudupai.com/ 书语者电子图书馆 Kindle电子书 http://book.shuyuzhe.com/ 早安社区 - 简单阅读自由分享雅俗共赏_全国十大原创精校电子书网站 http://www.zasq.net/forum.php 网上读书园地 - 论坛 http://readfree.net/bbs/forum.php 缤闹kindle论坛 http://www.binnao.com/forum.php 国学数典 http://bbs.gxsd.com.cn/forum.php 益书网：优质电子书资源分享、下载与推送 https://kindbook.cn/ 图书资源 – 书伴（原名“Kindle伴侣”） https://bookfere.com/ebook 许多书(建设中) https://xuduoshu.com/about/ 书多多 - 好用的电子书搜索引擎 - 搜书就用书多多 http://www.shuduoduo.me/ 奇异书屋 http://www.talebook.org/ Kindle资源库SoKindle一起分享阅读的乐趣 https://www.so-kindle.com/ SoKindle - 免费电子书分享交流下载 https://sokindle.com/ iPad 电子书资源分享区 - 威锋论坛 - 威锋网 http://url.cn/5vNxgkF 爱问共享资料_在线资料分享平台 http://ishare.iask.sina.com.cn/ Android 漫畫小說-Android 資源分享-Android 台灣中文網 - APK.TW https://apk.tw/forum-368-1.html 英文电子书 Libgen Online Library:https://libgen.pw/ Electronic library http://booksc.org/ http://bookzz.org/ http://en.booksee.org/ Books-share.com - Free ebooks http://www.books-share.com/ ITeBookShare http://www.itebookshare.com/ Sci-Hub: removing barriers in the way of science http://www.sci-hub.cc/ 七彩英语 - 英文电子书下载站 PDF|TXT格式英文原版原著下载http://www.qcenglish.com/ BookDL › eBooks for PC &amp; Mobile Devices https://bookdl.com/ Free eBooks For Your Kindle or Other eReader | ManyBooks http://manybooks.net/ Welcome to Open Library | Open Libraryhttps://openlibrary.org/ Feedbooks | Free eBooks and Best Sellers http://www.feedbooks.com/ Ebook4Expert https://ebook4expert.com/ Download Amazing Free Ebooks in pdf, epub &amp; kindlehttp://www.obooko.com/ Scribd - Read books, audiobooks, and more https://zh.scribd.com/ E-Books Directory - Categorized Books, Short Reviews, Free Downloads http://www.e-booksdirectory.com/ 其他 亿年书海 - 电子书 wiki 网 http://www.inien.com/w/#/Index 直达号 http://zhidahao.com/?from=ppurl.com 掌上书苑-主页https://www.cnepub.com/ 古登堡计划（中文书籍） Gutenberg http://www.gutenberg.org/ 完美文库 http://www.wmwk.org/Search.aspx 好讀 http://haodoo.net/ 学习资料库，免费共享各类学习资料，学习资料免费下载 http://www.xuexi111.com/ E书吧-免费电子书下载 http://www.eshuba.com/ 漫画书电子版 日漫小站 - 电子书专用漫画下载 http://www.jp-comic.com/ Vol.moe = Kindle漫畫推送下載|mobi漫畫|Kobo漫畫|epub漫畫 - vol.moe http://vol.moe/ 简单易用的EPUB、MOBI电子书制作网站： 乐书-写书、写手册、团队文档管理,电子书制作 -乐书 http://www.lebook.me/ 优书 - 最简单易用的EPUB、MOBI电子书制作软件http://www.youshu.net/ 读远 - 干货集合地(用微博登录) 建设中 (http://readfar.com/) 相关参考： 免费电子书网站汇总http://shedingkong.lofter.com/post/302b9d_d324ec 原文地址： https://zhuanlan.zhihu.com/p/28472412 推荐本人常用微信公众号:幸福的味道&amp;网站:www.ireadweek.com","categories":[{"name":"Resource","slug":"Resource","permalink":"https://casuor.top/categories/Resource/"}],"tags":[]},{"title":"Electron Fiddle","slug":"geek_electronFiddle","date":"2019-09-24T16:00:00.000Z","updated":"2020-10-28T09:58:54.882Z","comments":true,"path":"2019/09/25/geek_electronFiddle/","link":"","permalink":"https://casuor.top/2019/09/25/geek_electronFiddle/","excerpt":"","text":"Electron Fiddle介绍create and play with small Electron experiments. It greets you with a quick-start template after opening – change a few things, choose the version of Electron you want to run it with, and play around. Then, save your Fiddle either as a GitHub Gist or to a local folder. Once published on GitHub, anyone can quickly try your Fiddle out by just entering it in the address bar. 功能探索Electron Fiddle包含了探索平台所需的一切。它还包括Electron中可用的每个API的示例. 代码风格 Fiddle包括Microsoft出色的Monaco编辑器，该编辑器支持Visual Studio Code。它还会自动为当前所选版本的Electron安装类型定义，以确保您始终只需单击几次即可获得所有Electron API。 编译打包 Complete Tool Start with Fiddle, Continue Wherever Fiddle 不是一个IDE,但是是一个不错的开始","categories":[{"name":"Geek","slug":"Geek","permalink":"https://casuor.top/categories/Geek/"}],"tags":[]},{"title":"Electron Notes","slug":"geek_electron","date":"2019-09-24T16:00:00.000Z","updated":"2020-10-28T09:58:54.882Z","comments":true,"path":"2019/09/25/geek_electron/","link":"","permalink":"https://casuor.top/2019/09/25/geek_electron/","excerpt":"","text":"Electorn技术栈环境搭建1.Node.js 2.GitNVM常用命令： 123456789101112nvm arch #版本64or32nvm install [version] [arch] #安装nvm list [available] #显示安装版本或已经安装的版本nvm on nvm offnvm proxy [url]nvm node_mirror [url]nvm npm_mirror[url]nvm uninstall &lt;version&gt;nvm use [version] [arch]nvm root [path]nvm version npm初始化 12345678910#查看部分配置信息npm config ls#修改全局Node moudle位置初始位置：prefix = \"C:\\\\Users\\\\16877\\\\AppData\\\\Roaming\\\\npm\"cache = \"C:\\\\Users\\\\16877\\\\AppData\\\\Roaming\\\\npm-cache\"修改：npm config set prefix \"F:\\Develop_Node.js\\Gobal_Npm_Module\"npm config set cache \"F:\\Develop_Node.js\\Gobal_Npm_Cache\"#修改Npm cache位置 PS:其他也可以设置 安装cnpm 123npm install -g cnpm --registry=https://registry.npm.taobao.org#此外需添加环境变量cnpm -v PS :problem: 1The process cannot access the file because it is being used by another process. 方案1：淘宝镜像 12nvm node_mirror https://npm.taobao.org/mirrors/node/nvm npm_mirror https://npm.taobao.org/mirrors/npm/ 方案2：直接下载个exe安装到nvm所指定的路径名称改为(LTS版本：’v12.13.1’) 3.Electorn (1)克隆示例项目的仓库 1git clone https://github.com/electron/electron-quick-start (2)进入仓库 1cd electron-quick-start (3)安装依赖并启动 123456cnpm install or npm installnpm start#使用npm卡住需在.npmrc文件添加registry=https://registry.npm.taobao.orgelectron_mirror=\"https://npm.taobao.org/mirrors/electron/\"PS:install.js文件中有electron_mirror这一项，使用cnpm没问题 npm地址 进程和线程什么是进程什么是线程进程与线程的区别1.内存使用方面的区别2.通信机制方面的区别3.量级方面的区别 Electorn 主进程和渲染进程chrom 多进程管理{主进程+渲染进程}main process使用和系统对接的Electorn API-创建菜单,创建菜单,上传文件等创建渲染进程-Render Process全面支持Node.js有且只有一个程序入口点Render Process可以有多个,每个对应一个窗口每个都是一个单独的进程全面支持Node.js和Dom API可使用部分Electron 进程Multi-process Architecture 创建Browser Windowcnpm install –save-dev nodemonEdit package.json 1234567891011121314151617181920212223&#123; \"name\": \"electron-quick-start\", \"version\": \"1.0.0\", \"description\": \"A minimal Electron application\", \"main\": \"main.js\", \"scripts\": &#123; \"start\": \"nodemon --watch main.js --exec electron .\" &#125;, \"repository\": \"https://github.com/electron/electron-quick-start\", \"keywords\": [ \"Electron\", \"quick\", \"start\", \"tutorial\", \"demo\" ], \"author\": \"GitHub\", \"license\": \"CC0-1.0\", \"devDependencies\": &#123; \"electron\": \"^7.1.2\", \"nodemon\": \"^2.0.1\" &#125;&#125; Main.js 123456789101112131415// Modules to control application life and create native browser window//common.jsconst &#123;app, BrowserWindow&#125; = require('electron')app.on('ready', () =&gt; &#123; let mainWindow = new BrowserWindow( &#123; width: 800, height: 500, webPreferences: &#123; nodeIntegration:true &#125; &#125; ) mainWindow.loadFile('index.html')&#125;)","categories":[{"name":"Geek","slug":"Geek","permalink":"https://casuor.top/categories/Geek/"}],"tags":[]},{"title":"哔哩哔哩-汪峰-空空如也","slug":"trans-B站-空空如也","date":"2019-08-27T16:00:00.000Z","updated":"2020-10-28T09:58:54.892Z","comments":true,"path":"2019/08/28/trans-B站-空空如也/","link":"","permalink":"https://casuor.top/2019/08/28/trans-B%E7%AB%99-%E7%A9%BA%E7%A9%BA%E5%A6%82%E4%B9%9F/","excerpt":"","text":"B站呵呵系列多上B站,快乐多多转载自:AV25757959,侵删,联系方式 岁月不饶人,能救赎自己的只有自己","categories":[{"name":"Transfer","slug":"Transfer","permalink":"https://casuor.top/categories/Transfer/"}],"tags":[]},{"title":"Flutter Notes","slug":"geek_Flutter","date":"2019-08-24T16:00:00.000Z","updated":"2020-10-28T09:58:54.879Z","comments":true,"path":"2019/08/25/geek_Flutter/","link":"","permalink":"https://casuor.top/2019/08/25/geek_Flutter/","excerpt":"","text":"起步移动开发技术简介跨平台技术简介H5+原生（Cordova、Ionic、微信小程序）​ 动态内容通过H5实现(原生的网页加载控件webview,不难理解),APP相当于浏览器.这种模式称为混合应用,或Hybrid APP.​ 代表:微信小程序​ 混合开发技术:​ webview实质上是一个浏览器内核,实现交互需要js,而对于js直接操纵系统(原生API)能力有限,即需要使用原生与H5混合的开发模式.​ js与原生API之间通信遵守一个标准协议,协议实现的工具:webview javascipt bridge.​ JavaScript开发+原生渲染的方式主要优点如下： 采用Web开发技术栈，社区庞大、上手快、开发成本相对较低。原生渲染，性能相比H5提高很多。动态化较好，支持热更新。 ​ 不足： 渲染时需要JavaScript和原生之间通信，在有些场景如拖动可能会因为通信频繁导致卡顿。JavaScript为脚本语言，执行时需要JIT(Just In Time)，执行效率和AOT(Ahead Of Time)代码仍有差距。由于渲染依赖原生控件，不同平台的控件需要单独维护，并且当系统更新时，社区控件可能会滞后；除此之外，其控件系统也会受到原生UI系统限制，例如，在Android中，手势冲突消歧规则是固定的，这在使用不同人写的控件嵌套时，手势冲突问题将会变得非常棘手。:Hybrid(杂种;混合物) JavaScript开发+原生渲染 （React Native、Weex、快应用）​ React Native简介​ React Native (简称RN)是Facebook于2015年4月开源的跨平台移动应用开发框架，是Facebook早先开源的JS框架 React 在原生移动应用平台的衍生产物，目前支持iOS和Android两个平台。RN使用Javascript语言，类似于HTML的JSX，以及CSS来开发移动应用，因此熟悉Web前端开发的技术人员只需很少的学习就可以进入移动应用开发领域。​ 由于RN和React原理相通，并且Flutter也是受React启发，很多思想也都是相通的，万丈高楼平地起，我们有必要深入了解一下React原理。React是一个响应式的Web框架，我们先了解一下两个重要的概念：DOM树与响应式编程。​ &gt;DOM树:​ &gt;响应式编程:​ PS:​ &gt;react?​ -Weex简介​ Weex是阿里巴巴于2016年发布的跨平台移动端开发框架，思想及原理和React Native类似，最大的不同是语法层面，Weex支持Vue语法和Rax语法，Rax 的 DSL(Domain Specific Language) 语法是基于 React JSX 语法而创造。与 React 不同，在 Rax 中 JSX 是必选的，它不支持通过其它方式创建组件，所以学习 JSX 是使用 Rax 的必要基础。而React Native只支持JSX语法。​ -快应用简介​ 采用JavaScript语言开发，原生控件渲染，与React Native和Weex相比主要有两点不同：​ 快应用自身不支持Vue或React语法，其采用原生JavaScript开发，其开发框架和微信小程序很像，值得一提的是小程序目前已经可以使用Vue语法开发（mpvue），从原理上来讲，Vue的语法也可以移植到快应用上。​ React Native和Weex的渲染/排版引擎是集成到框架中的，每一个APP都需要打包一份，安装包体积较大；而快应用渲染/排版引擎是集成到ROM中的，应用中无需打包，安装包体积小，正因如此，快应用才能在保证性能的同时做到快速分发。 自绘UI+原生(QT for mobile、Flutter)​ QT :​ 初识FlutterFlutter简介 Flutter 是 Google推出并开源的移动应用开发框架，主打跨平台、高保真、高性能。开发者可以通过 Dart语言开发 App，一套代码同时运行在 iOS 和 Android平台。 Flutter提供了丰富的组件、接口，开发者可以很快地为 Flutter添加 native扩展。同时 Flutter还使用 Native引擎渲染视图，这无疑能为用户提供良好的体验。 跨平台自绘引擎Flutter与用于构建移动应用程序的其它大多数框架不同，因为Flutter既不使用WebView，也不使用操作系统的原生控件。 相反，Flutter使用自己的高性能渲染引擎来绘制widget。这样不仅可以保证在Android和iOS上UI的一致性，而且也可以避免对原生控件依赖而带来的限制及高昂的维护成本。 Flutter使用Skia作为其2D渲染引擎，Skia是Google的一个2D图形处理函数库，包含字型、坐标转换，以及点阵图都有高效能且简洁的表现，Skia是跨平台的，并提供了非常友好的API，目前Google Chrome浏览器和Android均采用Skia作为其绘图引擎。 目前Flutter目前默认支持iOS、Android、Fuchsia（Google新的自研操作系统）三个移动平台。但Flutter亦可支持Web开发（Flutter for web）和PC开发，本书的示例和介绍主要是基于iOS和Android平台的，其它平台读者可以自行了解。 高性能 Flutter高性能主要靠两点来保证，首先，Flutter APP采用Dart语言开发。Dart在 JIT（即时编译）模式下，速度与 JavaScript基本持平。但是 Dart支持 AOT，当以 AOT模式运行时，JavaScript便远远追不上了。速度的提升对高帧率下的视图数据计算很有帮助。其次，Flutter使用自己的渲染引擎来绘制UI，布局数据等由Dart语言直接控制，所以在布局过程中不需要像RN那样要在JavaScript和Native之间通信，这在一些滑动和拖动的场景下具有明显优势，因为在滑动和拖动过程往往都会引起布局发生变化，所以JavaScript需要和Native之间不停的同步布局信息，这和在浏览器中要JavaScript频繁操作DOM所带来的问题是相同的，都会带来比较可观的性能开销。 采用Dart语言开发这是一个很有意思，但也很有争议的问题，在了解Flutter为什么选择了 Dart而不是 JavaScript之前我们先来介绍两个概念：JIT和AOT。 目前，程序主要有两种运行方式：静态编译与动态解释。 静态编译的程序在执行前全部被翻译为机器码，通常将这种类型称为AOT （Ahead of time）即 “提前编译”； 动态解释执行的则是一句一句边翻译边运行，通常将这种类型称为JIT（Just-in-time）即“即时编译”。 AOT程序的典型代表是用C/C++开发的应用，它们必须在执行前编译成机器码，而JIT的代表则非常多，如JavaScript、python等，事实上，所有脚本语言都支持JIT模式。但需要注意的是JIT和AOT指的是程序运行方式，和编程语言并非强关联的，有些语言既可以以JIT方式运行也可以以AOT方式运行，如Java、Python，它们可以在第一次执行时编译成中间字节码、然后在之后执行时可以直接执行字节码，也许有人会说，中间字节码并非机器码，在程序执行时仍然需要动态将字节码转为机器码，是的，这没有错，不过通常我们区分是否为AOT的标准就是看代码在执行之前是否需要编译，只要需要编译，无论其编译产物是字节码还是机器码，都属于AOT。 现在我们看看Flutter为什么选择Dart语言？笔者根据官方解释以及自己对Flutter的理解总结了以下几条（由于其它跨平台框架都将JavaScript作为其开发语言，所以主要将Dart和JavaScript做一个对比）： 开发效率高 Dart运行时和编译器支持Flutter的两个关键特性的组合： 基于JIT的快速开发周期：Flutter在开发阶段采用，采用JIT模式，这样就避免了每次改动都要进行编译，极大的节省了开发时间； 基于AOT的发布包: Flutter在发布时可以通过AOT生成高效的ARM代码以保证应用性能。而JavaScript则不具有这个能力。 高性能 Flutter旨在提供流畅、高保真的的UI体验。为了实现这一点，Flutter中需要能够在每个动画帧中运行大量的代码。这意味着需要一种既能提供高性能的语言，而不会出现会丢帧的周期性暂停，而Dart支持AOT，在这一点上可以做的比JavaScript更好。 3.快速内存分配 Flutter框架使用函数式流，这使得它在很大程度上依赖于底层的内存分配器。因此，拥有一个能够有效地处理琐碎任务的内存分配器将显得十分重要，在缺乏此功能的语言中，Flutter将无法有效地工作。当然Chrome V8的JavaScript引擎在内存分配上也已经做的很好，事实上Dart开发团队的很多成员都是来自Chrome团队的，所以在内存分配上Dart并不能作为超越JavaScript的优势，而对于Flutter来说，它需要这样的特性，而Dart也正好满足而已。 4.类型安全 由于Dart是类型安全的语言，支持静态类型检测，所以可以在编译前发现一些类型的错误，并排除潜在问题，这一点对于前端开发者来说可能会更具有吸引力。与之不同的，JavaScript是一个弱类型语言，也因此前端社区出现了很多给JavaScript代码添加静态类型检测的扩展语言和工具，如：微软的TypeScript以及Facebook的Flow。相比之下，Dart本身就支持静态类型，这是它的一个重要优势。 5.Dart团队就在你身边 看似不起眼，实则举足轻重。由于有Dart团队的积极投入，Flutter团队可以获得更多、更方便的支持，正如Flutter官网所述“我们正与Dart社区进行密切合作，以改进Dart在Flutter中的使用。例如，当我们最初采用Dart时，该语言并没有提供生成原生二进制文件的工具链（这对于实现可预测的高性能具有很大的帮助），但是现在它实现了，因为Dart团队专门为Flutter构建了它。同样，Dart VM之前已经针对吞吐量进行了优化，但团队现在正在优化VM的延迟时间，这对于Flutter的工作负载更为重要。” Flutter框架结构 Flutter Framework这是一个纯 Dart实现的 SDK，它实现了一套基础库，自底向上，我们来简单介绍一下： 底下两层（Foundation和Animation、Painting、Gestures）在Google的一些视频中被合并为一个dart UI层，对应的是Flutter中的dart:ui包，它是Flutter引擎暴露的底层UI库，提供动画、手势及绘制能力。 Rendering层，这一层是一个抽象的布局层，它依赖于dart UI层，Rendering层会构建一个UI树，当UI树有变化时，会计算出有变化的部分，然后更新UI树，最终将UI树绘制到屏幕上，这个过程类似于React中的虚拟DOM。Rendering层可以说是Flutter UI框架最核心的部分，它除了确定每个UI元素的位置、大小之外还要进行坐标变换、绘制(调用底层dart:ui)。 Widgets层是Flutter提供的的一套基础组件库，在基础组件库之上，Flutter还提供了 Material 和Cupertino两种视觉风格的组件库。而我们Flutter开发的大多数场景，只是和这两层打交道。 Flutter Engine这是一个纯 C++实现的 SDK，其中包括了 Skia引擎、Dart运行时、文字排版引擎等。在代码调用 dart:ui库时，调用最终会走到Engine层，然后实现真正的绘制逻辑。 学习Flutter资源 官网：阅读Flutter官网的资源是快速入门的最佳方式，同时官网也是了解最新Flutter发展动态的地方，由于目前Flutter仍然处于快速发展阶段，所以建议读者还是时不时的去官网看看有没有新的动态。 源码及注释：源码注释应作为学习Flutter的第一文档，Flutter SDK的源码是开源的，并且注释非常详细，也有很多示例，实际上，Flutter官方的SDK文档就是通过注释生成的。源码结合注释可以帮你解决大多数问题。 Github：如果遇到的问题在StackOverflow上也没有找到答案，可以去github flutter 项目下提issue。 Gallery源码：Gallery是Flutter官方示例APP，里面有丰富的示例，读者可以在网上下载安装。Gallery的源码在Flutter源码“examples”目录下。 搭建Flutter开发环境获取Flutter SDKFlutterSDK Windows下安装解压到任意盘: 用户变量: Path:追加xxx/Flutter/Bin/ 新建: 变量名=变量值 1PUB_HOSTED_URL&#x3D;https:&#x2F;&#x2F;pub.flutter-io.cn 1FLUTTER_STORAGE_BASE_URL&#x3D;https:&#x2F;&#x2F;storage.flutter-io.cn 重启电脑 运行flutter doctor -v 逐步解决 1.安装插件 Flutter&amp;Dart 2.配置环境变量 ANDROID_HOME=F:\\Develop_AndroidStudio\\AndroidSDK\\platform-tools Path下添加F:\\Develop_AndroidStudio\\AndroidSDK\\platform-tools Problem:Android license status Unknow. Solution: https://www.wandouip.com/t5i325108/ 简要记录下: F:\\Develop_AndroidStudio\\AndroidSDK\\tools\\bin目录下 执行: 1sdkmanager.bat --update 出现错误: 1234567891011Exception in thread &quot;main&quot; java.lang.NoClassDefFoundError: javax&#x2F;xml&#x2F;bind&#x2F;annotation&#x2F;XmlSchema at com.android.repository.api.SchemaModule$SchemaModuleVersion.&lt;init&gt;(SchemaModule.java:156) at com.android.repository.api.SchemaModule.&lt;init&gt;(SchemaModule.java:75) at com.android.sdklib.repository.AndroidSdkHandler.&lt;clinit&gt;(AndroidSdkHandler.java:81) at com.android.sdklib.tool.sdkmanager.SdkManagerCli.main(SdkManagerCli.java:73) at com.android.sdklib.tool.sdkmanager.SdkManagerCli.main(SdkManagerCli.java:48)Caused by: java.lang.ClassNotFoundException: javax.xml.bind.annotation.XmlSchema at java.base&#x2F;jdk.internal.loader.BuiltinClassLoader.loadClass(BuiltinClassLoader.java:583) at java.base&#x2F;jdk.internal.loader.ClassLoaders$AppClassLoader.loadClass(ClassLoaders.java:178) at java.base&#x2F;java.lang.ClassLoader.loadClass(ClassLoader.java:521) ... 5 more 根据笔者的解决方法:(原因是java版本8就可以java9之后阉割了一些库,本人12.0.2) 需要添加jaxb相关依赖： 下载: :jack_o_lantern: activation.jar:jack_o_lantern: jaxb-api.jar:jack_o_lantern: jaxb-core.jar:jack_o_lantern: jaxb-impl.jar:jack_o_lantern: jaxb-jxc.jar:jack_o_lantern: jaxb-xjc.jar jar地址: java2s jar-download mvnjar xxx/AndroidSDK/tools/jaxb PS:jaxb为新建目录,jar包放在此目录下(放在lib下也可以,配置对就行) Sublime打开Bin下 sdkmanager.bat 第66行 1set CLASSPATH&#x3D;%APP_HOME%\\jaxb\\activation.jar;%APP_HOME%\\jaxb\\jaxb-impl.jar;%APP_HOME%\\jaxb\\jaxb-xjc.jar;%APP_HOME%\\jaxb\\jaxb-core.jar;%APP_HOME%\\jaxb\\jaxb-jxc.jar;%APP_HOME%\\jaxb\\jaxb-api.jar;%APP_HOME%\\lib\\dvlib-26.0.0-dev.jar;%APP_HOME%\\lib\\jimfs-1.1.jar;%APP_HOME%\\lib\\jsr305-1.3.9.jar;%APP_HOME%\\lib\\repository-26.0.0-dev.jar;%APP_HOME%\\lib\\j2objc-annotations-1.1.jar;%APP_HOME%\\lib\\layoutlib-api-26.0.0-dev.jar;%APP_HOME%\\lib\\gson-2.3.jar;%APP_HOME%\\lib\\httpcore-4.2.5.jar;%APP_HOME%\\lib\\commons-logging-1.1.1.jar;%APP_HOME%\\lib\\commons-compress-1.12.jar;%APP_HOME%\\lib\\annotations-26.0.0-dev.jar;%APP_HOME%\\lib\\error_prone_annotations-2.0.18.jar;%APP_HOME%\\lib\\animal-sniffer-annotations-1.14.jar;%APP_HOME%\\lib\\httpclient-4.2.6.jar;%APP_HOME%\\lib\\commons-codec-1.6.jar;%APP_HOME%\\lib\\common-26.0.0-dev.jar;%APP_HOME%\\lib\\kxml2-2.3.0.jar;%APP_HOME%\\lib\\httpmime-4.1.jar;%APP_HOME%\\lib\\annotations-12.0.jar;%APP_HOME%\\lib\\sdklib-26.0.0-dev.jar;%APP_HOME%\\lib\\guava-22.0.jar PS:前6项是追加进去的,如下: 1%APP_HOME%\\jaxb\\activation.jar;%APP_HOME%\\jaxb\\jaxb-impl.jar;%APP_HOME%\\jaxb\\jaxb-xjc.jar;%APP_HOME%\\jaxb\\jaxb-core.jar;%APP_HOME%\\jaxb\\jaxb-jxc.jar;%APP_HOME%\\jaxb\\jaxb-api.jar; 保存OK,继续Bin下执行 1sdkmanager.bat --update 至此,会出现: 12Some Android licenses not accepted. To resolve this, run: flutter doctor --android-licenses 根据指示执行: 1flutter doctor --android-licenses 一路y+回车就ok了. 连接Android设备要准备在Android设备上运行并测试您的Flutter应用，您需要安装Android 4.1（API level 16）或更高版本的Android设备. 在您的设备上启用 开发人员选项 和 USB调试 。详细说明可在Android文档中找到。 使用USB将手机插入电脑。如果您的设备出现提示，请授权您的计算机访问您的设备。 在终端中，运行 flutter devices 命令以验证Flutter识别您连接的Android设备。 运行启动您的应用程序 flutter run。 默认情况下，Flutter使用的Android SDK版本是基于你的 adb 工具版本。 如果您想让Flutter使用不同版本的Android SDK，则必须将该 ANDROID_HOME 环境变量设置为SDK安装目录。 使用Android模拟器要准备在Android模拟器上运行并测试您的Flutter应用，请按照以下步骤操作： 在您的机器上启用 VM acceleration . 启动 Android Studio&gt;Tools&gt;Android&gt;AVD Manager 并选择 Create Virtual Device. 选择一个设备并选择 Next。 为要模拟的Android版本选择一个或多个系统映像，然后选择 Next. 建议使用 x86 或 x86_64 image . 在 Emulated Performance下, 选择 Hardware - GLES 2.0 以启用 硬件加速. 验证AVD配置是否正确，然后选择 Finish。 有关上述步骤的详细信息，请参阅 Managing AVDs. 在 Android Virtual Device Manager中, 点击工具栏的 Run。模拟器启动并显示所选操作系统版本或设备的启动画面. 运行 flutter run 启动您的设备. 连接的设备名是 Android SDK built for,其中 platform 是芯片系列, 如 x86. 体验第一个FlutterAPP创建 一直在creat,发现文件夹已创建了一些文件,就结束了Android Studio进程,重启.直接去文件夹打开项目,然而问题又出现了. 缺少依赖包: can not get packages from”https://pub.flutter-io.cn/%2xx&quot; 应该是镜像路径问题.复制去看了下: 目的网址应该是https://pub.flutter-io.cn/ 后面应该是配置错误. 然后在环境变量中,加入了/ 1FLUTTER_STORAGE_BASE_URL&#x3D;https:&#x2F;&#x2F;storage.flutter-io.cn&#x2F; 1UB_HOSTED_URL&#x3D;https:&#x2F;&#x2F;pub.flutter-io.cn&#x2F; 重启OK了.","categories":[{"name":"Geek","slug":"Geek","permalink":"https://casuor.top/categories/Geek/"}],"tags":[]},{"title":"Draw.io","slug":"res-draw.io","date":"2019-07-24T16:00:00.000Z","updated":"2020-10-28T09:58:54.890Z","comments":true,"path":"2019/07/25/res-draw.io/","link":"","permalink":"https://casuor.top/2019/07/25/res-draw.io/","excerpt":"","text":"Draw.io桌面Draw.io Release ONLINEhttps://draw.io 扩展GET以前知道这格式文件，没有详细了解使用。 SVG可以算是目前最最火热的图像文件格式了，它的英文全称为Scalable Vector Graphics，意思为可缩放的矢量图形。它是基于XML（Extensible Markup Language），由World Wide Web Consortium（W3C）联盟进行开发的。严格来说应该是一种开放标准的矢量图形语言，可让你设计激动人心的、高分辨率的Web图形页面。用户可以直接用代码来描绘图像，可以用任何文字处理工具打开SVG图像，通过改变部分代码来使图像具有交互功能，并可以随时插入到HTML中通过浏览器来观看。 ●SVG 指可伸缩矢量图形 (Scalable Vector Graphics) ●SVG 用来定义用于网络的基于矢量的图形 ●SVG 使用 XML 格式定义图形 ●SVG 图像在放大或改变尺寸的情况下其图形质量不会有所损失 ●SVG 是万维网联盟的标准 ●SVG 与诸如 DOM 和 XSL 之类的 W3C 标准是一个整体","categories":[{"name":"Geek","slug":"Geek","permalink":"https://casuor.top/categories/Geek/"}],"tags":[]},{"title":"转载-WallpaperAPI","slug":"trans-Blog-wallpaperAPI","date":"2019-06-27T16:00:00.000Z","updated":"2020-10-28T09:58:54.892Z","comments":true,"path":"2019/06/28/trans-Blog-wallpaperAPI/","link":"","permalink":"https://casuor.top/2019/06/28/trans-Blog-wallpaperAPI/","excerpt":"","text":"360壁纸转载自:AV25757959,侵删,联系方式接口一：获取壁纸分类 http://cdn.apc.360.cn/index.php?c=WallPaper&amp;a=getAllCategoriesV2&amp;from=360chrome 这个接口很简单，直接请求上述网址，就可以得到 json 数据。返回的数据中有个 data 数组，其中的“name”就是获取到的壁纸分类名，“id”就是这个分类对应的ID值。 接口二：根据壁纸分类ID获取分类下壁纸图片 http://wallpaper.apc.360.cn/index.php? c=WallPaper&amp;a=getAppsByCategory &amp;cid=【刚才获取到的分类ID】 &amp;start=【从第几幅图开始(用于分页)】 &amp;count=【每次加载的数量】&amp;from=360chrome 通过这个接口获取到的数据有点多，但主要要用到的只有几个。一是 data 数组中的 url 值，就是我们要获取的图片链接。它的格式类似于： http://p15.qhimg.com/bdr/__85/t0151ad4ac41239cb58.jpg 我们可以根据它来获取这张图片的指定分辨率以及指定画质的图片，以上图为例，如果我们要获取分辨率为 1024*768 ，画质为 80 (最高为100)的图片，只需将上述链接的 “bdr/__85” 替换为 “bdm/1024_768_80” 即可。替换后的图片链接如下： http://p19.qhimg.com/bdm/1024_768_80/t0151ad4ac41239cb58.jpg （注：有些图片如果原图本身就小，不会被拉伸） 除去 url 值，data 数组中的 tag 是图片对应的标签，如果需要也可以进行获取。 接口三：获取最近更新的壁纸http://wallpaper.apc.360.cn/index.php?c=WallPaper&amp;a=getAppsByOrder&amp;order=create_time&amp;start=【偏移量，从0开始】&amp;count=【加载张数】&amp;from=360chrome 这个接口的参数是固定的，并且获取到的数据格式与接口二的一样。这里就不在赘述了。 必应壁纸Bing搜索的首页每天都会推送一张很漂亮的图片，把它保存下来，当做电脑桌面或是自己的网站背景图还不是美滋滋…… 既然要抓取这张图片，首先就得弄清这张图是从何而来的。经过对必应首页的抓包，我们可以获得首页图的获取API。它的格式是这样的： http://cn.bing.com/HPImageArchive.aspx?format=js&amp;idx=0&amp;n=1 注意，这里有几个GET参数，它们的作用分别是： n，必要参数。这是输出信息的数量。比如n=1，即为1条，以此类推，至多输出8条。 format，非必要。返回结果的格式，不存在或者等于xml时，输出为xml格式，等于js时，输出json格式 idx，非必要。不存在或者等于0时，输出当天的图片，-1为已经预备用于明天显示的信息，1则为昨天的图片，以此类推，idx最多获取到前16天的图片信息 这里将n设定为1、format设定为js、idx设定为1，去发出GET请求，返回的数据是这样的： 123456789101112131415161718192021222324252627&#123; \"images\": [ &#123; \"startdate\": \"20161222\", \"fullstartdate\": \"201612221600\", \"enddate\": \"20161223\", \"url\": \"/az/hprichbg/rb/TheDomeEdinburgh_ZH-CN11993142817_1920x1080.jpg\", \"urlbase\": \"/az/hprichbg/rb/TheDomeEdinburgh_ZH-CN11993142817\", \"copyright\": \"爱丁堡一家叫做The Dome的夜店，苏格兰 (© Marty McKillop/500px)\", \"copyrightlink\": \"http://www.bing.com/search?q=The+Dome,+Edinburgh&amp;form=hpcapt&amp;mkt=zh-cn\", \"quiz\": \"/search?q=Bing+homepage+quiz&amp;filters=WQOskey:%22HPQuiz_20161222_TheDomeEdinburgh%22&amp;FORM=HPQUIZ\", \"wp\": false, \"hsh\": \"376393c9b49c6d8d1a6e7c2d38343105\", \"drk\": 1, \"top\": 1, \"bot\": 1, \"hs\": [] &#125; ], \"tooltips\": &#123; \"loading\": \"正在加载...\", \"previous\": \"上一个图像\", \"next\": \"下一个图像\", \"walle\": \"此图片不能下载用作壁纸。\", \"walls\": \"下载今日美图。仅限用作桌面壁纸。\" &#125;&#125; 其中的“images”节点下的“url”值便是我们要获取的图像地址。我们把它取出来，再加上Bing的网址前缀(http://cn.bing.com)即组合成了完整的图像地址。比如说上面返回数据的完整图像地址是这样的： http://cn.bing.com/az/hprichbg/rb/TheDomeEdinburgh_ZH-CN11993142817_1920x1080.jpg 知道了背景图的获取方式，接下来就是用PHP去动态抓取了。 如果你只是单纯的想用作网页背景的话，你只需新建一个php文件，里面贴入如下代码： 12345678&lt;?php$str = file_get_contents('http://cn.bing.com/HPImageArchive.aspx?idx=0&amp;n=1'); //从bing获取数据if(preg_match(\"/&lt;url&gt;(.+?)&lt;\\/url&gt;/ies\",$str,$matches))&#123; //正则匹配抓取图片url $imgurl='http://cn.bing.com'.$matches[1];&#125;else&#123; //如果由于某些原因，没抓取到图片地址 $imgurl='http://img.infinitynewtab.com/InfinityWallpaper/2_14.jpg'; //使用默认的图像(默认图像链接可修改为自己的)&#125;header(\"Location: $imgurl\"); //header跳转 然后把这个php文件上传到你的服务器或者是网站空间，访问这个php应该就能看到被跳转到了Bing的图片。 使用方法：直接将那个php文件的绝对地址当做图片放进网页中即可。 比如说，如果你的这个php的地址为“http://www.myweb.cn/bing.php”，那么你在你自己的网页的css中这么写就能当背景使用了： 123456789body&#123; width:100%; height:100%; background: url(http://www.myweb.cn/bing.php) no-repeat; -moz-background-size: cover; /*背景图片拉伸以铺满全屏*/ -ms-background-size: cover; -webkit-background-size: cover; background-size: cover;&#125; 以上方法只是简单地跳转，如果想要抓取这张图片并保存到服务器呢？这里直接贴代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&lt;?php/** * php抓取bing每日图片并保存到服务器 * 作者：mengkun (mkblog.cn) * 日期：2016/12/23 */$path = 'temp'; //设置图片缓存文件夹$filename = date(\"Ymd\") . '.jpg'; //用年月日来命名新的文件名if (!file_exists($path.'/'. $filename)) //如果文件不存在，则说明今天还没有进行缓存&#123; if(!file_exists($path)) //如果目录不存在 &#123; mkdir($path, 0777); //创建缓存目录 &#125; $str = file_get_contents('http://cn.bing.com/HPImageArchive.aspx?format=js&amp;idx=0&amp;n=1'); //读取必应api，获得相应数据 $str = json_decode($str,true); $imgurl = 'http://cn.bing.com'.$str['images'][0]['url']; //获取图片url $img = grabImage($imgurl, $path.'/'.$filename); //读取并保存图片 $handle = fopen(\"dat.txt\", \"a\"); //用于存放图片信息，如果不需要保存图片的相关信息，可以把下面这些去掉。 if ($handle) &#123; $copyright = $str['images'][0]['copyright']; //说明 $startdate = $str['images'][0]['startdate']; $fullstartdate = $str['images'][0]['fullstartdate']; $enddate = $str['images'][0]['enddate']; $urlbase = $str['images'][0]['urlbase']; $copyrightlink = $str['images'][0]['copyrightlink']; $quiz = $str['images'][0]['quiz']; $wp = $str['images'][0]['wp']; $hsh = $str['images'][0]['hsh']; $drk = $str['images'][0]['drk']; $top = $str['images'][0]['top']; $bot = $str['images'][0]['bot']; $tempArr = array(\"imgurl\"=&gt;$imgurl,\"copyright\"=&gt;$copyright, \"startdate\"=&gt;$startdate, \"fullstartdate\"=&gt;$fullstartdate, \"enddate\"=&gt; $enddate, \"urlbase\"=&gt;$urlbase, \"copyrightlink\"=&gt; $copyrightlink, \"quiz\"=&gt;$quiz, \"wp\"=&gt; $wp, \"hsh\"=&gt;$hsh,\"drk\"=&gt;$drk, \"top\"=&gt; $top, \"bot\"=&gt; $bot); //将相关信息放进数组中 fwrite($handle, json_encode($tempArr) .\"\\r\\n\"); //最终以json格式保存在文本文档中 fclose($handle); &#125;&#125;/** * 远程抓取图片并保存 * @param $url 图片url * @param $filename 保存名称和路径 */function grabImage($url, $filename = \"\")&#123; if($url == \"\") return false; //如果$url地址为空，直接退出 if ($filename == \"\") //如果没有指定新的文件名 &#123; $ext = strrchr($url, \".\"); //得到$url的图片格式 $filename = date(\"Ymd\") . $ext; //用天月面时分秒来命名新的文件名 &#125; ob_start(); //打开输出 readfile($url); //输出图片文件 $img = ob_get_contents(); //得到浏览器输出 ob_end_clean(); //清除输出并关闭 $size = strlen($img); //得到图片大小 $fp2 = @fopen($filename, \"a\"); fwrite($fp2, $img); //向当前目录写入图片文件，并重新命名 fclose($fp2); return $filename; //返回新的文件名&#125; 这样，如果这个php被访问，它就会自动启动抓取并保存。你可以用阿里云监控或其他类型的网站监控服务来实现每天自动运行这个php。","categories":[{"name":"Transfer","slug":"Transfer","permalink":"https://casuor.top/categories/Transfer/"}],"tags":[]},{"title":"oh-my-posh for windows terminal","slug":"geek_powershell","date":"2019-06-24T16:00:00.000Z","updated":"2020-10-28T09:58:54.885Z","comments":true,"path":"2019/06/25/geek_powershell/","link":"","permalink":"https://casuor.top/2019/06/25/geek_powershell/","excerpt":"","text":"仓库地址：oh my posh","categories":[{"name":"Geek","slug":"Geek","permalink":"https://casuor.top/categories/Geek/"}],"tags":[]},{"title":"JsDeliver-usages","slug":"geek_jsDelivrUsage","date":"2019-04-24T16:00:00.000Z","updated":"2020-10-28T09:58:54.883Z","comments":true,"path":"2019/04/25/geek_jsDelivrUsage/","link":"","permalink":"https://casuor.top/2019/04/25/geek_jsDelivrUsage/","excerpt":"","text":"GitHub CDNWe recommend using npm for projects that support it for better UX - npm packages are searchable on our website, and package pages show additional useful information, such as description and link to homepage.We use a permanent S3 storage to ensure all files remain available even if GitHub goes down, or a repository or a release is deleted by its author. Files are fetched directly from GitHub only the first time, or when S3 goes down.Load any GitHub release, commit, or branch: https://cdn.jsdelivr.net/gh/user/repo@version/fileLoad an exact version of a file: https://cdn.jsdelivr.net/gh/jquery/jquery@3.2.1/dist/jquery.min.jshttps://cdn.jsdelivr.net/gh/jquery/jquery@32b00373b3f42e5cdcb709df53f3b08b7184a944/dist/jquery.min.jsUse a version range instead of an exact version: https://cdn.jsdelivr.net/gh/jquery/jquery@3.2/dist/jquery.min.jshttps://cdn.jsdelivr.net/gh/jquery/jquery@3/dist/jquery.min.jsIf you use this feature and a file you requested is not available in the newest release, the link will keep working thanks to our version-fallback feature. We’ll continue to serve the file from older release instead of failing with a 404 error.Omit the version completely or use “latest” to load the latest one (not recommended for production usage): https://cdn.jsdelivr.net/gh/jquery/jquery@latest/dist/jquery.min.jshttps://cdn.jsdelivr.net/gh/jquery/jquery/dist/jquery.min.jsRequesting the latest version (as opposed to “latest major” or “latest minor”) is dangerous because major versions usually come with breaking changes. Only do this if you really know what you are doing.Add “.min” to any JS/CSS file to get a minified version - if one doesn’t exist, we’ll generate it for you. All generated files come with source maps and can be easily used during development: https://cdn.jsdelivr.net/gh/jquery/jquery@3.2.1/src/core.min.jsMinifying a large file can take several seconds. However, we store all generated files in our permanent storage, so this delay only applies to the first few requests.Get a directory listing: https://cdn.jsdelivr.net/gh/jquery/jquery@3.2.1/https://cdn.jsdelivr.net/gh/jquery/jquery@3.2.1/dist/Combine multiple filesOur combine endpoint allows you to load several files from npm and GitHub endpoints in one request: https://cdn.jsdelivr.net/combine/url1,url2,url3All features that work for individual files (version ranges, minification, etc.) work here as well. All combined files come with source maps and can be easily used during development. https://cdn.jsdelivr.net/combine/gh/jquery/jquery@3.2/dist/jquery.min.js,gh/twbs/bootstrap@3.3/dist/js/bootstrap.min.jshttps://cdn.jsdelivr.net/combine/npm/bootstrap@3.3/dist/css/bootstrap.min.css,npm/bootstrap@3.3/dist/css/bootstrap-theme.min.cssCombining large/many files can take several seconds. However, we store all generated files in our permanent storage, so this delay only applies to the first few requests. ProblemPackage size exceeded the configured limit of 50 MB","categories":[{"name":"Geek","slug":"Geek","permalink":"https://casuor.top/categories/Geek/"}],"tags":[]},{"title":"PHP Notes","slug":"geek_learningphp","date":"2019-04-24T16:00:00.000Z","updated":"2020-10-28T09:58:54.884Z","comments":true,"path":"2019/04/25/geek_learningphp/","link":"","permalink":"https://casuor.top/2019/04/25/geek_learningphp/","excerpt":"","text":"PHP学习笔记配置ApacheServerPS::alarm_clock:IDE好用. 安装apache服务httpd -k install -n &quot;Apache Server&quot; 注：设置下面servername 即可，但一般使用虚拟主机，可以不对其设置 设置ServerName(可省略) F:\\Develop_Apache_HttpServer\\httpd-2.4.39-win64-VC15\\Apache24\\conf\\httpd.conf 227 #ServerName www.example.com:80 228 #ServerName localhost --设置设置监听端口listen 80每次更改重启服务 本机：localhost:80 cmd进入Apache目录测试配置是否有错误httpd -t //测试配置是否OK网站根目录 DocumentRoot &quot;${SRVROOT}/htdocs&quot; &lt;Directory &quot;${SRVROOT}/htdocs&quot;&gt; 修改htdocs即可更改后出现forbidden &lt;Directory &quot;${SRVROOT}/htdocs&quot;&gt;#记得更改这个路径,一改全改 # # Possible values for the Options directive are &quot;None&quot;, &quot;All&quot;, # or any combination of: # Indexes Includes FollowSymLinks SymLinksifOwnerMatch ExecCGI MultiViews # # Note that &quot;MultiViews&quot; must be named *explicitly* --- &quot;Options All&quot; # doesn&apos;t give it to you. # # The Options directive is both complicated and important. Please see # http://httpd.apache.org/docs/2.4/mod/core.html#options # for more information. # Options Indexes FollowSymLinks # # AllowOverride controls what directives may be placed in .htaccess files. # It can be &quot;All&quot;, &quot;None&quot;, or any combination of the keywords: # AllowOverride FileInfo AuthConfig Limit # AllowOverride None # # Controls who can get stuff from this server. # Require all granted &lt;/Directory&gt;默认打开文档&lt;IfModule dir_module&gt; DirectoryIndex index.html &lt;/IfModule&gt;配置能否浏览目录结构&lt;Directory &quot;${SRVROOT}/htdocs&quot;&gt; # # Possible values for the Options directive are &quot;None&quot;, &quot;All&quot;, # or any combination of: # Indexes Includes FollowSymLinks SymLinksifOwnerMatch ExecCGI MultiViews # # Note that &quot;MultiViews&quot; must be named *explicitly* --- &quot;Options All&quot; # doesn&apos;t give it to you. # # The Options directive is both complicated and important. Please see # http://httpd.apache.org/docs/2.4/mod/core.html#options # for more information. # Options Indexes FollowSymLinks #看这里，去掉Indexes就访问不到了 # # AllowOverride controls what directives may be placed in .htaccess files. # It can be &quot;All&quot;, &quot;None&quot;, or any combination of the keywords: # AllowOverride FileInfo AuthConfig Limit # AllowOverride None # # Controls who can get stuff from this server. # Require all granted &lt;/Directory&gt;配置虚拟主机(一台机器，多个网站) 第一步 12345#行号 内容510 # Virtual hosts #去除注释511 Include conf&#x2F;extra&#x2F;httpd-vhosts.conf 第二步 本机目录：F:\\Develop_Apache_HttpServer\\httpd-2.4.39-win64-VC15\\Apache24\\conf\\extra\\httpd-vhosts.conf 123456789101112131415161718注： 特意的要去host文件去设置域名 htdocs在这里即是根目录与config文件中要相同 由于多个虚拟主机一同工作，所以需设置域名 #*:80 监听绑定在当前电脑上的任意IP的80端口&lt;VirtualHost *:80&gt;#根目录 DocumentRoot &quot;$&#123;SRVROOT&#125;&#x2F;htdocs&quot;#域名，需要在C盘hosts文件(C:\\Windows\\System32\\drivers\\etc\\hosts)去设置本机为此域名(127.0.0.1 apache.store) ServerName apache.store#显示错误反馈邮箱，暂时用不到 #ServerAdmin webmaster@dummy-host2.example.com#错误日志 ErrorLog &quot;logs&#x2F;apache.store-error.log&quot;#日志 CustomLog &quot;logs&#x2F;apache.store-access.log&quot; common&lt;&#x2F;VirtualHost&gt;这个虚拟主机配置是默认配置。测试：apache.store 请求响应流程 让Apache支持PHP（解压PHP，加载模块，addtype ）配置主配置文件 把apache的工作交给php做（apache雇佣php工作） 配置前浏览器原样输出 配置内容 配置完成 重启服务测试效果如图 apache与PHP的关系 PHP基础PHP简介PHP:Hypertext Preprocessor https://www.php.net/manual/zh/history.php.php PHP开发工具PHP Storm 配置: 出现图二的情况: PHP语法基础PHP代码块及注释1234567&lt;?php//此处是PHP代码?&gt;/*当是纯的PHP代码时，可省略闭合的\"?&gt;\"*/#单行注释 PHP大小写敏感问题(变量)1.PHP自定义函数，类和关键字（如echo ,if else）不关心大小写。 2.变量（存储信息的容器）大小写敏感。 变量规则： 变量以$符号开头，其后是变量的名称 变量名称必须以字母或下划线开头 变量名称不能以数字开头 变量名称只能包含字母数字字符和下划线（a-z,0-9以及_） 变量名称对大小写敏感（$y和$Y是两个不同的变量） 注： 变量在赋值时创建，创建输出文本需加双引号。 变量的作用域: local（局部）global（全局）static（静态） 函数之外声明的变量拥有 Global 作用域，只能在函数以外进行访问。 函数内部声明的变量拥有 LOCAL 作用域，只能在函数内部进行访问。 123456789101112131415161718&lt;?php$x=5; // 全局作用域function myTest() &#123; $y=10; // 局部作用域 echo \"&lt;p&gt;测试函数内部的变量：&lt;/p&gt;\"; echo \"变量 x 是：$x\"; echo \"&lt;br&gt;\"; echo \"变量 y 是：$x\";&#125; myTest();echo \"&lt;p&gt;测试函数之外的变量：&lt;/p&gt;\";echo \"变量 x 是：$x\";echo \"&lt;br&gt;\";echo \"变量 y 是：$x\";?&gt; PHP global 关键词global 关键词用于访问函数内的全局变量。 123456789101112&lt;?php$x=5;$y=10;function myTest() &#123; global $x,$y; $y=$x+$y;&#125;myTest();echo $y; // 输出 15?&gt; PHP 同时在名为 $GLOBALS[index] 的数组中存储了所有的全局变量。下标存有变量名。这个数组在函数内也可以访问，并能够用于直接更新全局变量。 上面的例子可以这样重写： 1234567891011&lt;?php$x=5;$y=10;function myTest() &#123; $GLOBALS['y']=$GLOBALS['x']+$GLOBALS['y'];&#125; myTest();echo $y; // 输出 15?&gt; PHP全局变量——超全局变量PHP 中的许多预定义变量都是“超全局的”，这意味着它们在一个脚本的全部作用域中都可用。在函数或方法中无需执行 global $variable; 就可以访问它们。 这些超全局变量是： 123456789$GLOBALS $_SERVER $_REQUEST $_POST $_GET $_FILES $_ENV $_COOKIE $_SESSION $GLOBALS 用于在 PHP 脚本中的任意位置访问全局变量（从函数或方法中均可）。 PHP 在名为 $GLOBALS[index] 的数组中存储了所有全局变量。变量的名字就是数组的键。 123456789&lt;?php$x=75;$y=25;function addition()&#123; $GLOBALS['variable'] = $GLOBALS['x'] +$GLOBALS['y'];&#125;addition();echo \"$variable\";?&gt; $SERVER 保存关于报头、路径和脚本位置的信息。 详见:PHP教程.pdf_P35 1234567891011121314&lt;?phpecho $_SERVER['PHP_SELF'];echo \"&lt;br&gt;\";echo $_SERVER['HTTP_HOST'];echo \"&lt;br&gt;\";echo $_SERVER['SERVER_NAME'];echo \"&lt;br&gt;\";echo $_SERVER['HTTP_REFERER'];echo \"&lt;br&gt;\";echo $_SERVER['HTTP_USER_AGENT'];echo \"&lt;br&gt;\";echo $_SERVER['SCRIPT_NAME'];echo \"&lt;br&gt;\"; $REQUEST PHP $_REQUEST 用于收集 HTML 表单提交的数据。 12345678910111213141516//REQUEST用于获取html表单提交的数据&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=\"&lt;?php echo $_SERVER['PHP_SELF'];?&gt;\" method=\"post\"&gt;Name: &lt;input type=\"text\" name=\"name\"&gt;&lt;input type=\"submit\"&gt;&lt;/form&gt;&lt;?php$name = $_REQUEST['name'];echo $name;?&gt;&lt;/body&gt;&lt;/html&gt; $POSTPHP $_POST 广泛用于收集提交 method=”post” 的 HTML 表单后的表单数据。$_POST 也常用于传递变量。 12345678910111213141516PHP $_POST 广泛用于收集提交 method=\"post\" 的 HTML 表单后的表单数据。$_POST 也常用于传递变量。&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=\"&lt;?php echo $_SERVER['PHP_SELF'];?&gt;\" method=\"post\"&gt;Name: &lt;input type=\"text\" name=\"name\"&gt;&lt;input type=\"submit\"&gt;&lt;/form&gt;&lt;?php$name = $_POST['name'];echo $name;?&gt;&lt;/body&gt;&lt;/html&gt; $GET PHP $_GET 也可用于收集提交 HTML 表单 (method=”get”) 之后的表单数据。 $_GET 也可以收集 URL 中的发送的数据。 12345678&lt;html&gt;&lt;body&gt;&lt;a href=\"$_GET.php?subject=php&amp;web=www.w3cschool.com.cn\"&gt;TEST $_GET&lt;/a&gt;&lt;br&gt;&lt;?phpecho 'study&amp;nbsp;'.$_GET['subject'].'at&amp;nbsp'.$_GET['web'];?&gt;&lt;/body&gt;&lt;/html&gt; $FILES $_FILES 主要用在当需要上传二进制文件的地方，录入上传一个abc.mp3文件，则服务器端需要获得该文件的相关信息，则通过变量 $_FILES 来取得。$_FILES 超级全局变量包含通过POST方法向服务器上传的数据的有关信息。这个超级全局变量与其他的变量有所不同，它是一个二维数组，包含5个元素。 注:① 在 PHP 4.1.0 版本以前该数组的名称为 $HTTP_POST_FILES，它并不像 $_FILES 一样是自动全局变量。PHP 3 不支持 $HTTP_POST_FILES 数组。② 如果表单中没有选择上传的文件，则 PHP 变量 1$_FILES[‘userfile’][‘size’] _的值将为 0， 1$_FILES[‘userfile’][‘tmp_name’] 将为 none。③ error字段5个错误码： UPLOAD_ERR_OK 文件成功上传UPLOAD_ERR_INI_SIZE 文件大小超出了MAX_FILE_SIZE 指令所指定的最大值。UPLOAD_ERR_FORM_SIZE 文件大小超出了MAX_FILE_SIZE 隐藏表单域参数（可选）指定的最大值。UPLOAD_ERR_PARTIAL 文件只上传了一部分UPLOAD_ERR_NO_FILE 上传表单中没有指定文件 1234567891011&lt;html&gt;&lt;body&gt;&lt;form action=\"$_FILES.php\" method=\"post\" enctype=\"multipart/form-data\"&gt;&lt;input type=\"file\" name=\"file\" &gt;&lt;input type=\"submit\" name=\"submit\" value=\"上传\"&gt;&lt;/form&gt;&lt;?phpecho $_FILES['file']['name'];?&gt;&lt;/body&gt;&lt;/html&gt; $ENV PHP中的$_ENV是一个包含服务器端环境变量的数组，不同系统不完全一样。部分变量示例：$_ENV[ ‘HOSTNAME’ ] 服务器的主机名$_ENV[ ‘SHELL’ ] 系统 shell $_ENV只是被动的接受服务器端的环境变量并把它们转换为数组元素，你可以尝试直接输出它： 123456789&lt;?php//输出内容格式清晰，ThinkPHP可以直接用dump()var_dump($_ENV);echo \"&lt;hr&gt;\";//输出到屏幕print_r($_ENV);echo \"&lt;hr&gt;\";//输出key-value键值对foreach($_ENV as $key=&gt;$val)&#123;echo $key.'--------'.$val.'&lt;br&gt;';&#125; $_COOKIE cookie 常用于识别用户。cookie 是服务器留在用户计算机中的小文件。每当相同的计算机通过浏览器请求页面时，它同时会发送 cookie。通过 PHP，您能够创建并取回 cookie 的值。 12345678910&lt;html&gt;&lt;body&gt;&lt;?phpsetcookie(\"user\", \"Alex Porter\", 3600); echo $_COOKIE['user'];?&gt;&lt;/body&gt;&lt;/html&gt; $_SESSION PHP session 变量用于存储有关用户会话的信息，或更改用户会话的设置。Session 变量保存的信息是单一用户的，并且可供应用程序中的所有页面使用。 当您运行一个应用程序时，您会打开它，做些更改，然后关闭它。这很像一次会话。计算机清楚你是谁。它知道你何时启动应用程序，并在何时终止。但是在因特网上，存在一个问题：服务器不知道你是谁以及你做什么，这是由于 HTTP 地址不能维持状态。通过在服务器上存储用户信息以便随后使用，PHP session 解决了这个问题（比如用户名称、购买商品等）。不过，会话信息是临时的，在用户离开网站后将被删除。如果您需要永久储存信息，可以把数据存储在数据库中。Session 的工作机制是：为每个访问者创建一个唯一的 id (UID)，并基于这个 UID 来存储变量。UID 存储在 cookie 中，亦或通过 URL 进行传导。 1234567891011121314151617181920212223&lt;html&gt;&lt;body&gt;&lt;?php//①开始 PHP Session ://在您把用户信息存储到 PHP session 中之前，首先必须启动会话。//注释：session_start() 函数必须位于 标签之前//session_start();//②存储 和使用Session 变量：$_SESSION['views']=1;echo \"views=\". $_SESSION['views'];//③终结 Session//如果您希望删除某些 session 数据，可以使用 unset() 或 session_destroy() 函数。//通过 unset() 函数用于释放指定的 session 变量：unset($_SESSION['views']);//通过 session_destroy() 函数彻底终结 session：//session_destroy();?&gt;&lt;/body&gt;&lt;/html&gt; PHP魔术变量PHP 向它运行的任何脚本提供了大量的预定义常量。 不过很多常量都是由不同的扩展库定义的，只有在加载了这些扩展库时才会出现，或者动态加载后，或者在编译时已经包括进去了。 有八个魔术常量它们的值随着它们在代码中的位置改变而改变。 __LINE__ 123&gt;&lt;?php&gt;echo \"&lt;br&gt;\";&gt;echo \"这是第\".__LINE__.\"行！\"; _FILE_ 123456&lt;!--文件的完整路径和文件名。如果用在被包含文件中，则返回被包含的文件名自 PHP 4.0.2 起，__FILE__总是包含一个绝对路径（如果是符号连接，则是解析后的绝对路径），而在此之前的版本有时会包含一个相对路径。--&gt;&lt;?phpecho &#39;此文件位置在&#39;.__FILE__.&#39;.&#39;; _DIr_ 123456&lt;!--__DIR__文件所在的目录。如果用在被包括文件中，则返回被包括的文件所在的目录。它等价于 dirname(__FILE__)。除非是根目录，否则目录中名不包括末尾的斜杠。(PHP 5.3.0中新 增)--&gt;&lt;?phpecho &#39;该文件位于 “ &#39; . __DIR__ . &#39; ” &#39;; _FUNCTION_ 12345678910&lt;!--__FUNCTION__函数名称（PHP 4.3.0 新加）。自 PHP 5 起本常量返回该函数被定义时的名字（区分大小写）。在 PHP 4 中该值总是小写字母的。--&gt;&lt;?phpfunction test()&#123;echo &#39;方法名是&#39;.__FUNCTION__;&#125;test(); _CLASS_ 1234567891011121314151617181920&lt;!--类的名称（PHP 4.3.0 新加）。自 PHP 5 起本常量返回该类被定义时的名字（区分大小写）。在 PHP 4 中该值总是小写字母的。类名包括其被声明的作用区域（例如 Foo\\Bar）。注意自 PHP 5.4 起 __CLASS__ 对 trait 也起作用。当用在 trait 方法中时，__CLASS__ 是调用 trait 方法的类的名字。--&gt;&lt;?phpclass test&#123; function _print() &#123; echo &#39;类名为：&#39; . __CLASS__ . &quot;&lt;br&gt;&quot;; echo &#39;函数名为：&#39; . __FUNCTION__; &#125;&#125;$t &#x3D; new test();$t-&gt;_print();?&gt; __TRAIT__ 12345678910111213141516171819202122&lt;!--__TRAIT__Trait 的名字（PHP 5.4.0 新加）。自 PHP 5.4.0 起，PHP 实现了代码复用的一个方法，称为 traits。Trait 名包括其被声明的作用区域（例如 Foo\\Bar）。从基类继承的成员被插入的 SayWorld Trait 中的 MyHelloWorld 方法所覆盖。其行为 MyHelloWorld 类 中定义的方法一致。优先顺序是当前类中的方法会覆盖 trait 方法，而 trait 方法又覆盖了基类中的方 法。--&gt;&lt;?phpclass Base&#123; public function sayhello()&#123; echo &quot;hello&quot;; &#125;&#125;trait SayWorld&#123; public function sayhello()&#123; parent::sayhello(); echo &quot;world&quot;; &#125;&#125;class Myhelloworld extends Base&#123; use SayWorld;&#125;$o&#x3D;new Myhelloworld();$o-&gt;sayhello(); __METHOD__ 123456789&lt;!--返回该方法被定义时的名字（区分大小写）。--&gt;&lt;?phpfunction test()&#123; echo &#39;函数名为:&#39;.__METHOD__;&#125;test(); _NAMESPACE_ 1234&lt;?php namespace MyProject;echo &#39;命名空间为：&quot;&#39;, __NAMESPACE__, &#39;&quot;&#39;; &#x2F;&#x2F; 输出 &quot;MyProject&quot; \\?&gt; PHP命名空间PHP 命名空间可以解决以下两类问题： 用户编写的代码与PHP内部的类/函数/常量或第三方类/函数/常量之间的名字冲突。 为很长的标识符名称(通常是为了缓解第一类问题而定义的)创建一个别名（或简短）的名称，提高 源代码的可读性 定义命名空间 默认情况下，所有常量、类和函数名都放在全局空间下，就和PHP支持命名空间之前一样。命名空间通过关键字namespace 来声明。如果一个文件中包含命名空间，它必须在其它所有代码之前 声明命名空间。语法格式如下: 123&lt; ?php &#x2F;&#x2F; 定义代码在 &#39;MyProject&#39; 命名空间中 namespace MyProject; &#x2F;&#x2F; ... 代码 ... 你也可以在同一个文件中定义不同的命名空间代码，如： 12345678&lt; ?php namespace MyProject1; &#x2F;&#x2F; MyProject1 命名空间中的PHP代码 namespace MyProject2; &#x2F;&#x2F; MyProject2 命名空间中的PHP代码 &#x2F;&#x2F; 另一种语法 namespace MyProject3 &#123; &#x2F;&#x2F; MyProject3 命名空间中的PHP代码 &#125; ?&gt; ps:不建议使用这种语法在单个文件中定义多个命名空间。建议使用下面的大括号形式的语法。 12345678910111213&lt;?phpnamespace MyProject &#123; const CONNECT_OK = 1; class Connection &#123; /* ... */ &#125; function connect() &#123; /* ... */ &#125;&#125;namespace AnotherProject &#123; const CONNECT_OK = 1; class Connection &#123; /* ... */ &#125; function connect() &#123; /* ... */ &#125;&#125;?&gt; 将全局的非命名空间中的代码与命名空间中的代码组合在一起，只能使用大括号形式的语法。全局代码必须用一个不带名称的 namespace 语句加上大括号括起来，例如： 1234567891011121314&lt;?phpnamespace MyProject &#123;const CONNECT_OK = 1;class Connection &#123; /* ... */ &#125;function connect() &#123; /* ... */ &#125;&#125;namespace &#123; // 全局代码session_start();$a = MyProject\\connect();echo MyProject\\Connection::start();&#125;?&gt; 在声明命名空间之前唯一合法的代码是用于定义源文件编码方式的 declare 语句。所有非 PHP 代码包 括空白符都不能出现在命名空间的声明之前. 12345678910111213141516171819202122232425262728&lt;?php declare(encoding='UTF-8'); //定义多个命名空间和不包含在命名空间中的代码namespace MyProject &#123; const CONNECT_OK = 1; class Connection &#123; /* ... */ &#125; function connect() &#123; /* ... */ &#125;&#125;namespace &#123; session_start(); $a = MyProject\\connect(); echo MyProject\\connect()::start();&#125;?&gt;&lt;!--F:\\Develop_PHP\\php-7.1.31-Win32-VC14-x64\\php.exe F:\\Develop_Apache_HttpServer\\httpd-2.4.39-win64-VC15\\Apache24\\htdocs\\PHP_Projects\\PrimarySyntax\\NameSpace\\NameSpace.phpPHP Warning: declare(encoding=...) ignored because Zend multibyte feature is turned off by settings in F:\\Develop_Apache_HttpServer\\httpd-2.4.39-win64-VC15\\Apache24\\htdocs\\PHP_Projects\\PrimarySyntax\\NameSpace\\NameSpace.php on line 1PHP Fatal error: Uncaught Error: Class name must be a valid object or a string in F:\\Develop_Apache_HttpServer\\httpd-2.4.39-win64-VC15\\Apache24\\htdocs\\PHP_Projects\\PrimarySyntax\\NameSpace\\NameSpace.php:16Stack trace:#0 &#123;main&#125; thrown in F:\\Develop_Apache_HttpServer\\httpd-2.4.39-win64-VC15\\Apache24\\htdocs\\PHP_Projects\\PrimarySyntax\\NameSpace\\NameSpace.php on line 16Process finished with exit code 255--&gt; 子命名空间 与目录和文件的关系很象，PHP 命名空间也允许指定层次化的命名空间的名称。因此，命名空间的名 字可以使用分层次的方式定义: 12345678910111213&lt;?phpnamespace MyProject\\Sub\\Level;&#x2F;&#x2F;声明分层次的单个命名空间const CONNECT_OK &#x3D; 1;class Connection&#123; &#x2F;* ... *&#x2F;&#125;function Connect()&#123; &#x2F;* ... *&#x2F;&#125;?&gt; 上面的例子创建了 常量 MyProject\\Sub\\Level\\CONNECT_OK， 类 MyProject\\Sub\\Level\\Connection 函数 MyProject\\Sub\\Level\\Connection。 命名空间使用 PHP 命名空间中的类名可以通过三种方式引用： 非限定名称，或不包含前缀的类名称，例如 $a=new foo(); 或 foo::staticmethod();。如果当前命名空间是 currentnamespace，foo 将被解析为 currentnamespace\\foo。如果使用 foo 的代码是全局的，不包含在任何命名空间中的代码，则 foo 会被解析为foo。 PS：如果命名空间中的函数或常量未定义，则该非限定的函数名称或常量名称会被解析为全局函数名称或常量名称。 限定名称,或包含前缀的名称，例如 $a = new subnamespace\\foo(); 或 subnamespace\\foo::staticmethod();。如果当前的命名空间是 currentnamespace，则 foo 会被解析为 currentnamespace\\subnamespace\\foo。如果使用 foo 的代码是全局的，不包含在任何命名空间中的代码，foo 会被解析为subnamespace\\foo。 完全限定名称，或包含了全局前缀操作符的名称，例如， $a = new \\currentnamespace\\foo(); 或 \\currentnamespace\\foo::staticmethod();。在这种情况下，foo 总是被解析为代码中的文字名(literal name)currentnamespace\\foo。 DEMO01 123456789&lt;?phpnamespace Foo\\Bar\\Subnamespace;const FOO=1;function foo()&#123;&#125;class foo&#123; static function staticmethod()&#123;&#125;&#125;?&gt; DEMO02 12345678910111213141516171819202122232425262728293031323334353637383940&lt;?phpnamespace Foo\\Bar;//命名空间为Foo\\Bar,位于Foo下include \"Demo01NameSpace.php\";//echo \"全局代码应包含在全局名称空间声明中\";const FOO=2;function Foo()&#123;&#125;class Foo&#123; static function staticmethod()&#123;&#125;&#125;/* 非限定名称 */foo();// 解析为 Foo\\Bar\\foo这个函数foo::staticmethod();// 解析为类 Foo\\Bar\\foo的静态方法staticmethod。echo FOO;// 解析为 Foo\\Bar\\ FOO这个常量/* 限定名称 */subnamespace\\foo();// 解析为函数 Foo\\Bar\\subnamespace\\foosubnamespace\\foo::staticmethod();// 解析为类 Foo\\Bar\\subnamespace\\foo,// 以及类的方法 staticmethodecho subnamespace\\FOO;/// 解析为常量 Foo\\Bar\\subnamespace\\FOO/* 完全限定名称 */\\Foo\\Bar\\foo();// 解析为函数 Foo\\Bar\\foo\\Foo\\Bar\\foo::staticmethod();// 解析为类 Foo\\Bar\\foo, 以及类的方法 staticmethodecho \\Foo\\Bar\\FOO;// 解析为常量 Foo\\Bar\\FOO DEMO03 123456789&lt;?phpnamespace Foo;//命名空间为Foofunction strlen() &#123;&#125;const INI_ALL = 3;class Exception &#123;&#125;$a = \\strlen('hi'); // 调用全局函数strlen$b = \\INI_ALL; // 访问全局常量 INI_ALL$c = new \\Exception('error'); // 实例化全局类 Exception :orange: PS:不就是路径访问的结构,具体怎么实现不知道 命名空间和动态语言特征 PHP 命名空间的实现受到其语言自身的动态特征的影响。因此，如果要将下面的代码转换到命名空间中，动态访问元素。 DEMO01 1234567891011121314151617&lt;?phpclass cname&#123; function __construct() &#123; echo __METHOD__,\"\\n\";//输出方法名:__construct &#125;&#125;function fname()&#123; echo __FUNCTION__,\"\\n\";//输出方法名:fname&#125;const conname=\"global\";//常量:conname$a='cname';$obj = new $a;//打印cname::__construct$b='fname';$b(); //打印fnameecho constant('conname'),\"\\n\";//打印conname 输出结果: 12cname::__construct fname global &#x2F;&#x2F;嗯结果打印了全局的结构类,方法,常量 必须使用完全限定名称（包括命名空间前缀的类名称）。注意因为在动态的类名称、函数名称或常量名称中，限定名称和完全限定名称没有区别，因此其前导的反斜杠是不必要的。 动态访问命名空间的元素 DEMO02 1234567891011121314151617181920212223242526272829303132333435&lt;?phpnamespace namespacename;class cname&#123; function __construct() &#123; echo __METHOD__,\"\\n\"; &#125;&#125;function fname()&#123; echo __FUNCTION__,\"\\n\";&#125;const constname = \"global\";include 'Demo04NameSpace&amp;Dynamic.php';$a = 'cname';$obj = new $a; // prints classname::__construct$b = 'fname';$b(); // prints funcnameecho constant('constname'), \"\\n\"; // prints global//echo constant(\"namespacename\\constname\"),\"\\n\";/* note that if using double quotes, \"\\\\namespacename\\\\classname\" must be used */$a = '\\namespacename\\cname';$obj = new $a; // prints namespacename\\classname::__construct$a = 'namespacename\\cname';$obj = new $a; // also prints namespacename\\classname::__construct$b = 'namespacename\\fname';$b(); // prints namespacename\\funcname$b = '\\namespacename\\fname';$b(); // also prints namespacename\\funcnameecho constant('\\namespacename\\constname'), \"\\n\"; // prints namespacedecho constant('namespacename\\constname'), \"\\n\"; // also prints namespaced?&gt; 输出结果: 1error:Couldn&#39;t find constant constname :orange: PS:这这讲的不是一个问题吗 namespace关键字和__NAMESPACE__常量 PHP static 关键词通常，当函数完成/执行后，会删除所有变量。不过，有时我需要不删除某个局部变量。实现这一点需要首次声明变量时使用 static 关键词。 123456789101112131415&lt;?phpfunction myTest() &#123; static $x=0; echo $x; $x++;&#125;myTest();myTest();myTest();?&gt; 然后，每当函数被调用时，这个变量所存储的信息都是函数最后一次被调用时所包含的信息。 注释：该变量仍然是函数的局部变量。 PHP数据类型PHP是一种松散型语言，不用告知类型，自动数据类型。 字符串、整数、浮点数、逻辑、数组、对象、NULL。 字符串可以是引号内的任何文本。您可以使用单引号或双引号。 整数是没有小数的数字。 整数规则： 整数必须有至少一个数字（0-9）整数不能包含逗号或空格整数不能有小数点整数正负均可可以用三种格式规定整数：十进制、十六进制（前缀是 0x）或八进制（前缀是 0） PHP var_dump() 会返回变量的数据类型和值。 1234567891011121314151617181920212223&lt;?php$x=5985;var_dump($x);echo(\"&lt;br&gt;\");$x=-345;var_dump($x);echo(\"&lt;br&gt;\");$x=0x8C;var_dump($x);echo(\"&lt;br&gt;\");$x=047;var_dump($x);echo(\"&lt;br&gt;\");?&gt;结果：int(5985)int(-345)int(140)int(39) 浮点数是有小数点或指数形式的数字。 1234567891011121314151617&lt;?php$x=10.365;var_dump($x);echo(\"&lt;br&gt;\");$x=2.4e3;var_dump($x);echo(\"&lt;br&gt;\");$x=8E-5;var_dump($x);echo(\"&lt;br&gt;\");?&gt;结果： float(10.365)float(2400)float(8.0E-5) 逻辑是 true 或 false。 数组在一个变量中存储多个值。 123456&lt;?php$cars=array(\"volvo\",\"bwm\",\"saab\");var_dump($cars);?&gt;结果：array(3) &#123; [0]=&gt; string(5) \"volvo\" [1]=&gt; string(3) \"bwm\" [2]=&gt; string(4) \"saab\" &#125; 创建数组 在 PHP 中， array() 函数用于创建数组： 1array(); 在 PHP 中，有三种数组类型： 索引数组 - 带有数字索引的数组 有两种创建索引数组的方法： 索引是自动分配的（索引从 0 开始）： 1$cars=array(\"Volvo\",\"BMW\",\"SAAB\"); 手动分配索引 123$cars[0]=\"Volvo\";$cars[1]=\"BMW\";$cars[2]=\"SAAB\"; 关联数组 - 带有指定键的数组 关联数组是使用您分配给数组的指定键的数组。 有两种创建关联数组的方法： 1$age=array(\"Peter\"=&gt;\"35\",\"Ben\"=&gt;\"37\",\"Joe\"=&gt;\"43\"); 123$age['Peter']=\"35\";$age['Ben']=\"37\";$age['Joe']=\"43\"; 多维数组 - 包含一个或多个数组的数组 数组的方法 获得数组的长度 - count() 函数 1234&lt;?php$cars=array(\"Volvo\",\"BMW\",\"SAAB\");echo count($cars);?&gt; PHP - 数组的排序函数 sort() - 以升序对数组排序rsort() - 以降序对数组排序asort() - 根据值，以升序对关联数组进行排序ksort() - 根据键，以升序对关联数组进行排序arsort() - 根据值，以降序对关联数组进行排序krsort() - 根据键，以降序对关联数组进行排序 遍历一般数组 12345678&gt;&lt;?php$cars = array('volvo' ,'bmw','saab' );$arraylenth=count($cars);for ($i=0; $i &lt;$arraylenth ; $i++) &#123; echo $cars[$i]; echo \"&lt;br&gt;\";&#125;?&gt; 遍历关联数组 12345678&gt;&lt;?php$age=array(\"Bill\"=&gt;\"35\",\"Steve\"=&gt;\"37\",\"Peter\"=&gt;\"43\");foreach($age as $x=&gt;$x_value) &#123;echo \"Key=\" . $x . \", Value=\" . $x_value;echo \"&lt;br&gt;\";&#125;?&gt; 对象是存储数据和有关如何处理数据的信息的数据类型。 在 PHP 中，必须明确地声明对象。 首先我们必须声明对象的类。对此，我们使用 class 关键词。类是包含属性和方法的结构。 然后我们在对象类中定义数据类型，然后在该类的实例中使用此数据类型： 123456789101112&gt;&lt;?phpclass car&#123; var $color; function car($color=\"green\")&#123; $this-&gt;color=$color; &#125; function what_color()&#123; return $this-&gt;color; &#125;&#125;?&gt; 特殊的 NULL 值表示变量无值。NULL 是数据类型 NULL 唯一可能的值。 NULL 值标示变量是否为空。也用于区分空字符串与空值数据库。 可以通过把值设置为 NULL，将变量清空： PHP的输出方法 echo 和 print 之间的差异： echo - 能够输出一个以上的字符串print - 只能输出一个字符串，并始终返回 1 提示：echo 比 print 稍快，因为它不返回任何值。 echo 是一个语言结构，有无括号均可使用：echo 或 echo()。 print 也是语言结构，有无括号均可使用：print 或 print()。 显示字符串 123456&lt;?phpecho \"&lt;h2&gt;PHP is fun!&lt;/h2&gt;\";echo \"Hello world!&lt;br&gt;\";echo \"I'm about to learn PHP!&lt;br&gt;\";echo \"This\", \" string\", \" was\", \" made\", \" with multiple parameters.\";?&gt; 12345&lt;?phpprint &quot;&lt;h2&gt;PHP is fun!&lt;&#x2F;h2&gt;&quot;;print &quot;Hello world!&lt;br&gt;&quot;;print &quot;I&#39;m about to learn PHP!&quot;;?&gt; 显示变量 1234567891011&lt;?php$txt1=\"learn php\";$txt2=\"w3school.com.cn\";$cars=array(\"volvo\",\"bwm\",\"saab\");echo $txt1;echo \"&lt;br&gt;\";echo \"study php at $txt2\";echo \"&lt;br&gt;\";echo \"my car is a &#123;$cars[0]&#125;\";?&gt; PHP常用函数字符串函数 strlen()字符串长度 123&lt;?phpecho strlen(\"hello world\");?&gt; strpos() 函数用于检索字符串内指定的字符或文本。 如果找到匹配，则会返回首个匹配的字符位置。如果未找到匹配，则将返回 FALSE。 1234&lt;?phpecho strpos(\"hello world\", \"world\");?&gt;结果：6 PHP 常量 常量是单个值的标识符（名称）。在脚本中无法改变该值。 有效的常量名以字符或下划线开头（常量名称前面没有 $ 符号）。 注释：与变量不同，常量贯穿整个脚本是自动全局的。 设置 PHP 常量如需设置常量，请使用 define() 函数 - 它使用三个参数： 首个参数定义常量的名称 第二个参数定义常量的值 可选的第三个参数规定常量名是否对大小写敏感。默认是 false。 1234&lt;?phpdefine('greeting', 'welcome to w3cschool.com.cn');echo(greeting);?&gt; 1234&lt;?phpdefine('greeting', 'welcome to w3cschool.com.cn',true);echo(GREETING);?&gt; PHP运算符 PHP 算数运算符——+-*/% PHP 赋值运算符——略 PHP 字符串运算符 . 串接 .= 串接赋值 1234567&lt;?php$a=\"hello\";$b=$a.\" world!\";echo($b.\"&lt;br&gt;\");$a.=\"world!!!\";echo($a);?&gt; PHP 递增/递减运算符 ++$x 前递增 $x 加一递增，然后返回 $x$x++ 后递增 返回 $x，然后 $x 加一递增–$x 前递减 $x 减一递减，然后返回 $x$x– 后递减 返回 $x，然后 $x 减一递减 1234567891011121314&lt;?php$x=10; echo ++$x; // 输出 11$y=10; echo $y++; // 输出 10$z=5;echo --$z; // 输出 4$i=5;echo $i--; // 输出 5?&gt; PHP 比较运算符 12345678910&lt;?php$x&#x3D;10; $y&#x3D;&#39;10&#39;; echo(&quot;&#x3D;&#x3D;&quot;);var_dump($x&#x3D;&#x3D;$y);echo(&quot;&lt;br&gt;&quot;.&quot;&#x3D;&#x3D;&#x3D;&quot;);var_dump($x&#x3D;&#x3D;&#x3D;$y);?&gt; PHP 逻辑运算符 PHP 数组运算符 123456789101112131415161718192021222324252627282930313233&lt;?php$x = array('a' =&gt;\"red\" ,\"b\"=&gt;\"green\");$y = array('c' =&gt;\"blue\" ,\"d\"=&gt;\"yellow\");$a = array('a' =&gt; \"orange\", \"f\"=&gt;\"pink\");$b = array('e' =&gt; \"red\", \"f\"=&gt;\"pink\");$z=$x+$y;$c=$x+$a;$d=$x+$b;var_dump($z);echo(\"&lt;br&gt;\");var_dump($c);echo(\"&lt;br&gt;\");var_dump($d);echo(\"&lt;br&gt;\");var_dump($x==$y);echo(\"&lt;br&gt;\");var_dump($x===$y);echo(\"&lt;br&gt;\");var_dump($x!=$y);echo(\"&lt;br&gt;\");var_dump($x&lt;&gt;$y);echo(\"&lt;br&gt;\");var_dump($x!==$y);?&gt; 结果：array(4) &#123; [\"a\"]=&gt; string(3) \"red\" [\"b\"]=&gt; string(5) \"green\" [\"c\"]=&gt; string(4) \"blue\" [\"d\"]=&gt; string(6) \"yellow\" &#125;array(3) &#123; [\"a\"]=&gt; string(3) \"red\" [\"b\"]=&gt; string(5) \"green\" [\"f\"]=&gt; string(4) \"pink\" &#125;array(4) &#123; [\"a\"]=&gt; string(3) \"red\" [\"b\"]=&gt; string(5) \"green\" [\"e\"]=&gt; string(3) \"red\" [\"f\"]=&gt; string(4) \"pink\" &#125;bool(false)bool(false)bool(true)bool(true)bool(true) PHP 条件语句 PHP if else 语句 PHP Switch 语句 语法 12345678910111213switch (expression)&#123;case label1: code to be executed if expression = label1; break; case label2: code to be executed if expression = label2; break;default: code to be executed if expression is different from both label1 and label2;&#125; 工作原理 对表达式（通常是变量）进行一次计算 把表达式的值与结构中 case 的值进行比较 如果存在匹配，则执行与 case 关联的代码 代码执行后，break 语句阻止代码跳入下一个 case 中继续执行 如果没有 case 为真，则使用 default 语句 PHP while 循环 while - 只要指定条件为真，则循环代码块do…while - 先执行一次代码块，然后只要指定条件为真则重复循环for - 循环代码块指定次数foreach - 遍历数组中的每个元素并循环代码块 注： 语法 123foreach ($array as $value) &#123; code to be executed;&#125; 每进行一次循环迭代，当前数组元素的值就会被赋值给 $value 变量，并且数组指针会逐一地移动，直到到达最后一个数组元素。 123456&lt;?php$colors = array('red','green','blue','yellow' );foreach ($colors as $value) &#123; echo \"$value&lt;br&gt;\";&#125;?&gt; PHP函数 注: PHP 默认参数值 下面的例子展示了如何使用默认参数。如果我们调用没有参数的 setHeight() 函数，它的参数会取默认值： 12345678&lt;?phpfunction setHeight($mineheight=50)&#123; echo \"the height is:$mineheight&lt;br&gt;\";&#125; setHeight(350);setHeight();?&gt;","categories":[{"name":"Geek","slug":"Geek","permalink":"https://casuor.top/categories/Geek/"}],"tags":[]},{"title":"Node.js Usages-01","slug":"geek_Nodejsuse01","date":"2019-04-19T16:00:00.000Z","updated":"2020-10-28T09:58:54.880Z","comments":true,"path":"2019/04/20/geek_Nodejsuse01/","link":"","permalink":"https://casuor.top/2019/04/20/geek_Nodejsuse01/","excerpt":"","text":"安装NVM Node管理Nvm-windos 常用命令 nvm install node problem: The process cannot access the file because it is being used by another process. 方案1： 淘宝镜像 nvm node_mirror https://npm.taobao.org/mirrors/node/ nvm npm_mirror https://npm.taobao.org/mirrors/npm/ 方案2： 直接下载个exe安装到nvm所指定的路径名称改为(LTS版本：’v12.13.1’) 预览: 配置npm配置#查看配置信息 npm config ls #修改全局Node moudle位置 初始位置： prefix = &quot;C:\\\\Users\\\\16877\\\\AppData\\\\Roaming\\\\npm&quot; cache = &quot;C:\\\\Users\\\\16877\\\\AppData\\\\Roaming\\\\npm-cache&quot; 修改： npm config set prefix &quot;F:\\Develop_Node.js\\Gobal_Npm_Module&quot; npm config set cache &quot;F:\\Develop_Node.js\\Gobal_Npm_Cache&quot; #修改Npm cache位置PS:其他也可以设置 使用cnpmnpm install -g cnpm --registry=https://registry.npm.taobao.org #此外需添加环境变量 cnpm -vPS:诸多网速问题，使用cnpm比较好 类似问题解决方案： cnpm install or npm install #使用npm卡住需在.npmrc文件添加（使用 npm config ls可以找到这一项） registry=https://registry.npm.taobao.org #install.js 卡住也是此类问题，同样设置依赖镜像地址 #如install electron: electron_mirror=&quot;https://npm.taobao.org/mirrors/electron/&quot;PS:install.js文件中有electron_mirror这一项，使用cnpm没问题 nrm—切换npm源 nrm 是一个 NPM 源管理器，允许你快速地在如下 NPM 源间切换： 1.安装 npm install -g nrm2.使用 #列出可选的源 nrm ls #查看所有或指定测试源响应时间 nrm test [name] #切换指定源 nrm use &lt;name&gt;","categories":[{"name":"Geek","slug":"Geek","permalink":"https://casuor.top/categories/Geek/"}],"tags":[]},{"title":"数据结构 Notes","slug":"geek数据结构","date":"2019-03-24T16:00:00.000Z","updated":"2020-10-28T09:58:54.887Z","comments":true,"path":"2019/03/25/geek数据结构/","link":"","permalink":"https://casuor.top/2019/03/25/geek%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/","excerpt":"","text":"1、按值得不同类型数据类型分为： 1.非结构的原子类型：不可分解 原子类型： 2.结构类型：可分解，如数组 固定聚合类型：确定数目的数据由某种结构组成 可变聚合类型：数目不确定 2、从硬件角度： 数据类型实现了某种信息的屏蔽 抽象数据类型： abstract data type:一种数学模型以及定义在该模型上的一组操作 抽象数据类型的定义仅仅取决于他的一组逻辑特性，而与其在计算机内如何表示和实现无关，即不论其内部结构如何变化，只要他的数学特性不变，都不影响其外部使用。 抽象数据类型和数据类型实质上是一个概念","categories":[{"name":"Geek","slug":"Geek","permalink":"https://casuor.top/categories/Geek/"}],"tags":[]},{"title":"算法导论札记","slug":"geek_算法导论","date":"2019-02-24T16:00:00.000Z","updated":"2020-10-28T09:58:54.887Z","comments":true,"path":"2019/02/25/geek_算法导论/","link":"","permalink":"https://casuor.top/2019/02/25/geek_%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/","excerpt":"","text":"1)插入排序c1nn2）归并排序c2nlgn 算法分析：–运行时间来说，c1&lt;c2插入排序有一个因子n的地方，归并排序有一个因子lgn,后者小于前者，对于小的输入规模，插入排序比归并排序要快，但是一旦输入规模n变得足够大，归并排序lgn对n的优点将足以补偿常数因子的差别不管c1比c2小多少，总会存在一个交叉点，超出这个点，归并排序更快。 结论：问题规模的增大，归并排序的优势也会增大 ————习题——————–1、给出应用曾需要算法内容的的应用的一个例子。2、相同机器上实现插入排序和归并排序，对于规模为n的输入，插入排序运行8n平方步而归并排序运行64nlgn步，那么对于那些n值插入排序优于归并排序？3、n的最小值为多少时，运行时间为100n平方的一个算法算法在相同机器上快于运行时间为2的n次方的另有一个算法？ ———-归并排序之分治策略———-分解:解决:合并： ——-求解递归式的方法————代入法：猜测一个界，然后用数学归纳法证明这个界是正确的。 递归树法：将递归式转换为一颗树，其节点表示不同层次的递归调用产生的代价。然后采用边界和技术来求解递归式。主方法：解T(n)=aT(n/b)+f(n) ———-最大子数组问题—————- P24股票低价买入，高价出。即达到最大收益。1）暴力求解法简单的尝试每对可能买进和卖出日期组合，只要卖出日期在买入日期之前即可。N天中有N/2种日期组合。因为N/2=O(n^2),而处理每对日期所花费的时间至少也是常量，因此，这种方法的运行时间为C(n^2).2)问题转换：目的：寻找一段时间，使得从第一天到最后一天的股票价格净变值最大。因此，我们不再从每日价格的角度去看待数据而是考虑每日价格变化，第i天的价格变化定义为第i天和第i-1天的价格差，那么得到一个关于价格变化的数组A，那么问题就转化为寻找A的和最大的非空连续子数组。这样的连续子数组称为最大子数组。","categories":[{"name":"Geek","slug":"Geek","permalink":"https://casuor.top/categories/Geek/"}],"tags":[]},{"title":"python小记(未完)","slug":"geek_python 小记","date":"2019-01-05T16:00:00.000Z","updated":"2020-10-28T09:58:54.885Z","comments":true,"path":"2019/01/06/geek_python 小记/","link":"","permalink":"https://casuor.top/2019/01/06/geek_python%20%E5%B0%8F%E8%AE%B0/","excerpt":"","text":"python 小记查看python路径12345Pythonimport sysprint(sys.path) 设置pip源C:\\Users\\16877\\pip\\pip.ini 12345[global]index-url = http://mirrors.aliyun.com/pypi/simple [install]trusted-host=mirrors.aliyun.com GithubRich is a Python library for rich text and beautiful formatting in the terminal. Anaconda configAnaconda Installer Anaconda修改国内镜像源 1234567conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/conda config --set show_channel_urls yescd ~lscode .\\.condarc 123channels: - https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;anaconda&#x2F;pkgs&#x2F;free&#x2F;show_channel_urls: true 1conda info Anaconda Usuages 12","categories":[{"name":"Geek","slug":"Geek","permalink":"https://casuor.top/categories/Geek/"}],"tags":[]},{"title":"BaiduCloud Picbed","slug":"geek_baiduPicbed","date":"2018-08-24T16:00:00.000Z","updated":"2020-10-28T09:58:54.881Z","comments":true,"path":"2018/08/25/geek_baiduPicbed/","link":"","permalink":"https://casuor.top/2018/08/25/geek_baiduPicbed/","excerpt":"","text":"百度下载图片链：https://image.baidu.com/search/down?tn=download&amp;url=巴拉巴拉.jpg 抓接口 首先我们打开百度识图的首页，按 F12 呼出浏览器开发者工具，切换到 Netnork 选项卡。因为百度识图在上传完图片后会立即进行跳转，因此还需勾选 Preserve log 用以保留跳转前的数据。 准备就绪后点击 识图一下 &gt; 本地上传，随意上传一张图片，这时浏览器 Netnork 里会列出在此期间产生的所有网络请求。我们可以点击工具栏里的 XHR，用以筛选出数据交互请求。(注：有时用 XHR也可能会过滤掉我们需要的数据，因此如果在 XHR 中找不到的时候，可以切回 ALL 里一个个找) 清空log,Ctrl+R刷新 通过缩略图发现 得到： Request URL: http://g.hiphotos.baidu.com/image/pic/item/37d12f2eb9389b5021eedd048b35e5dde7116e56.jpg 在筛选后的数据请求里，有个名称为 a_upload?fr=html5&amp;target=pcSearchImage&amp;needJson=true的请求很是可疑，因此点开查看请求详情。 可以看到，本地的图片果然是通过这个接口进行上传的。上传表单的文件 name 为 “file”。接口地址如下： http://image.baidu.com/pcdutu/a_upload?fr=html5&amp;target=pcSearchImage&amp;needJson=true 访问结果： 1&#123;\"errno\":-1,\"msg\":\"no file\",\"type\":\"img-upload\"&#125; 解析：错误； 错误问题：nofile; 类型：上传文件 至此，我们成功抓取到了百度识图的图片上传接口，接下来可以正式搞事情了 看来，接口没问题 写代码用代码实现很容易，就一个简单的 CURL 上传文件，这里直接给出完整版的代码了，收好！ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;?php/** * 上传图片到百度识图接口，获取图片外链 * * @param $file 图片文件 * @return 图片链接(上传成功) NULL(上传失败) * @copyright (c) mengkun(https://mkblog.cn/1619/) */function uploadToBaidu($file) &#123; // API 接口地址 $url = 'http://image.baidu.com/pcdutu/a_upload?fr=html5&amp;target=pcSearchImage&amp;needJson=true'; // 文件不存在 if(!file_exists($file)) return ''; // POST 文件 if (class_exists('CURLFile')) &#123; // php 5.5 $post['file'] = new CURLFile(realpath($file)); &#125; else &#123; $post['file'] = '@'.realpath($file); &#125; // CURL 模拟提交 $ch = curl_init(); curl_setopt($ch, CURLOPT_URL , $url); curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1); curl_setopt($ch, CURLOPT_POST, 1); curl_setopt($ch, CURLOPT_POSTFIELDS, $post); $output = curl_exec($ch); curl_close($ch); // 返回结果为空（上传失败） if($output == '') return ''; // 解析数据 $output = json_decode($output, true); if(isset($output['url']) &amp;&amp; $output['url'] != '') &#123; return $output['url']; &#125; return '';&#125;// 使用示例：$url = uploadToBaidu('1.jpg');echo $url;","categories":[{"name":"Geek","slug":"Geek","permalink":"https://casuor.top/categories/Geek/"}],"tags":[]},{"title":"数据结构与算法之美 Notes","slug":"geek_数据结构与算法之美-王争","date":"2018-08-22T16:00:00.000Z","updated":"2020-10-28T09:58:54.886Z","comments":true,"path":"2018/08/23/geek_数据结构与算法之美-王争/","link":"","permalink":"https://casuor.top/2018/08/23/geek_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E-%E7%8E%8B%E4%BA%89/","excerpt":"","text":"数据结构与算法之美-王争推动算法传播的是生活在美索不达米亚的AI Khwarizmi 于9世纪一本以阿拉姆语著述的教科书。 一、目标什么是数据结构？什么是算法？ 从广义上讲，数据结构就是指一组数据的存储结构。算法就是操作数据的一组方法。 从狭义上讲，也就是我们专栏要讲的，是指某些著名的数据结构和算法，比如队列、栈、堆、二分查找、动态规划等。这些都是前人智慧的结晶，我们可以直接拿来用。 数据结构与算法的关系？ 这是因为，数据结构和算法是相辅相成的。数据结构是为算法服务的，算法要作用在特定的数据结构之上。 因此，我们无法孤立数据结构来讲算法，也无法孤立算法来讲数据结构。 比如，因为数组具有随机访问的特点，常用的二分查找算法需要用数组来存储数据。但如果我们选择链表这种数据结构，二分查找算法就无法工作了，因为链表并不支持随机访问。 数据结构是静态的，它只是组织数据的一种方式。如果不在它的基础上操作、构建算法，孤立存在的数据结构就是没用的。 学习的重点？ 复杂度分析 数据结构和算法解决的是如何更省、更快地存储和处理数据的问题，因此，我们就需要一个考量效率和 资源消耗的方法，这就是复杂度分析方法。所以，只掌握了数据结构和算法的特点、用法，但是没有学 会复杂度分析，那就相当于只知道操作口诀，而没掌握心法。只有把心法了然于胸，才能做到无招胜有招！ 常用的，基础的数据结构与算法 10 个数据结构： 数组、链表、栈、队列、散列表、二叉树、堆、跳表、图、 Trie 树； 10个算法： 递归、排序、二分查找、搜索、哈希算法、贪心算法、分治算法、回溯算法、动态规划、字符串匹配算法。 二、算法复杂度分析如何分析、统计算法的执行效率和资源消耗？ 时间、空间复杂度分析。为什么需要复杂度分析？ 你可能会有些疑惑，我把代码跑一遍，通过统计、监控，就能得到算法执行的时间和占用的内存大小。为什么还要做时间、空间复杂度分析呢？这种分析方法能比我实实在在跑一遍得到的数据更准确吗？首先，我可以肯定地说，你这种评估算法执行效率的方法是正确的。很多数据结构和算法书籍还给这种方法起了一个名字，叫事后统计法。但是，这种统计方法有非常大的局限性。 1.测试结果非常依赖测试环境。 2.测试结果受数据规模影响很大 3.大O复杂度表示法 int cal(int n) { int sum = 0; int i = 1; for (; i &lt;= n; ++i) { sum = sum + i; } return sum; } 从 CPU 的角度来看，这段代码的每一行都执行着类似的操作：读数据 - 运算 - 写数据。尽管每行代码对应的 CPU 执行的个数、执行的时间都不一样，但是，我们这里只是粗略估计，所以可以假设每行代码执行的时间都一样，为 unit_time 。在这个假设的基础之上，这段代码的总执行时间是多少呢？第 2 、 3 行代码分别需要 1 个 unit_time 的执行时间，第 4 、 5 行都运行了 n 遍，所以需要2nunit_time 的执行时间，所以这段代码总的执行时间就是 (2n+2)*unit_time 。可以看出来，所有代码的执行时间 T(n) 与每行代码的执行次数成正比。 按照这个分析思路，我们再来看这段代码。 int cal(int n) { int sum = 0; int i = 1; int j = 1; for (; i &lt;= n; ++i) { j = 1; for (; j &lt;= n; ++j) { sum = sum + i * j; } } } 我们依旧假设每个语句的执行时间是 unit_time 。那这段代码的总执行时间 T(n) 是多少呢？第 2 、 3 、 4 行代码，每行都需要 1 个 unit_time 的执行时间，第 5 、 6 行代码循环执行了 n 遍，需要 2n * unit_time的执行时间，第7,8行执行了n^2遍，所以需要2n^2*unit_time的执行时间。所以整段代码执行时间 T(n)=(2n^2+2n+3)*unit_time. 尽管我们不知道 unit_time 的具体值，但是通过这两段代码执行时间的推导过程，我们可以得到一个非常重要的规律，那就是，所有代码的执行时间 T(n) 与每行代码的执行次数 n 成正比。我们可以把这个规律总结成一个公式。 大O记号 其中， T(n)表示代码执行的时间； n 表示数据规模的大小； f(n) 表示每行代码执行的次数总和。因为这是一个公式，所以用 f(n) 来表示。公式中的O ，表示代码的执行时间 T(n) 与 f(n) 表达式成正比。所以，第一个例子中的 T(n) = O(2n+2) ，第二个例子中的 T(n) = O(2n +2n+3) 。 这就是大 O 时间复杂度表示法。 大 O 时间复杂度实际上并不具体表示代码真正的执行时间，而是表示代码执行时间随数据规模增长的变化趋势，所以，也叫作渐进时间复杂度（ asymptotic time complexity ），简称时间复杂度。当 n 很大时，你可以把它想象成 10000 、 100000 。而公式中的低阶、常量、系数三部分并不左右增长趋势，所以都可以忽略。我们只需要记录一个最大量级就可以了，如果用大 O 表示法表示刚讲的那两段代码的时间复杂度，就可以记为： T(n) = O(n) ； T(n) = O(n ) 。 时间复杂度分析如何分析一段代码的时间复杂度？有三个比较实用的方法。 只关注循环执行次数最多的一段代码大 O 这种复杂度表示方法只是表示一种变化趋势。我们通常会忽略掉公式中的常量、低阶、系数，只需要记录一个最大阶的量级就可以了。所以，我们在分析一个算法、一段代码的时间复杂度的时候，也只关注循环执行次数最多的那一段代码就可以了。这段核心代码执行次数的 n的量级，就是整段要分析代码的时间复杂度。 那前面的第一个例子来说，其中第 2 、 3 行代码都是常量级的执行时间，与 n 的大小无关，所以对于复杂度并没有影响。循环执行次数最多的是第 4 、 5 行代码，所以这块代码要重点分析。前面我们也讲过，这两行代码被执行了 n 次，所以总的时间复杂度就是 O(n) 加法法则：总复杂度等于量级最大的那段代码的复杂度 //前100个数相加 int cal(int n) { int sum_1 = 0; int p = 1; for (; p &lt; 100; ++p) { sum_1 = sum_1 + p; } //前n个数 int sum_2 = 0; int q = 1; for (; q &lt; n; ++q) { sum_2 = sum_2 + q; } // int sum_3 = 0; int i = 1; int j = 1; for (; i &lt;= n; ++i) { j = 1; for (; j &lt;= n; ++j) { sum_3 = sum_3 + i * j; } } return sum_1 + sum_2 + sum_3; } 这个代码分为三部分，分别是求 sum_1 、 sum_2 、 sum_3 。我们可以分别分析每一部分的时间复杂度，然后把它们放到一块儿，再取一个量级最大的作为整段代码的复杂度。 第一段的时间复杂度是多少呢？这段代码循环执行了 100 次，所以是一个常量的执行时间，跟 n 的规模无关。这里我要再强调一下，即便这段代码循环 10000 次、 100000 次，只要是一个已知的数，跟 n 无关，照样也是常量级的执行时间。当 n 无限大的时候，就可以忽略。尽管对代码的执行时间会有很大影响，但是回到时间复杂度的概念来说，它表示的是一个算法执行效率与数据规模增长的变化趋势，所以不管常量的执行时间多大，我们都可以忽略掉。因为它本身对增长趋势并没有影响。那第二段代码和第三段代码的时间复杂度是多少呢？答案是 O(n) 和 O(n )。 综合三段代码的时间复杂度，我们取最大的量级，即总的复杂度为O(n^2) 也就是说：总的时间复杂度就等于量级最大的那段代码的时间复杂度。那我们将这个规律抽象成公式就是：如果 T1(n)=O(f(n)) ， T2(n)=O(g(n)) ；那么 T(n)=T1(n)+T2(n)=max(O(f(n)), O(g(n))) =O(max(f(n),g(n))). 3.乘法法则：嵌套代码的复杂度等于嵌套内外复杂度的乘积。 如果T1(n)=O(f(n)），T2(n)=O(g(n))； 那么T（n）=T1（n）xT2（n）=O(f(n))xO(g(n))=O(f(n)xg(n)).也就是说，假设T1（n）=O（n），T2（n）=O（n^2），则T1（n）xT2（n）=O（n^3）。 落实到具体的代码上 int cal(int n) { int ret = 0; int i = 1; for (; i &lt; n; ++i) { ret = ret + f(i); } } int f(int n) { int sum = 0; int i = 1; for (; i &lt; n; ++i) { sum = sum + i; } return sum; }我们单独看cal（）函数。假设f()只是一个普通的操作，那第4~6行的时间复杂度就是，T1(n)=O(n)。 但f()函数本身不是一个简单的操作，它的时间复杂度是T2(n)=O(n)，所以，整个cal）函数的时间复杂度就是，T(n)=T1(n)xT2(n)=O(nxn)=O（n2）。 常见的时间复杂度实例分析 分类： 多项式量级： 非多项式量级：O(2n)和O(n!)。 我们把复杂度为非多项式量级的算法问题叫做NP(Non-Deterministic Polynomial,非确定多项式)问题。 当数据规模n越来越大时，非多项式量级算法的执行时间会急剧增加，求解问题的执行时间会无限增长。所以，非多项式时间复杂度的算法其实是非常低效的算法。因此，关于NP时间复杂度问题略。 主要来看几种常见的多项式时间复杂度。 1.O(1) 常量级时间复杂度的一种表示方法，并不是指执行了一行代码。比如这段代码，即便有 3 行，它的时间复杂度也是 O(1 ），而不是 O(3) 。 int i = 8; int j = 6; int sum = i + j;由此，只要代码的执行时间不随 n 的增大而增长，这样代码的时间复杂度我们都记作O(1) 。或者说，一般情况下，只要算法中不存在循环语句、递归语句，即使有成千上万行的代码，其时间复杂度也是 Ο(1)。 2.O(logn),O(nlogn) i=1; while (i &lt;= n) { i = i * 2; }根据我们前面讲的复杂度分析方法，第三行代码是循环执行次数最多的。所以，我们只要能计算出这行代码被执行了多少次，就能知道整段代码的时间复杂度。从代码中可以看出，变量 i 的值从 1 开始取，每循环一次就乘以 2 。当大于 n 时，循环结束。还记得我们高中学过的等比数列吗？实际上，变量 i 的取值就是一个等比数列。如果我把它一个一个列出来，就应该是这个样子的： 所以，我们只要知道 x 值是多少，就知道这行代码执行的次数了。通过 2^x=n,则 x=log2n ，所以，这段代码的时间复杂度就是 O(log2n) 。现在，我把代码稍微改下，你再看看，这段代码的时间复杂度是多少？ i=1; while (i &lt;= n) { i = i * 3; }由上得出这段代码的复杂度为O(log3n) 。 实际上，不管是以 2 为底、以 3 为底，还是以 10 为底，我们可以把所有对数阶的时间复杂度都记为 O(logn)。 我们知道，对数之间是可以互相转换的，log3n就等于log32xlog2n，所以O(log3n)=O(Clog2n），其中C=log32是一个常量。基于我们前面的一个理论：*在采用大O标记复杂度的时候，可以忽略系数**，即O(Cf(n)=O(f(n))。所以，O（log2n）就等于O（log3n）。因此，在对数阶时间复杂度的表示方法里，我们忽略对数的“底”，统一表示为O（logn）。如果你理解了我前面讲的O（logn），那O（nlogn）就很容易理解了。还记得我们刚讲的乘法法则吗？如果一段代码的时间复杂度是O(logn)，我们循环执行n遍，时间复杂度就是O（nlogn）了。而且，O（nlogn）也是一种非常常见的算法时间复杂度。比如，归并排序、快速排序的时间复杂度都是O（nlogn）。 3.O(m+n),O(m*n) 这种情况代码的复杂度由两个数据的规模来决定。 int cal(int m, int n) { int sum_1 = 0; int i = 1; for (; i &lt; m; ++i) { sum_1 = sum_1 + i; } int sum_2 = 0; int j = 1; for (; j &lt; n; ++j) { sum_2 = sum_2 + j; } return sum_1 + sum_2; }从代码中可以看出， m 和 n 是表示两个数据规模。我们无法事先评估 m 和 n 谁的量级大，所以我们在表示复杂度的时候，就不能简单地利用加法法则，省略掉其中一个。所以，上面代码的时间复杂度就是 O(m+n) 。针对这种情况，原来的加法法则就不正确了，我们需要将加法规则改为： T1(m) + T2(n) = O(f(m) +g(n)) 。但是乘法法则继续有效： T1(m)*T2(n) = O(f(m) * f(n)) 。 空间复杂度分析 时间复杂度的全称是渐进时间复杂度，表示算法的执行时间与数据规模之间的增长关系。类比一下，空间复杂度全称就是渐进空间复杂度（ asymptotic space complexity ），表示算法的存储空间与数据规模之间的增长关系。 void print(int n) { int i = 0; int[] a = new int[n]; for (i; i &lt;n; ++i) { a[i] = i * i; } for (i = n-1; i &gt;= 0; --i) { print out a[i] } }跟时间复杂度分析一样，我们可以看到，第 2 行代码中，我们申请了一个空间存储变量 i ，但是它是常量阶的，跟数据规模 n 没有关系，所以我们可以忽略。第 3 行申请了一个大小为 n 的 int 类型数组，除此之外，剩下的代码都没有占用更多的空间，所以整段代码的空间复杂度就是 O(n)。 常见空间复杂度： O(1) 、 O(n)、 O(n^2) 小结： 复杂度也叫渐进复杂度，包括时间复杂度和空间复杂度，用来分析算法执行效率与数据规模之间的增长关系，可以粗略地表示，越高阶复杂度的算法，执行效率越低。 复杂度分析法则1 ）单段代码看高频：比如循环。2 ）多段代码取最大：比如一段代码中有单循环和多重循环，那么取多重循环的复杂度。3 ）嵌套代码求乘积：比如递归、多重循环等4 ）多个规模求加法：比如方法有两个参数控制两个循环的次数，那么这时就取二者复杂度相加。常用的复杂度级别？多项式阶：随着数据规模的增长，算法的执行时间和空间占用，按照多项式的比例增长。包括，O(1) （常数阶）、 O(logn) （对数阶）、 O(n) （线性阶）、 O(nlogn) （线性对数阶）、 O(n^2) （平方阶）、 O(n^3) （立方阶）非多项式阶：随着数据规模的增长，算法的执行时间和空间占用暴增，这类算法性能极差。包括，O(2^n) （指数阶）、 O(n!) 最好最坏及平均时间复杂度 // n 表示数组 array 的长度 int find(int[] array, int n, int x) { int i = 0; int pos = -1; for (; i &lt; n; ++i) { if (array[i] == x) pos = i; } return pos; }这段代码的功能是：长度为n的数组中，返回等于x的数组元素的下标，不等于则返回-1 缺点：全部元素遍历，不够高效 时间复杂度：O(n) // n 表示数组 array 的长度 int find(int[] array, int n, int x) { int i = 0; int pos = -1; for (; i &lt; n; ++i) { if (array[i] == x) { pos = i; break; } } return pos; }优化后时间复杂度则由x出现的位置决定。最好第一个元素，最差最后一个元素。 最好情况时间复杂度和最坏情况时间复杂度对应的都是极端情况下的代码复杂度，发生的概率其实并不大。为了更好地表示平均情况下的复杂度，需要引入另一个概念：平均情况时间复杂度，后面我简称为平均时间复杂度。 例： 要查找的变量 x 在数组中的位置，有 n+1 种情况：在数组的 0 ～ n-1 位置中和不在数组中。我们把每种情况下，查找需要遍历的元素个数累加起来，然后再除以 n+1 ，就可以得到需要遍历的元素个数的平均值， 即： 由大O记号表示可知，可以省略掉系数，低阶，常量，所以简化后的时间复杂度为O(n). 这个结论虽然是正确的，但是计算过程稍微有点儿问题。刚讲的这 n+1 种情况，出现的概率并不是一样的。我们知道，要查找的变量 x ，要么在数组里，要么就不在数组里。这两种情况对应的概率统计起来很麻烦，为了方便理解，我们假设在数组中与不在数组中的概率都为 1/2 。另外，要查找的数据出现在 0 ～ n-1 这 n 个位置的概率也是一样的，为 1/n 。所以，根据概率乘法法则，要查找的数据出现在 0 ～ n-1 中任意位置的概率就是 1/(2n). 因此，前面的推导过程中存在的最大问题就是，没有将各种情况发生的概率考虑进去。如果我们把每种情况发生的概率也考虑进去，那平均时间复杂度的计算过程就变成了这样： 这个值就是概率论中的加权平均值，也叫作期望值，所以平均时间复杂度的全称应该叫加权平均时间复杂度或者期望时间复杂度。引入概率之后，前面那段代码的加权平均值为 (3n+1)/4 。用大 O 表示法来表示，去掉系数和常量，这段代码的加权平均时间复杂度仍然是 O(n) 。 由上可得：不是所有情况都要进行最好，最糟或平均时间复杂度的分析，量级相差较大时才进行区别。 均摊时间复杂度 例子： // array 表示一个长度为 n 的数组 // 代码中的 array.length 就等于 n int[] array = new int[n]; int count = 0; void insert(int val) { if (count == array.length) { int sum = 0; for (int i = 0; i &lt; array.length; ++i) { sum = sum + array[i]; } array[0] = sum; count = 1; } array[count] = val; ++count; }代码功能： 往数组中插入数据的功能。 当数组满了之后，也就是代码中的 count == array.length 时，我们用 for 循环遍历数组求和，并清空数组，将求和之后的sum 值放到数组的第一个位置，然后再将新的数据插入。但如果数组一开始就有空闲空间，则直接将数据插入数组。最理想的情况下，数组中有空闲空间，我们只需要将数据插入到数组下标为 count 的位置就可以了，所以最好情况时间复杂度为 O(1) 。最坏的情况下，数组中没有空闲空间了，我们需要先做一次数组的遍历求和，然后再将数据插入，所以最坏情况时间复杂度为 O(n)。 平均复杂度分析： 假设数组的长度是 n ，根据数据插入的位置的不同，我们可以分为 n 种情况，每种情况的时间复杂度是 O(1) 。除此之外，还有一种 “ 额外 ” 的情况，就是在数组没有空闲空间时插入一个数据，这个时候的时间复杂度是 O(n) 。而且，这 n+1 种情况发生的概率一样，都是 1/(n+1) 。所以，根据加权平均的计算方法，我们求得的平均时间复杂度就是： 这个例子不需要引入概率论的知识。这是为什么呢？我们先来对比一下这个 insert() 的例子和前面那个 find() 的例子，你就会发现这两者有很大差别。首先， find() 函数在极端情况下，复杂度才为 O(1) 。但 insert() 在大部分情况下，时间复杂度都为O(1) 。只有个别情况下，复杂度才比较高，为 O(n) 。这是 insert() 第一个区别于 find() 的地方。第二个不同的地方，对于 insert() 函数来说， O(1) 时间复杂度的插入和 O(n) 时间复杂度的插入，出现的频率是非常有规律的，而且有一定的前后时序关系，一般都是一个 O(n) 插入之后，紧跟着 n-1 个 O(1) 的插入操作，循环往复。所以，针对这样一种特殊场景的复杂度分析，我们并不需要像之前讲平均复杂度分析方法那样，找出所有的输入情况及相应的发生概率，然后再计算加权平均值。 因此引入了摊还分析法，通过摊还分析得到的时间复杂度叫做均摊时间复杂度。 具体怎样使用摊还分析法分析算法的均摊时间复杂度？ 我们还是继续看在数组中插入数据的这个例子。每一次 O(n) 的插入操作，都会跟着 n-1 次 O(1) 的插入操作，所以把耗时多的那次操作均摊到接下来的 n-1 次耗时少的操作上，均摊下来，这一组连续的操作的均摊时间复杂度就是 O(1) 。这就是均摊分析的大致思路。均摊时间复杂度和摊还分析应用场景比较特殊，所以我们并不会经常用到。 应用场景 对一个数据结构进行一组连续操作中，大部分情况下时间复杂度都很低，只有个别情况下时间复杂度比较高，而且这些操作之间存在前后连贯的时序关系，这个时候，我们就可以将这一组操作放在一块儿分析，看是否能将较高时间复杂度那次操作的耗时，平摊到其他那些时间复杂度比较低的操作上。而且，在能够应用均摊时间复杂度分析的场合，一般均摊时间复杂度就等于最好情况时间复杂度。 一、复杂度分析的 4 个概念 最好情况时间复杂度：代码在最理想情况下执行的时间复杂度。 最坏情况时间复杂度：代码在最坏情况下执行的时间复杂度。 平均时间复杂度：用代码在所有情况下执行的次数的加权平均值表示。 均摊时间复杂度：在代码执行的所有复杂度情况中绝大部分是低级别的复杂度，个别情况是高级别复杂度且发生具有时序关系时，可以将个别高级别复杂度均摊到低级别复杂度上。基本上均摊结果就等于低级别复杂度。 二、为什么要引入这 4 个概念？ 同一段代码在不同情况下时间复杂度会出现量级差异，为了更全面，更准确的描述代码的时间复杂度，所以引入这 4 个概念。 代码复杂度在不同情况下出现量级差别时才需要区别这四种复杂度。大多数情况下，是不需要区别分析它们的。 三、 平均时间复杂度 代码在不同情况下复杂度出现量级差别，则用代码所有可能情况下执行次数的加权平均值表示。 均摊时间复杂度 两个条件满足时使用： 1 ）代码在绝大多数情况下是低级别复杂度，只有极少数情况是高级别复杂度； 2 ）低级别和高级别复杂度出现具有时序规律。均摊结果一般都等于低级别复杂度。 习题 // 全局变量，大小为 10 的数组 array ，长度 len ，下标 i 。 int array[] = new int[10]; int len = 10; int i = 0; // 往数组中添加一个元素 void add(int element) { if (i &gt;= len) { // 数组空间不够了 // 重新申请一个 2 倍大小的数组空间 int new_array[] = new int[len*2]; // 把原来 array 数组中的数据依次 copy 到 new_array for (int j = 0; j &lt; len; ++j) { new_array[j] = array[j]; } // new_array 复制给 array ， array 现在大小就是 2 倍 len 了 array = new_array; len = 2 * len; } // 将 element 放到下标为 i 的位置，下标 i 加一 array[i] = element; ++i; }线性表： 非线性表： 数组 1、存储结构：链式存储，前驱后继关联 2、操作： crud(前后索引关联，涉及最优最糟问题) 特点：非常低效 查询操作： 了解其存储方式，即查询就是通过数组下标进行。 插入操作： 假设数组的长度为n，现在，如果我们需要将一个数据插入到数组中的第k个位置。为了把第k个位置腾出来，给新来的数据，我们需要将第k~n这部分的元素都顺序地往后挪一位。那插入操作的时间复杂度是多少呢？ 如果在数组的末尾插入元素，那就不需要移动数据了，这时的(最优)时间复杂度为O（1）。但如果在数组的开头插入元素，那所有的数据都需要依次往后移动一位，所以最坏时间复杂度是O（n）。因为我们在每个位置插入元素的概率是一样的，所以平均情况时间复杂度为（1+2+.n）/n=O（n）。 如果数组中的数据是有序的，我们在某个位置插入一个新的元素时，就必须按照刚才的方法搬移k之后的数据。但是，如果数组中存储的数据并没有任何规律，数组只是被当作一个存储数据的集合。在这种情况下，如果要将某个数组插入到第k个位置，为了避免大规模的数据搬移，我们还有一个简单的办法就是，直接将第k位的数据搬移到数组元素的最后，把新的元素直接放入第k个位置。 例： 假设数组a[10]中存储了如下5个元素：a，b，c，d，e。我们现在需要将元素X插入到第3个位置。我们只需要将c放入到a[5]，将a[2]赋值为X即可。最后，数组中的元素如下：a，b，x，d，e，c。 删除操作： 跟插入数据类似，如果我们要删除第k个位置的数据，为了内存的连续性，也需要搬移数据，不然中间就会出现空洞，内存就不连续了。和插入类似，如果删除数组末尾的数据，则最好情况时间复杂度为O（1）；如果删除开头的数据，则最坏情况时间复杂度为O（n）；平均情况时间复杂度也为O（n）。 实际上，在某些特殊场景下，我们并不一定非得追求数组中数据的连续性。如果我们将多次删除操作集中在一起执行，删除的效率是不是会提高很多呢？例： 数组a[1]中存储了8个元素：a，b，c，d，e，f，g，h。现在，我们要依次删除a，b，c三个元素。 为了避免d，e，f，g，h这几个数据会被搬移三次，我们可以先记录下已经删除的数据。每次的删除操作并不是真正地搬移数据，只是记录数据已经被删除。当数组没有更多空间存储数据时，我们再触发执行一次真正的删除操作，这样就大大减少了删除操作导致的数据搬移。 访问数组越界问题： 即访问数组以外的资源； 容器能否完全替代数组？ 针对数组类型，很多语言都提供了容器类，比如Java中的Arraylist、C++STL中的ector。在项目开发中，什么时候适合用数组，什么时候适合用容器呢？ArrayList与数组相比，有哪些优势呢？ArrayList的优势就是可以将很多数组操作的细节封装起来。比如前面提到的数组插入、删除数据时需要搬移其他数据等。另外，它还有一个优势，就是支持动态扩容。数组本身在定义的时候需要预先指定大小，因为需要分配连续的内存空间。如果我们申请了大小为10的组，当第11个数据需要存储到数组中时，我们就需要重新分配一块更大的空间，将原来的数据复制过去，然后再将新的数据插入。 注意因为扩容操作涉及内存申请和数据搬移，是比较耗时的。所以，如果事先能确定需要存储的数据大小，最好在创建ArrayList的时候事先指定数据大小。 例： ArrayList&lt;User&gt; users = new ArrayList(10000); for (int i = 0; i &lt; 10000; ++i) { users.add(xxx); } 1.Java Arraylist无法存储基本类型，比如int、long，需要封装为Integer、Long类，而Autoboxing、Unboxing则有一定的性能消耗，所以如果特别关注性能，或者希望使用基本类型，就可以选用数组。2.如果数据大小事先已知，并且对数据的操作非常简单，用不到ArrayList提供的大部分方法，也可以直接使用数组。3.还有一个是我个人的喜好，当要表示多维数组时，用数组往往会更加直观。比如Object[][] array；而用容器的话则需要这样定义：ArrayListarray。 数组下标问题： 链表： 如何实现LRU缓存算法？ 缓存是一种提高数据读取性能的技术，在硬件设计、软件开发中都有着非常广泛的应用，比如常见的CPU缓存、数据库缓存、浏览器缓存等等。 缓存的大小有限，当缓存被用满时，哪些数据应该被清理出去，哪些数据应该被保留？这就需要缓存淘汰策略来决定。常见的策略有三种： 先进先出策略FIFO（First In，First Out） 最少使用策略LFU（Least Frequently Used） 最近最少使用策略LRU（Least Recently Used）。 数组与链表的存储结构： 单链表： 特点：索引串联存储，除了存储数据外，还需存储下一节点的索引，头尾相连，最后一个元素指向空 插入删除操作 查找操作 链表要想随机访问第k个元素，就没有数组那么高效了。因为链表中的数据并非连续存储的，所以无法像数组那样，根据首地址和下标，通过寻址公式就能直接计算出对应的内存地址，而是需要根据指针一个结点一个结点地依次遍历，直到找到相应的结点。需要O（n）的时间复杂度。 循环链表 特点：同单链表，不同在于尾节点指向起始头节点。 优点：任意节点出发的操作，而不用从头开始。 约瑟夫环问题 算法原理： 约瑟夫环运作如下： 1、一群人围在一起坐成 [2] 环状（如：N） 2、从某个编号开始报数（如：K） 3、数到某个数（如：M）的时候，此人出列，下一个人重新报数 4、一直循环，直到所有人出列 [3] ，约瑟夫环结束 自己写了一个：普通 看了下递归算法，还有待研究 优质推荐：应有尽有 双向链表 节点结构：前驱指针域 数据域 后继指针域 特点： 双向链表需要额外的两个空间来存储后继结点和前驱结点的地址。所以，如果存储同样多的数据，双向链表要比单链表占用更多的内存空间。虽然两个指针比较浪费存储空间，但可以支持双向遍历，这样也带来了双向链表操作的灵活性。 常见删除操作： 删除结点中“值等于某个给定值”的结点；删除给定指针指向的结点。 对于第一种情况，不管是单链表还是双向链表，为了查找到值等于给定值的结点，都需要从头结点开始一个一个依次遍历对比，直到找到值等于给定值的结点，然后再通过我前面讲的指针操作将其删除。尽管单纯的删除操作时间复杂度是O（1），但遍历查找的时间是主要的耗时点，对应的时间复杂度为O（n）。根据时间复杂度分析中的加法法则，删除值等于给定值的结点对应的链表操作的总时间复杂度为O（n）。对于第二种情况，我们已经找到了要删除的结点，但是删除某个结点q需要知道其前驱结点，而单链表并不支持直接获取前驱结点，所以，为了找到前驱结点，我们还是要从头结点开始遍历链表，直到p-&gt;next=q，说明p是q的前驱结点。但是对于双向链表来说，这种情况就比较有优势了。因为双向链表中的结点已经保存了前驱结点的指针，不需要像单链表那样遍历。所以，针对第二种情况，单链表删除操作需要O（n）的时间复杂度，而双向链表只需要在O（1）的时间复杂度内就搞定了！ 同理，如果我们希望在链表的某个指定结点前面插入一个结点，双向链表比单链表有很大的优势。双向链表可以在O（1）时间复杂度搞定，而单向链表需要O（n）的时间复杂度。除了插入、删除操作有优势之外，对于一个有序链表，双向链表的按值查询的效率也要比单链表高一些。因为，我们可以记录上次查找的位置p，每次查询时，根据要查找的值与p的大小关系，决定是往前还是往后查找，所以平均只需要查找一半的数据。现在，你有没有觉得双向链表要比单链表更加高效呢？这就是为什么在实际的软件开发中，双向链表尽管比较费内存，但还是比单链表的应用更加广泛的原因。如果你熟悉Java语言，你肯定用过LinkedHashMap这个容器。如果你深入研究LinkedHashMap的实现原理，就会发现其中就用到了双向链表这种数据结构。实际上，这里有一个更加重要的知识点需要你掌握，那就是用空间换时间的设计思想。当内存空间充足的时候，如果我们更加追求代码的执行速度，我们就可以选择空间复杂度相对较高、但时间复杂度相对很低的算法或者数据结构。相反，如果内存比较紧缺，比如代码跑在手机或者单片机上，这个时候，就要反过来用时间换空间的设计思路。 还是开篇缓存的例子。缓存实际上就是利用了空间换时间的设计思想。如果我们把数据存储在硬盘上，会比较节省内存，但每次查找数据都要询问一次硬盘，会比较慢。但如果我们通过缓存技术，事先将数据加载在内存中，虽然会比较耗费内存空间，但是每次数据查询的速度就大大提高了。所以我总结一下，对于执行较慢的程序，可以通过消耗更多的内存（空间换时间）来进行优化；而消耗过多内存的程序，可以通过消耗更多的时间（时间换空间）来降低内存的消耗。你还能想到其他时间换空间或者空间换时间的例子吗？了解了循环链表和双向链表，如果把这两种链表整合在一起就是一个新的版本：双向循环链表。我想不用我多讲，你应该知道双向循环链表长什么样子了吧？你可以自己试着在纸上画一画。 链表与数组性能比较 不过，数组和链表的对比，并不能局限于时间复杂度。而且，在实际的软件开发中，不能仅仅利用复杂度分析就决定使用哪个数据结构来存储数据。数组简单易用，在实现上使用的是连续的内存空间，可以借助CPU的缓存机制，预读数组中的数据，所以访问效率更高。而链表在内存中并不是连续存储，所以对CPU缓存不友好，没办法有效预读。数组的缺点是大小固定，一经声明就要占用整块连续内存空间。如果声明的数组过大，系统可能没有足够的连续内存空间分配给它，导致“内存不足（out of memory）”。如果声明的数组过小，则可能出现不够用的情况。这时只能再申请一个更大的内存空间，把原数组拷贝进去，非常费时。链表本身没有大小的限制，天然地支持动态扩容，我觉得这也是它与数组最大的区别。你可能会说，我们Java中的ArayList容器，也可以支持动态扩容啊？我们上一节课讲过，当我们往支持动态扩容的数组中插入一个数据时，如果数组中没有空闲空间了，就会申请一个更大的空间，将数据拷贝过去，而数据拷贝的操作是非常耗时的。我举一个稍微极端的例子。如果我们用ArrayList存储了了1GB大小的数据，这个时候已经没有空闲空间了，当我们再插入数据的时候，Arraylist会申请一个1.5GB大小的存储空间，并且把原来那1GB的数据拷贝到新申请的空间上。听起来是不是就很耗时？ 除此之外，如果你的代码对内存的使用非常苛刻，那数组就更适合你。因为链表中的每个结点都需要消耗额外的存储空间去存储一份指向下一个结点的指针，所以内存消耗会翻倍。而且，对链表进行频繁的插入、删除操作，还会导致频繁的内存申请和释放，容易造成内存碎片，如果是Java语言，就有可能会导致频繁的GC（Garbage Collection，垃圾回收）。所以，在我们实际的开发中，针对不同类型的项目，要根据具体情况，权衡究竟是选择数组还是链表。 解答开篇好了，关于链表的知识我们就讲完了。我们现在回过头来看下开篇留给你的思考题。如何基于链表实现LRU缓存淘汰算法？我的思路是这样的： 我们维护一个有序单链表，越靠近链表尾部的结点是越早之前访问的。当有一个新的数据被访问时，我们从链表头开始顺序遍历链表。1.如果此数据之前已经被缓存在链表中了，我们遍历得到这个数据对应的结点，并将其从原来的位置删除，然后再插入到链表的头部。2.如果此数据没有在缓存链表中，又可以分为两种情况：·如果此时缓存未满，则将此结点直接插入到链表的头部；·如果此时缓存已满，则链表尾结点删除，将新的数据结点插入链表的头部。这样我们就用链表实现了一个LRU缓存，是不是很简单？现在我们来看下m缓存访问的时间复杂度是多少。因为不管缓存有没有满，我们都需要遍历一遍链表，所以这种基于链表的实现思路，缓存访问的时间复杂度为O（n）。 实际上，我们可以继续优化这个实现思路，比如引入散列表（Hash table）来记录每个数据的位置，将缓存访问的时间复杂度降到O（1）。因为要涉及我们还没有讲到的数据结构，所以这个优化方案，我现在就不详细说了，等讲到散列表的时候，我会再拿出来讲。除了基于链表的实现思路，实际上还可以用数组来实现LRU缓存淘汰策略。如何利用数组实现LRU缓存淘汰策略呢？我把这个问题留给你思考。 课后思考如果字符串是通过单链表来存储的，那该如何来判断是一个回文串呢？相应的时间空间复杂度又是多少呢？","categories":[{"name":"Geek","slug":"Geek","permalink":"https://casuor.top/categories/Geek/"}],"tags":[]},{"title":"RPC架构简介与原理","slug":"geek_RPC架构简介与原理","date":"2018-07-24T16:00:00.000Z","updated":"2020-10-28T09:58:54.880Z","comments":true,"path":"2018/07/25/geek_RPC架构简介与原理/","link":"","permalink":"https://casuor.top/2018/07/25/geek_RPC%E6%9E%B6%E6%9E%84%E7%AE%80%E4%BB%8B%E4%B8%8E%E5%8E%9F%E7%90%86/","excerpt":"","text":"RPC架构简介与原理 RPC简介 RPC(Remote Procedure Call，即远程过程调用)是建立在Socket之上的，在一台机器上运行的主程序，可以调用另一台机器上准备好的子程序，就像LPC(本地过程调用)。也就是说两台服务器A，B，一个应用部署在A服务器上，想要调用B服务器上应用提供的函数/方法，由于不在一个内存空间，不能直接调用，需要通过网络来表达调用的语义和传达调用的数据。对于RPC架构来说，应用越底层，代码越复杂、灵活性越高、效率越高；应用越上层，抽象封装的越好、代码越简单、效率越差。 通过RPC，我们可以充分利用非共享内存的多处理器环境(例如通过局域网连接的多台应用服务器)，这样可以简便地将你的应用分布在多台应用服务器上，应用程序就像运行在一个多处理器的计算机上一样。我们可以方便的实现过程代码共享，提高系统资源的利用率，也可以将以大量数值处理的操作放在处理能力较强的系统上运行，从而减轻前端机的负担。 RPC作为普遍的C/S开发方法，开发效率高效、可靠。但RPC方法的基本原则是：以模块调用的简单性忽略通讯的具体细节，以便程序员不用关心C/S之间的通讯协议，集中精力实现应用过程。这就决定了 RPC生成的通讯包不可能对每种应用都有最恰当的处理办法，与Socket方法相比，传输相同的有效数据，RPC占用更多的网络带宽。RPC是在Socket的基础上实现的，它比socket需要更多的网络和系统资源。 RPC架构的作用 RPC 的主要目标是让构建分布式计算（应用）更容易、透明，在提供强大的远程调用能力时不损失本地调用的语义简洁性。为实现该目标，RPC 框架需提供一种透明调用机制让使用者不必显式的区分本地调用和远程调用。RPC框架负责屏蔽底层的传输方式（TCP或者UDP）、序列化方式（XML/JSON/二进制）和通信细节。开发人员在使用的时候只需要了解谁在什么位置提供了什么样的远程服务接口即可，并不需要关心底层通信细节和调用过程。 1、从通信协议的层面，大致可以分为： （1）基于HTTP协议的（例如基于文本的SOAP（XML）、REST（JSON）、基于二进制Hessian（Binary））； （2）基于TCP协议的（通常会借助Mina、Netty等高性能网络框架）。 2、只有二进制数据才能在网络中传输，序列化和反序列化的定义是： （1）将对象转换成二进制流的过程叫做序列化； （2）将二进制流转换成对象的过程叫做反序列化。 3、 RPC架构分为三部分： (1)、服务提供者（RPC Server），运行在服务器端，提供服务接口定义与服务实现类。 (2)、服务中心（Registry），运行在服务器端，负责将本地服务发布成远程服务，管理远程服务，提供给服务消费者使用。 (3)、服务消费者（RPC Client），运行在客户端，通过远程代理对象调用远程服务。 服务提供者启动后主动向服务（注册）中心注册机器ip、端口以及提供的服务列表； 服务消费者启动时向服务（注册）中心获取服务提供方地址列表，可实现软负载均衡和Failover。 RPC调用流程 简单来说一个RPC架构里包含如下4个组件: 1、 客户端(RPC Client)：服务调用方 2、 客户端存根(Client Stub)：存放服务端地址信息，将客户端的请求参数打包成网络消息，再通过网络发送给服务方 3、 服务端存根(Server Stub)：接受客户端发送过来的消息并解包，再调用本地服务 4、 服务端(RPC Server)：真正的服务提供者。 RPC采用C/S模式,请求程序就是一个客户端应用，而服务提供者就是一个服务器。首先，服务消费者（RPC客户端应用）调用进程发送一个有进程参数的调用信息到服务进程，然后等待应答信息。在服务提供方（RPC服务器端），进程保持睡眠状态直到调用信息到达为止。当一个调用信息到达，服务器获得进程参数，调用服务端方法对调用请求进行计算而得到计算结果，并发送答复信息，然后等待下一个调用信息；最后，客户端调用进程接收答复信息，获得进程结果，然后调用执行继续进行。 一次完整的RPC调用流程如下： 1)、服务消费方（Client）调用以本地调用方式调用服务； 2)、Client stub接收到调用后负责将方法、参数等组装成能够进行网络传输的消息体； 3)、Client stub找到服务地址，通过Socket将消息发送到服务端； 4)、Server stub收到消息后进行解码； 5)、Server stub根据解码结果调用服务端本地的服务； 6)、本地服务执行并将结果返回给Server stub； 7)、Server stub将返回结果打包成消息; 8)、Server stub通过Socket将消息发送至客户端； 9)、Client stub接收到消息，并进行解码； 10)、服务消费方（RPC Client）得到最终的服务调用结果。 RPC框架的目标就是要2~9这些步骤都封装起来，让用户对这些细节透明。 当我们在建立RPC服务以后，客户端的调用参数通过底层的RPC传输通道，可以是UDP，也可以是TCP，并根据传输前所提供的目的地址及RPC上层应用程序号转至相应的RPC应用程序服务端，且此时的客户端处于等待状态，直至收到应答或Time Out超时信号。当服务器端获得请求消息，则会根据注册RPC时告诉RPC系统的例程入口地址，执行相应的操作，并将结果返回至客户端。 当一次RPC调用结束后，相应线程发送相应的信号，客户端程序才会继续运行。在这个过程中，一个远程过程是有三个要素来唯一确定的：程序号、版本号和过程号。 程序号是用来区别一组相关的并且具有唯一过程好的远程过程。一个程序可以有一个或几个不同的版本，而每个版本的程序都包含一系列能被远程调用的过程，通过版本的引入，使得不同版本下的RPC能同时提供服务。每个版本都包含有许多可供远程调用的过程，每个过程则有其唯一标示的过程号。 RPC核心技术点和应用构架 1. 核心技术点 (1)、服务提供者需要以某种形式提供服务调用相关的信息，包括但不限于服务接口定义、数据结构、或者中间态的服务定义文件。例如Facebook的 Thrift的IDL文件，Web service的WSDL文件；服务的调用者需要通过一定的场景获取远程服务调用相关的信息。 (2)、远程代理对象：服务调用者用的服务实际是远程服务的本地代理。说白了就是通过动态代理来实现。 (3)、通信：RPC框架与具体的协议无关。 (4)、序列化：毕竟是远程通信，需要将对象转化成二进制流进行传输。不同的RPC框架应用的场景不同，在序列化上也会采取不同的技术。 2. 常见RPC技术和框架 (1)、应用级的服务框架：阿里的Dubbo/Dubbox、Google GRPC、Spring Boot/Spring Cloud。 (2)、远程通信协议：RMI、Socket、SOAP(HTTP XML)、REST(HTTP JSON)。 (3)、通信框架：MINA和Netty。","categories":[{"name":"Geek","slug":"Geek","permalink":"https://casuor.top/categories/Geek/"}],"tags":[]},{"title":"Mysql install for windows","slug":"geek_MysqlInstall","date":"2018-04-24T16:00:00.000Z","updated":"2020-10-28T09:58:54.879Z","comments":true,"path":"2018/04/25/geek_MysqlInstall/","link":"","permalink":"https://casuor.top/2018/04/25/geek_MysqlInstall/","excerpt":"","text":"Mysql离线安装教程（5.7.26）1.下载官网直达 2.解压并创建my.ini文件[mysql] # 设置mysql客户端默认字符集 default-character-set=utf8 [mysqld] # 设置3306端口 port = 3306 # 设置mysql的安装目录 basedir=F:\\Develop_MySQL\\mysql-5.7.26-winx64 #自己改 # 设置mysql数据库的数据的存放目录 datadir=F:\\Develop_MySQL\\mysql-5.7.26-winx64\\data #自己改 # 允许最大连接数 max_connections=200 # 设置mysql服务端默认字符集 character-set-server=utf83.配置环境变量（可省略）path中添加“F:\\Develop_MySQL\\mysql-5.7.26-winx64\\bin” 此步骤省略需进入“F:\\Develop_MySQL\\mysql-5.7.26-winx64\\bin”执行以下指令，反之。 4.初始化数据库管理员运行cmd mysqld --initialize --user=mysql --console 最后一行是随机生成的密码 初始化时出现问题: TIMESTAMP with implicit DEFAULT value is deprecated. Please use --explicit_defaults_for_timestamp server option (see documentation for more details)表明已经初始化过,建议删了重新弄 删除mysql HKEY_LOCAL_MACHINE\\SYSTEM\\ControlSet001\\services\\eventlog\\Application\\MySQL5.安装MySQL服务mysqld --install6.开启服务net start mysql7.进入操作（不解释操作）mysql -u root -p进入时密码一般为空或者生成的随机密码 ![](https://raw.githubusercontent.com/FenQingyang/Ey_PicBed/master/Images 8.修改初始密码方式一（命令行） 进入数据库，键入： ./mysqladmin -uroot -p password方式二（管理工具Navicat） 9.软件链接链接：https://pan.baidu.com/s/1vVOcs_Y2iW6HdM5m3irW0w提取码：h51w 其他版本自行百度","categories":[{"name":"Geek","slug":"Geek","permalink":"https://casuor.top/categories/Geek/"}],"tags":[]},{"title":"commom-class-C#","slug":"geek_csharpcs","date":"2018-03-24T16:00:00.000Z","updated":"2020-10-28T09:58:54.882Z","comments":true,"path":"2018/03/25/geek_csharpcs/","link":"","permalink":"https://casuor.top/2018/03/25/geek_csharpcs/","excerpt":"","text":".Net常用类1.验证码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148using System;using System.Collections.Generic;using System.Drawing;using System.Drawing.Drawing2D;using System.Drawing.Imaging;using System.IO;using System.Linq;using System.Text;using System.Threading.Tasks;using System.Web;namespace CZBK.ItcastProject.Common&#123; public class ValidateCode &#123; public ValidateCode() &#123; &#125; &#x2F;&#x2F;&#x2F; &lt;summary&gt; &#x2F;&#x2F;&#x2F; 验证码的最大长度 &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt; public int MaxLength &#123; get &#123; return 10; &#125; &#125; &#x2F;&#x2F;&#x2F; &lt;summary&gt; &#x2F;&#x2F;&#x2F; 验证码的最小长度 &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt; public int MinLength &#123; get &#123; return 1; &#125; &#125; &#x2F;&#x2F;&#x2F; &lt;summary&gt; &#x2F;&#x2F;&#x2F; 生成验证码 &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt; &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;length&quot;&gt;指定验证码的长度&lt;&#x2F;param&gt; &#x2F;&#x2F;&#x2F; &lt;returns&gt;&lt;&#x2F;returns&gt; public string CreateValidateCode(int length) &#123; int[] randMembers &#x3D; new int[length]; int[] validateNums &#x3D; new int[length]; string validateNumberStr &#x3D; &quot;&quot;; &#x2F;&#x2F;生成起始序列值 int seekSeek &#x3D; unchecked((int)DateTime.Now.Ticks); Random seekRand &#x3D; new Random(seekSeek); int beginSeek &#x3D; (int)seekRand.Next(0, Int32.MaxValue - length * 10000); int[] seeks &#x3D; new int[length]; for (int i &#x3D; 0; i &lt; length; i++) &#123; beginSeek +&#x3D; 10000; seeks[i] &#x3D; beginSeek; &#125; &#x2F;&#x2F;生成随机数字 for (int i &#x3D; 0; i &lt; length; i++) &#123; Random rand &#x3D; new Random(seeks[i]); int pownum &#x3D; 1 * (int)Math.Pow(10, length); randMembers[i] &#x3D; rand.Next(pownum, Int32.MaxValue); &#125; &#x2F;&#x2F;抽取随机数字 for (int i &#x3D; 0; i &lt; length; i++) &#123; string numStr &#x3D; randMembers[i].ToString(); int numLength &#x3D; numStr.Length; Random rand &#x3D; new Random(); int numPosition &#x3D; rand.Next(0, numLength - 1); validateNums[i] &#x3D; Int32.Parse(numStr.Substring(numPosition, 1)); &#125; &#x2F;&#x2F;生成验证码 for (int i &#x3D; 0; i &lt; length; i++) &#123; validateNumberStr +&#x3D; validateNums[i].ToString(); &#125; return validateNumberStr; &#125; &#x2F;&#x2F;&#x2F; &lt;summary&gt; &#x2F;&#x2F;&#x2F; 创建验证码的图片 &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt; &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;containsPage&quot;&gt;要输出到的page对象&lt;&#x2F;param&gt; &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;validateNum&quot;&gt;验证码&lt;&#x2F;param&gt; public void CreateValidateGraphic(string validateCode, HttpContext context) &#123; Bitmap image &#x3D; new Bitmap((int)Math.Ceiling(validateCode.Length * 12.0), 22); Graphics g &#x3D; Graphics.FromImage(image); try &#123; &#x2F;&#x2F;生成随机生成器 Random random &#x3D; new Random(); &#x2F;&#x2F;清空图片背景色 g.Clear(Color.White); &#x2F;&#x2F;画图片的干扰线 for (int i &#x3D; 0; i &lt; 25; i++) &#123; int x1 &#x3D; random.Next(image.Width); int x2 &#x3D; random.Next(image.Width); int y1 &#x3D; random.Next(image.Height); int y2 &#x3D; random.Next(image.Height); g.DrawLine(new Pen(Color.Silver), x1, y1, x2, y2); &#125; Font font &#x3D; new Font(&quot;Arial&quot;, 12, (FontStyle.Bold | FontStyle.Italic)); &#x2F;&#x2F;渐变. LinearGradientBrush brush &#x3D; new LinearGradientBrush(new Rectangle(0, 0, image.Width, image.Height), Color.Blue, Color.DarkRed, 1.2f, true); g.DrawString(validateCode, font, brush, 3, 2); &#x2F;&#x2F;画图片的前景干扰点 for (int i &#x3D; 0; i &lt; 100; i++) &#123; int x &#x3D; random.Next(image.Width); int y &#x3D; random.Next(image.Height); image.SetPixel(x, y, Color.FromArgb(random.Next())); &#125; &#x2F;&#x2F;画图片的边框线 g.DrawRectangle(new Pen(Color.Silver), 0, 0, image.Width - 1, image.Height - 1); &#x2F;&#x2F;保存图片数据 MemoryStream stream &#x3D; new MemoryStream(); image.Save(stream, ImageFormat.Jpeg); &#x2F;&#x2F;输出图片流 context.Response.Clear(); context.Response.ContentType &#x3D; &quot;image&#x2F;jpeg&quot;; context.Response.BinaryWrite(stream.ToArray()); &#125; finally &#123; g.Dispose(); image.Dispose(); &#125; &#125; &#x2F;&#x2F;&#x2F; &lt;summary&gt; &#x2F;&#x2F;&#x2F; 得到验证码图片的长度 &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt; &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;validateNumLength&quot;&gt;验证码的长度&lt;&#x2F;param&gt; &#x2F;&#x2F;&#x2F; &lt;returns&gt;&lt;&#x2F;returns&gt; public static int GetImageWidth(int validateNumLength) &#123; return (int)(validateNumLength * 12.0); &#125; &#x2F;&#x2F;&#x2F; &lt;summary&gt; &#x2F;&#x2F;&#x2F; 得到验证码的高度 &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt; &#x2F;&#x2F;&#x2F; &lt;returns&gt;&lt;&#x2F;returns&gt; public static double GetImageHeight() &#123; return 22.5; &#125; &#125;&#125; 2.缩略图123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590using System;using System.Collections;using System.IO;using System.Drawing;using System.Drawing.Imaging;using System.Drawing.Drawing2D;namespace CZBK.ItcastProject.Common&#123; public class ImageClass &#123; public ImageClass() &#123; &#125; #region 缩略图 &#x2F;&#x2F;&#x2F; &lt;summary&gt; &#x2F;&#x2F;&#x2F; 生成缩略图 &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt; &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;originalImagePath&quot;&gt;源图路径（物理路径）&lt;&#x2F;param&gt; &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;thumbnailPath&quot;&gt;缩略图路径（物理路径）&lt;&#x2F;param&gt; &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;width&quot;&gt;缩略图宽度&lt;&#x2F;param&gt; &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;height&quot;&gt;缩略图高度&lt;&#x2F;param&gt; &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;mode&quot;&gt;生成缩略图的方式&lt;&#x2F;param&gt; public static void MakeThumbnail(string originalImagePath, string thumbnailPath, int width, int height, string mode) &#123; System.Drawing.Image originalImage &#x3D; System.Drawing.Image.FromFile(originalImagePath); int towidth &#x3D; width; int toheight &#x3D; height; int x &#x3D; 0; int y &#x3D; 0; int ow &#x3D; originalImage.Width; int oh &#x3D; originalImage.Height; switch (mode) &#123; case &quot;HW&quot;: &#x2F;&#x2F;指定高宽缩放（可能变形） break; case &quot;W&quot;: &#x2F;&#x2F;指定宽，高按比例 toheight &#x3D; originalImage.Height * width &#x2F; originalImage.Width; break; case &quot;H&quot;: &#x2F;&#x2F;指定高，宽按比例 towidth &#x3D; originalImage.Width * height &#x2F; originalImage.Height; break; case &quot;Cut&quot;: &#x2F;&#x2F;指定高宽裁减（不变形） if ((double)originalImage.Width &#x2F; (double)originalImage.Height &gt; (double)towidth &#x2F; (double)toheight) &#123; oh &#x3D; originalImage.Height; ow &#x3D; originalImage.Height * towidth &#x2F; toheight; y &#x3D; 0; x &#x3D; (originalImage.Width - ow) &#x2F; 2; &#125; else &#123; ow &#x3D; originalImage.Width; oh &#x3D; originalImage.Width * height &#x2F; towidth; x &#x3D; 0; y &#x3D; (originalImage.Height - oh) &#x2F; 2; &#125; break; default: break; &#125; &#x2F;&#x2F;新建一个bmp图片 System.Drawing.Image bitmap &#x3D; new System.Drawing.Bitmap(towidth, toheight); &#x2F;&#x2F;新建一个画板 System.Drawing.Graphics g &#x3D; System.Drawing.Graphics.FromImage(bitmap); &#x2F;&#x2F;设置高质量插值法 g.InterpolationMode &#x3D; System.Drawing.Drawing2D.InterpolationMode.High; &#x2F;&#x2F;设置高质量,低速度呈现平滑程度 g.SmoothingMode &#x3D; System.Drawing.Drawing2D.SmoothingMode.HighQuality; &#x2F;&#x2F;清空画布并以透明背景色填充 g.Clear(System.Drawing.Color.Transparent); &#x2F;&#x2F;在指定位置并且按指定大小绘制原图片的指定部分 &#x2F;&#x2F;第一个：对哪张图片进行操作。 &#x2F;&#x2F;二：画多么大。 &#x2F;&#x2F;三：画那块区域。 g.DrawImage(originalImage, new System.Drawing.Rectangle(0, 0, towidth, toheight), new System.Drawing.Rectangle(x, y, ow, oh), System.Drawing.GraphicsUnit.Pixel); try &#123; &#x2F;&#x2F;以jpg格式保存缩略图 bitmap.Save(thumbnailPath, System.Drawing.Imaging.ImageFormat.Jpeg); &#125; catch (System.Exception e) &#123; throw e; &#125; finally &#123; originalImage.Dispose(); bitmap.Dispose(); g.Dispose(); &#125; &#125; #endregion #region 图片水印 &#x2F;&#x2F;&#x2F; &lt;summary&gt; &#x2F;&#x2F;&#x2F; 图片水印处理方法 &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt; &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;path&quot;&gt;需要加载水印的图片路径（绝对路径）&lt;&#x2F;param&gt; &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;waterpath&quot;&gt;水印图片（绝对路径）&lt;&#x2F;param&gt; &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;location&quot;&gt;水印位置（传送正确的代码）&lt;&#x2F;param&gt; public static string ImageWatermark(string path, string waterpath, string location) &#123; string kz_name &#x3D; Path.GetExtension(path); if (kz_name &#x3D;&#x3D; &quot;.jpg&quot; || kz_name &#x3D;&#x3D; &quot;.bmp&quot; || kz_name &#x3D;&#x3D; &quot;.jpeg&quot;) &#123; DateTime time &#x3D; DateTime.Now; string filename &#x3D; &quot;&quot; + time.Year.ToString() + time.Month.ToString() + time.Day.ToString() + time.Hour.ToString() + time.Minute.ToString() + time.Second.ToString() + time.Millisecond.ToString(); Image img &#x3D; Bitmap.FromFile(path); Image waterimg &#x3D; Image.FromFile(waterpath); Graphics g &#x3D; Graphics.FromImage(img); ArrayList loca &#x3D; GetLocation(location, img, waterimg); g.DrawImage(waterimg, new Rectangle(int.Parse(loca[0].ToString()), int.Parse(loca[1].ToString()), waterimg.Width, waterimg.Height)); waterimg.Dispose(); g.Dispose(); string newpath &#x3D; Path.GetDirectoryName(path) + filename + kz_name; img.Save(newpath); img.Dispose(); File.Copy(newpath, path, true); if (File.Exists(newpath)) &#123; File.Delete(newpath); &#125; &#125; return path; &#125; &#x2F;&#x2F;&#x2F; &lt;summary&gt; &#x2F;&#x2F;&#x2F; 图片水印位置处理方法 &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt; &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;location&quot;&gt;水印位置&lt;&#x2F;param&gt; &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;img&quot;&gt;需要添加水印的图片&lt;&#x2F;param&gt; &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;waterimg&quot;&gt;水印图片&lt;&#x2F;param&gt; private static ArrayList GetLocation(string location, Image img, Image waterimg) &#123; ArrayList loca &#x3D; new ArrayList(); int x &#x3D; 0; int y &#x3D; 0; if (location &#x3D;&#x3D; &quot;LT&quot;) &#123; x &#x3D; 10; y &#x3D; 10; &#125; else if (location &#x3D;&#x3D; &quot;T&quot;) &#123; x &#x3D; img.Width &#x2F; 2 - waterimg.Width &#x2F; 2; y &#x3D; img.Height - waterimg.Height; &#125; else if (location &#x3D;&#x3D; &quot;RT&quot;) &#123; x &#x3D; img.Width - waterimg.Width; y &#x3D; 10; &#125; else if (location &#x3D;&#x3D; &quot;LC&quot;) &#123; x &#x3D; 10; y &#x3D; img.Height &#x2F; 2 - waterimg.Height &#x2F; 2; &#125; else if (location &#x3D;&#x3D; &quot;C&quot;) &#123; x &#x3D; img.Width &#x2F; 2 - waterimg.Width &#x2F; 2; y &#x3D; img.Height &#x2F; 2 - waterimg.Height &#x2F; 2; &#125; else if (location &#x3D;&#x3D; &quot;RC&quot;) &#123; x &#x3D; img.Width - waterimg.Width; y &#x3D; img.Height &#x2F; 2 - waterimg.Height &#x2F; 2; &#125; else if (location &#x3D;&#x3D; &quot;LB&quot;) &#123; x &#x3D; 10; y &#x3D; img.Height - waterimg.Height; &#125; else if (location &#x3D;&#x3D; &quot;B&quot;) &#123; x &#x3D; img.Width &#x2F; 2 - waterimg.Width &#x2F; 2; y &#x3D; img.Height - waterimg.Height; &#125; else &#123; x &#x3D; img.Width - waterimg.Width; y &#x3D; img.Height - waterimg.Height; &#125; loca.Add(x); loca.Add(y); return loca; &#125; #endregion #region 文字水印 &#x2F;&#x2F;&#x2F; &lt;summary&gt; &#x2F;&#x2F;&#x2F; 文字水印处理方法 &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt; &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;path&quot;&gt;图片路径（绝对路径）&lt;&#x2F;param&gt; &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;size&quot;&gt;字体大小&lt;&#x2F;param&gt; &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;letter&quot;&gt;水印文字&lt;&#x2F;param&gt; &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;color&quot;&gt;颜色&lt;&#x2F;param&gt; &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;location&quot;&gt;水印位置&lt;&#x2F;param&gt; public static string LetterWatermark(string path, int size, string letter, Color color, string location) &#123; #region string kz_name &#x3D; Path.GetExtension(path); if (kz_name &#x3D;&#x3D; &quot;.jpg&quot; || kz_name &#x3D;&#x3D; &quot;.bmp&quot; || kz_name &#x3D;&#x3D; &quot;.jpeg&quot;) &#123; DateTime time &#x3D; DateTime.Now; string filename &#x3D; &quot;&quot; + time.Year.ToString() + time.Month.ToString() + time.Day.ToString() + time.Hour.ToString() + time.Minute.ToString() + time.Second.ToString() + time.Millisecond.ToString(); Image img &#x3D; Bitmap.FromFile(path); Graphics gs &#x3D; Graphics.FromImage(img); ArrayList loca &#x3D; GetLocation(location, img, size, letter.Length); Font font &#x3D; new Font(&quot;宋体&quot;, size); Brush br &#x3D; new SolidBrush(color); gs.DrawString(letter, font, br, float.Parse(loca[0].ToString()), float.Parse(loca[1].ToString())); gs.Dispose(); string newpath &#x3D; Path.GetDirectoryName(path) + filename + kz_name; img.Save(newpath); img.Dispose(); File.Copy(newpath, path, true); if (File.Exists(newpath)) &#123; File.Delete(newpath); &#125; &#125; return path; #endregion &#125; &#x2F;&#x2F;&#x2F; &lt;summary&gt; &#x2F;&#x2F;&#x2F; 文字水印位置的方法 &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt; &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;location&quot;&gt;位置代码&lt;&#x2F;param&gt; &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;img&quot;&gt;图片对象&lt;&#x2F;param&gt; &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;width&quot;&gt;宽(当水印类型为文字时,传过来的就是字体的大小)&lt;&#x2F;param&gt; &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;height&quot;&gt;高(当水印类型为文字时,传过来的就是字符的长度)&lt;&#x2F;param&gt; private static ArrayList GetLocation(string location, Image img, int width, int height) &#123; #region ArrayList loca &#x3D; new ArrayList(); &#x2F;&#x2F;定义数组存储位置 float x &#x3D; 10; float y &#x3D; 10; if (location &#x3D;&#x3D; &quot;LT&quot;) &#123; loca.Add(x); loca.Add(y); &#125; else if (location &#x3D;&#x3D; &quot;T&quot;) &#123; x &#x3D; img.Width &#x2F; 2 - (width * height) &#x2F; 2; loca.Add(x); loca.Add(y); &#125; else if (location &#x3D;&#x3D; &quot;RT&quot;) &#123; x &#x3D; img.Width - width * height; &#125; else if (location &#x3D;&#x3D; &quot;LC&quot;) &#123; y &#x3D; img.Height &#x2F; 2; &#125; else if (location &#x3D;&#x3D; &quot;C&quot;) &#123; x &#x3D; img.Width &#x2F; 2 - (width * height) &#x2F; 2; y &#x3D; img.Height &#x2F; 2; &#125; else if (location &#x3D;&#x3D; &quot;RC&quot;) &#123; x &#x3D; img.Width - height; y &#x3D; img.Height &#x2F; 2; &#125; else if (location &#x3D;&#x3D; &quot;LB&quot;) &#123; y &#x3D; img.Height - width - 5; &#125; else if (location &#x3D;&#x3D; &quot;B&quot;) &#123; x &#x3D; img.Width &#x2F; 2 - (width * height) &#x2F; 2; y &#x3D; img.Height - width - 5; &#125; else &#123; x &#x3D; img.Width - width * height; y &#x3D; img.Height - width - 5; &#125; loca.Add(x); loca.Add(y); return loca; #endregion &#125; #endregion #region 调整光暗 &#x2F;&#x2F;&#x2F; &lt;summary&gt; &#x2F;&#x2F;&#x2F; 调整光暗 &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt; &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;mybm&quot;&gt;原始图片&lt;&#x2F;param&gt; &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;width&quot;&gt;原始图片的长度&lt;&#x2F;param&gt; &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;height&quot;&gt;原始图片的高度&lt;&#x2F;param&gt; &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;val&quot;&gt;增加或减少的光暗值&lt;&#x2F;param&gt; public Bitmap LDPic(Bitmap mybm, int width, int height, int val) &#123; Bitmap bm &#x3D; new Bitmap(width, height);&#x2F;&#x2F;初始化一个记录经过处理后的图片对象 int x, y, resultR, resultG, resultB;&#x2F;&#x2F;x、y是循环次数，后面三个是记录红绿蓝三个值的 Color pixel; for (x &#x3D; 0; x &lt; width; x++) &#123; for (y &#x3D; 0; y &lt; height; y++) &#123; pixel &#x3D; mybm.GetPixel(x, y);&#x2F;&#x2F;获取当前像素的值 resultR &#x3D; pixel.R + val;&#x2F;&#x2F;检查红色值会不会超出[0, 255] resultG &#x3D; pixel.G + val;&#x2F;&#x2F;检查绿色值会不会超出[0, 255] resultB &#x3D; pixel.B + val;&#x2F;&#x2F;检查蓝色值会不会超出[0, 255] bm.SetPixel(x, y, Color.FromArgb(resultR, resultG, resultB));&#x2F;&#x2F;绘图 &#125; &#125; return bm; &#125; #endregion #region 反色处理 &#x2F;&#x2F;&#x2F; &lt;summary&gt; &#x2F;&#x2F;&#x2F; 反色处理 &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt; &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;mybm&quot;&gt;原始图片&lt;&#x2F;param&gt; &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;width&quot;&gt;原始图片的长度&lt;&#x2F;param&gt; &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;height&quot;&gt;原始图片的高度&lt;&#x2F;param&gt; public Bitmap RePic(Bitmap mybm, int width, int height) &#123; Bitmap bm &#x3D; new Bitmap(width, height);&#x2F;&#x2F;初始化一个记录处理后的图片的对象 int x, y, resultR, resultG, resultB; Color pixel; for (x &#x3D; 0; x &lt; width; x++) &#123; for (y &#x3D; 0; y &lt; height; y++) &#123; pixel &#x3D; mybm.GetPixel(x, y);&#x2F;&#x2F;获取当前坐标的像素值 resultR &#x3D; 255 - pixel.R;&#x2F;&#x2F;反红 resultG &#x3D; 255 - pixel.G;&#x2F;&#x2F;反绿 resultB &#x3D; 255 - pixel.B;&#x2F;&#x2F;反蓝 bm.SetPixel(x, y, Color.FromArgb(resultR, resultG, resultB));&#x2F;&#x2F;绘图 &#125; &#125; return bm; &#125; #endregion #region 浮雕处理 &#x2F;&#x2F;&#x2F; &lt;summary&gt; &#x2F;&#x2F;&#x2F; 浮雕处理 &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt; &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;oldBitmap&quot;&gt;原始图片&lt;&#x2F;param&gt; &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;Width&quot;&gt;原始图片的长度&lt;&#x2F;param&gt; &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;Height&quot;&gt;原始图片的高度&lt;&#x2F;param&gt; public Bitmap FD(Bitmap oldBitmap, int Width, int Height) &#123; Bitmap newBitmap &#x3D; new Bitmap(Width, Height); Color color1, color2; for (int x &#x3D; 0; x &lt; Width - 1; x++) &#123; for (int y &#x3D; 0; y &lt; Height - 1; y++) &#123; int r &#x3D; 0, g &#x3D; 0, b &#x3D; 0; color1 &#x3D; oldBitmap.GetPixel(x, y); color2 &#x3D; oldBitmap.GetPixel(x + 1, y + 1); r &#x3D; Math.Abs(color1.R - color2.R + 128); g &#x3D; Math.Abs(color1.G - color2.G + 128); b &#x3D; Math.Abs(color1.B - color2.B + 128); if (r &gt; 255) r &#x3D; 255; if (r &lt; 0) r &#x3D; 0; if (g &gt; 255) g &#x3D; 255; if (g &lt; 0) g &#x3D; 0; if (b &gt; 255) b &#x3D; 255; if (b &lt; 0) b &#x3D; 0; newBitmap.SetPixel(x, y, Color.FromArgb(r, g, b)); &#125; &#125; return newBitmap; &#125; #endregion #region 拉伸图片 &#x2F;&#x2F;&#x2F; &lt;summary&gt; &#x2F;&#x2F;&#x2F; 拉伸图片 &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt; &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;bmp&quot;&gt;原始图片&lt;&#x2F;param&gt; &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;newW&quot;&gt;新的宽度&lt;&#x2F;param&gt; &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;newH&quot;&gt;新的高度&lt;&#x2F;param&gt; public static Bitmap ResizeImage(Bitmap bmp, int newW, int newH) &#123; try &#123; Bitmap bap &#x3D; new Bitmap(newW, newH); Graphics g &#x3D; Graphics.FromImage(bap); g.InterpolationMode &#x3D; System.Drawing.Drawing2D.InterpolationMode.HighQualityBicubic; g.DrawImage(bap, new Rectangle(0, 0, newW, newH), new Rectangle(0, 0, bap.Width, bap.Height), GraphicsUnit.Pixel); g.Dispose(); return bap; &#125; catch &#123; return null; &#125; &#125; #endregion #region 滤色处理 &#x2F;&#x2F;&#x2F; &lt;summary&gt; &#x2F;&#x2F;&#x2F; 滤色处理 &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt; &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;mybm&quot;&gt;原始图片&lt;&#x2F;param&gt; &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;width&quot;&gt;原始图片的长度&lt;&#x2F;param&gt; &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;height&quot;&gt;原始图片的高度&lt;&#x2F;param&gt; public Bitmap FilPic(Bitmap mybm, int width, int height) &#123; Bitmap bm &#x3D; new Bitmap(width, height);&#x2F;&#x2F;初始化一个记录滤色效果的图片对象 int x, y; Color pixel; for (x &#x3D; 0; x &lt; width; x++) &#123; for (y &#x3D; 0; y &lt; height; y++) &#123; pixel &#x3D; mybm.GetPixel(x, y);&#x2F;&#x2F;获取当前坐标的像素值 bm.SetPixel(x, y, Color.FromArgb(0, pixel.G, pixel.B));&#x2F;&#x2F;绘图 &#125; &#125; return bm; &#125; #endregion #region 左右翻转 &#x2F;&#x2F;&#x2F; &lt;summary&gt; &#x2F;&#x2F;&#x2F; 左右翻转 &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt; &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;mybm&quot;&gt;原始图片&lt;&#x2F;param&gt; &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;width&quot;&gt;原始图片的长度&lt;&#x2F;param&gt; &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;height&quot;&gt;原始图片的高度&lt;&#x2F;param&gt; public Bitmap RevPicLR(Bitmap mybm, int width, int height) &#123; Bitmap bm &#x3D; new Bitmap(width, height); int x, y, z; &#x2F;&#x2F;x,y是循环次数,z是用来记录像素点的x坐标的变化的 Color pixel; for (y &#x3D; height - 1; y &gt;&#x3D; 0; y--) &#123; for (x &#x3D; width - 1, z &#x3D; 0; x &gt;&#x3D; 0; x--) &#123; pixel &#x3D; mybm.GetPixel(x, y);&#x2F;&#x2F;获取当前像素的值 bm.SetPixel(z++, y, Color.FromArgb(pixel.R, pixel.G, pixel.B));&#x2F;&#x2F;绘图 &#125; &#125; return bm; &#125; #endregion #region 上下翻转 &#x2F;&#x2F;&#x2F; &lt;summary&gt; &#x2F;&#x2F;&#x2F; 上下翻转 &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt; &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;mybm&quot;&gt;原始图片&lt;&#x2F;param&gt; &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;width&quot;&gt;原始图片的长度&lt;&#x2F;param&gt; &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;height&quot;&gt;原始图片的高度&lt;&#x2F;param&gt; public Bitmap RevPicUD(Bitmap mybm, int width, int height) &#123; Bitmap bm &#x3D; new Bitmap(width, height); int x, y, z; Color pixel; for (x &#x3D; 0; x &lt; width; x++) &#123; for (y &#x3D; height - 1, z &#x3D; 0; y &gt;&#x3D; 0; y--) &#123; pixel &#x3D; mybm.GetPixel(x, y);&#x2F;&#x2F;获取当前像素的值 bm.SetPixel(x, z++, Color.FromArgb(pixel.R, pixel.G, pixel.B));&#x2F;&#x2F;绘图 &#125; &#125; return bm; &#125; #endregion #region 压缩图片 &#x2F;&#x2F;&#x2F; &lt;summary&gt; &#x2F;&#x2F;&#x2F; 压缩到指定尺寸 &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt; &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;oldfile&quot;&gt;原文件&lt;&#x2F;param&gt; &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;newfile&quot;&gt;新文件&lt;&#x2F;param&gt; public bool Compress(string oldfile, string newfile) &#123; try &#123; System.Drawing.Image img &#x3D; System.Drawing.Image.FromFile(oldfile); System.Drawing.Imaging.ImageFormat thisFormat &#x3D; img.RawFormat; Size newSize &#x3D; new Size(100, 125); Bitmap outBmp &#x3D; new Bitmap(newSize.Width, newSize.Height); Graphics g &#x3D; Graphics.FromImage(outBmp); g.CompositingQuality &#x3D; CompositingQuality.HighQuality; g.SmoothingMode &#x3D; SmoothingMode.HighQuality; g.InterpolationMode &#x3D; InterpolationMode.HighQualityBicubic; g.DrawImage(img, new Rectangle(0, 0, newSize.Width, newSize.Height), 0, 0, img.Width, img.Height, GraphicsUnit.Pixel); g.Dispose(); EncoderParameters encoderParams &#x3D; new EncoderParameters(); long[] quality &#x3D; new long[1]; quality[0] &#x3D; 100; EncoderParameter encoderParam &#x3D; new EncoderParameter(System.Drawing.Imaging.Encoder.Quality, quality); encoderParams.Param[0] &#x3D; encoderParam; ImageCodecInfo[] arrayICI &#x3D; ImageCodecInfo.GetImageEncoders(); ImageCodecInfo jpegICI &#x3D; null; for (int x &#x3D; 0; x &lt; arrayICI.Length; x++) if (arrayICI[x].FormatDescription.Equals(&quot;JPEG&quot;)) &#123; jpegICI &#x3D; arrayICI[x]; &#x2F;&#x2F;设置JPEG编码 break; &#125; img.Dispose(); if (jpegICI !&#x3D; null) outBmp.Save(newfile, System.Drawing.Imaging.ImageFormat.Jpeg); outBmp.Dispose(); return true; &#125; catch &#123; return false; &#125; &#125; #endregion #region 图片灰度化 public Color Gray(Color c) &#123; int rgb &#x3D; Convert.ToInt32((double)(((0.3 * c.R) + (0.59 * c.G)) + (0.11 * c.B))); return Color.FromArgb(rgb, rgb, rgb); &#125; #endregion #region 转换为黑白图片 &#x2F;&#x2F;&#x2F; &lt;summary&gt; &#x2F;&#x2F;&#x2F; 转换为黑白图片 &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt; &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;mybt&quot;&gt;要进行处理的图片&lt;&#x2F;param&gt; &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;width&quot;&gt;图片的长度&lt;&#x2F;param&gt; &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;height&quot;&gt;图片的高度&lt;&#x2F;param&gt; public Bitmap BWPic(Bitmap mybm, int width, int height) &#123; Bitmap bm &#x3D; new Bitmap(width, height); int x, y, result; &#x2F;&#x2F;x,y是循环次数，result是记录处理后的像素值 Color pixel; for (x &#x3D; 0; x &lt; width; x++) &#123; for (y &#x3D; 0; y &lt; height; y++) &#123; pixel &#x3D; mybm.GetPixel(x, y);&#x2F;&#x2F;获取当前坐标的像素值 result &#x3D; (pixel.R + pixel.G + pixel.B) &#x2F; 3;&#x2F;&#x2F;取红绿蓝三色的平均值 bm.SetPixel(x, y, Color.FromArgb(result, result, result)); &#125; &#125; return bm; &#125; #endregion #region 获取图片中的各帧 &#x2F;&#x2F;&#x2F; &lt;summary&gt; &#x2F;&#x2F;&#x2F; 获取图片中的各帧 &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt; &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;pPath&quot;&gt;图片路径&lt;&#x2F;param&gt; &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;pSavePath&quot;&gt;保存路径&lt;&#x2F;param&gt; public void GetFrames(string pPath, string pSavedPath) &#123; Image gif &#x3D; Image.FromFile(pPath); FrameDimension fd &#x3D; new FrameDimension(gif.FrameDimensionsList[0]); int count &#x3D; gif.GetFrameCount(fd); &#x2F;&#x2F;获取帧数(gif图片可能包含多帧，其它格式图片一般仅一帧) for (int i &#x3D; 0; i &lt; count; i++) &#x2F;&#x2F;以Jpeg格式保存各帧 &#123; gif.SelectActiveFrame(fd, i); gif.Save(pSavedPath + &quot;\\\\frame_&quot; + i + &quot;.jpg&quot;, ImageFormat.Jpeg); &#125; &#125; #endregion &#125;&#125; 3.SqlHelper12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849using System;using System.Collections.Generic;using System.Configuration;using System.Linq;using System.Text;using System.Threading.Tasks;using System.Data;using System.Data.SqlClient;namespace CZBK.ItcastProject.DAL&#123; public class SqlHelper &#123; private static readonly string connStr &#x3D; ConfigurationManager.ConnectionStrings[&quot;connStr&quot;].ConnectionString; public static DataTable GetDataTable(string sql,CommandType type,params SqlParameter[]pars) &#123; using (SqlConnection conn &#x3D; new SqlConnection(connStr)) &#123; using (SqlDataAdapter apter &#x3D; new SqlDataAdapter(sql, conn)) &#123; if (pars !&#x3D; null) &#123; apter.SelectCommand.Parameters.AddRange(pars); &#125; apter.SelectCommand.CommandType &#x3D; type; DataTable da &#x3D; new DataTable(); apter.Fill(da); return da; &#125; &#125; &#125; public static int ExecuteNonquery(string sql, CommandType type, params SqlParameter[] pars) &#123; using (SqlConnection conn &#x3D; new SqlConnection(connStr)) &#123; using (SqlCommand cmd &#x3D; new SqlCommand(sql, conn)) &#123; if (pars !&#x3D; null) &#123; cmd.Parameters.AddRange(pars); &#125; cmd.CommandType &#x3D; type; conn.Open(); return cmd.ExecuteNonQuery(); &#125; &#125; &#125; &#125;&#125;","categories":[{"name":"Geek","slug":"Geek","permalink":"https://casuor.top/categories/Geek/"}],"tags":[]},{"title":"Java Notes","slug":"geek_learningjava","date":"2018-03-24T16:00:00.000Z","updated":"2020-10-28T09:58:54.884Z","comments":true,"path":"2018/03/25/geek_learningjava/","link":"","permalink":"https://casuor.top/2018/03/25/geek_learningjava/","excerpt":"","text":"JavaEETomcattomcat启动问题1.一闪而过 未找到jdk%JAVA_HOME% 2.报错-端口占用cmd netstat -ano 找到8080进程pid 在任务管理器中关掉 修改配置部署方式wabapps目录下 __/项目文件 1.简化部署-项目打包成war包复制到目录下,会自动解压缩 2.配置server.xml 1&lt;Context docbase&#x3D;&quot;原项目路径&quot; path&#x3D;&quot;虚拟路径(随便写)&quot;&#x2F;&gt; 缺点:多个项目,配置不安全 3.在F:\\Develop_Apache\\apache-tomcat-8.5.45-windows-x64\\apache-tomcat-8.5.45\\conf\\Catalina\\localhost目录下创建任意名的xml文件 键入 1&lt;Context docbase&#x3D;&quot;原项目路径&quot;&#x2F;&gt; 则项目的虚拟路径为/xml的文件名 静态项目和动态项目的目录结构IDEA配置Tomcatrun-&gt; edit configurations-&gt;tomcatserver Servlet和Http请求协议Servlet简介-server applet 1）作用：规范了浏览器与服务器(代码编写的一个可以根据用户请求实时的调用执行对应的逻辑代码的一个容器)的数据交互；格式：key:value;2）特点：简单快速；灵活：允许传输任何数据对象，有Content-Type加以标记。无连接：HTTP1.1后支持可持续连接无状态：对于事物处理没有记忆能力3）HTTP交互流程：建立连接发送数据响应客户端4）请求格式：请求头：请求行：空行：请求数据5）get与post的区别6）响应格式及状态码（三个十进制数字组成，第一个定义了状态码的类型，后两个数组没有分类的作用）HTTP状态码分类： demo112345678910111213141516171819202122232425262728293031package com.web.servlet;import javax.servlet.*;import java.io.IOException;public class servlet implements Servlet &#123; @Override public void init(ServletConfig servletConfig) throws ServletException &#123; &#125; @Override public ServletConfig getServletConfig() &#123; return null; &#125; @Override public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException &#123; System.out.println(\"hello servlet\"); &#125; @Override public String getServletInfo() &#123; return null; &#125; @Override public void destroy() &#123; &#125;&#125; web.xml 12345678&lt;servlet&gt; &lt;servlet-name&gt;demo01&lt;/servlet-name&gt; &lt;servlet-class&gt;com.web.servlet.servlet&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;demo01&lt;/servlet-name&gt; &lt;url-pattern&gt;/demo01&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; Servlet技术Servlet 是什么？ Java Servlet 是运行在 Web 服务器或应用服务器上的程序，它是作为来自 Web 浏览器或其他 HTTP 客户端的请求和 HTTP 服务器上的数据库或应用程序之间的中间层。 使用 Servlet，您可以收集来自网页表单的用户输入，呈现来自数据库或者其他源的记录，还可以动态创建网页。 Java Servlet 通常情况下与使用 CGI（Common Gateway Interface，公共网关接口）实现的程序可以达到异曲同工的效果。但是相比于 CGI，Servlet 有以下几点优势： 性能明显更好。Servlet 在 Web 服务器的地址空间内执行。这样它就没有必要再创建一个单独的进程来处理每个客户端请求。Servlet 是独立于平台的，因为它们是用 Java 编写的。服务器上的 Java 安全管理器执行了一系列限制，以保护服务器计算机上的资源。因此，Servlet 是可信的。Java 类库的全部功能对 Servlet 来说都是可用的。它可以通过 sockets 和 RMI 机制与 applets、数据库或其他软件进行交互。 Servlet 任务 Servlet 执行以下主要任务： 读取客户端（浏览器）发送的显式的数据。这包括网页上的 HTML 表单，或者也可以是来自 applet 或自定义的 HTTP 客户端程序的表单。读取客户端（浏览器）发送的隐式的 HTTP 请求数据。这包括 cookies、媒体类型和浏览器能理解的压缩格式等等。处理数据并生成结果。这个过程可能需要访问数据库，执行 RMI 或 CORBA 调用，调用 Web 服务，或者直接计算得出对应的响应。发送显式的数据（即文档）到客户端（浏览器）。该文档的格式可以是多种多样的，包括文本文件（HTML 或 XML）、二进制文件（GIF 图像）、Excel 等。发送隐式的 HTTP 响应到客户端（浏览器）。这包括告诉浏览器或其他客户端被返回的文档类型（例如 HTML），设置 cookies 和缓存参数，以及其他类似的任务。 Servlet使用流程： 1、创建普通Java类，并继承HttpServlet2、覆写service方法3、在service方法中书写逻辑代码4、在webroot下的web-inf文件夹下的web.xml文件中配置servlet(demo1) ​ servlet3.0注解配置 在类上使用@webservlet(&quot;资源路径&quot;)不需要web.xml配置 Servlet访问流程 输入URL 1服务器地址：端口号&#x2F;project&#x2F;要执行的servlet的ul-pattern-&gt;classname-&gt;methodname Tomcat将全类名对应的字节码文件加载进内存Class.forname() 创建class对象.newInstance() 调用service方法 servlet接口的实现 1、实现 Servlet 接口 因为是实现 Servlet 接口，所以我们需要实现接口里的方法。 Servlet生命周期 Servlet的生命周期:从Servlet被创建到Servlet被销毁的过程 特点: 一次创建，到处服务一个Servlet只会有一个对象，服务所有的请求 1.实例化（使用构造方法创建对象） 指定servlet的创建时机 在servlet标签下配置load-on-startup &lt;load-on-startup&gt;负整数&lt;/load-on-startup&gt;//第一次访问时 1234 * &lt;load-on-startup&gt;正整数&lt;/load-on-startup&gt;//服务器启动时 12345678 * 2.初始化 执行init方法* 3.服务 执行service方法* 4.销毁 执行destroy方法 public class ServletDemo1 implements Servlet { //public ServletDemo1(){} //生命周期方法:当Servlet第一次被创建对象时执行该方法,该方法在整个生命周期中只执行一次,Servlet在内存中只存在一个对象,多个用户访问时存在线程安全问题,so,尽量不要在Servlet中定义变量,即使定义了不要修改. public void init(ServletConfig arg0) throws ServletException { System.out.println(&quot;=======init=========&quot;); } //生命周期方法:对客户端响应的方法,该方法会被执行多次，每次请求该servlet都会执行该方法 public void service(ServletRequest arg0, ServletResponse arg1) throws ServletException, IOException { System.out.println(&quot;hehe&quot;);} //生命周期方法:当Servlet被销毁时执行该方法 public void destroy() { System.out.println(&quot;******destroy**********&quot;);} //当停止tomcat时也就销毁的servlet。public ServletConfig getServletConfig() { return null; }//获取Servlet信息 public String getServletInfo() { return null; } } 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455 2、继承 GenericServlet 类它实现了 Servlet 接口除了 service 的方法，不过这种方法我们极少用。public class ServletDemo2 extends GenericServlet &#123; @Override public void service(ServletRequest arg0, ServletResponse arg1) throws ServletException, IOException &#123; System.out.println(&quot;heihei&quot;); &#125;&#125;3、继承 HttpServlet 方法public class ServletDemo3 extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; System.out.println(&quot;haha&quot;); &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; System.out.println(&quot;ee&quot;); doGet(req,resp); &#125;&#125;**关于 HttpServlet、GenericServlet 和 Servlet 的关系**&gt;&gt; 对于一个 Servlet 类，我们日常最常用的方法是继承自 HttpServlet 类，提供了 Http 相关的方 HttpServlet 扩展了 GenericServlet 类，而 GenericServlet 类又实现了 Servlet 类和 ServletConfig 类。&gt;**Servlet方法**&gt; Servlet类提供了五个方法，其中三个生命周期方法和两个普通方法，关于 Servlet类的方法，不再赘述，我主要补充一下另外两个类的实现思路。&gt;**GenericServlet**GenericServlet 是一个抽象类，实现了 Servlet 接口，并且对其中的 init() 和 destroy() 和 service() 提供了默认实现。在 GenericServlet 中，主要完成了以下任务：&gt; 将 init() 中的 ServletConfig 赋给一个类级变量，可以由 getServletConfig 获得；&gt; 为 Servlet 所有方法提供默认实现；&gt; 可以直接调用 ServletConfig 中的方法；基本的结构如下： abstract class GenericServlet implements Servlet,ServletConfig{ //GenericServlet通过将ServletConfig赋给类级变量 private trServletConfig servletConfig; public void init(ServletConfig servletConfig) throws ServletException { this.servletConfig=servletConfig; /*自定义init()的原因是：如果子类要初始化必须覆盖父类的init() 而使它无效 这样 this.servletConfig=servletConfig不起作用 这样就会导致空指针异常 这样如果子类要初始化， 可以直接覆盖不带参数的init()方法 */ this.init(); } //自定义的init()方法，可以由子类覆盖 //init()不是生命周期方法 public void init(){ } //实现service()空方法，并且声明为抽象方法，强制子类必须实现service()方法 public abstract void service(ServletRequest request,ServletResponse response) throws ServletException,java.io.IOException{ } //实现空的destroy方法 public void destroy(){ }} 123456以上就是 GenericServlet 的大致实现思想，可以看到如果继承这个类的话，我们必须重写 service() 方法来对处理请求。**HttpServlet**HttpServlet 也是一个抽象类，它进一步继承并封装了 GenericServlet，使得使用更加简单方便，由于是扩展了 Http 的内容，所以还需要使用 HttpServletRequest 和 HttpServletResponse，这两个类分别是 ServletRequest 和 ServletResponse 的子类。代码如下： abstract class HttpServlet extends GenericServlet{ //HttpServlet中的service() protected void service(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse){ //该方法通过httpServletRequest.getMethod()判断请求类型调用doGet() doPost() } //必须实现父类的service()方法 public void service(ServletRequest servletRequest,ServletResponse servletResponse){ HttpServletRequest request; HttpServletResponse response; try{ request=(HttpServletRequest)servletRequest; response=(HttpServletResponse)servletResponse; }catch(ClassCastException){ throw new ServletException(“non-http request or response”); } //调用service()方法 this.service(request,response); }} 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465我们可以看到，HttpServlet 中对原始的 Servlet 中的方法都进行了默认的操作，不需要显式的销毁初始化以及 service()，在 HttpServlet 中，自定义了一个新的 service() 方法，其中通过 getMethod() 方法判断请求的类型，从而调用 doGet() 或者 doPost() 处理 get,post 请求，使用者只需要继承 HttpServlet，然后重写 doPost() 或者 doGet() 方法处理请求即可。PS:IDEA与Tomcat配置&#96;IDEA会为每一个tomcat部署的项目单独创建一份配置文件&#96;控制台log:using CATALINA_BASE:&#96;工作空间项目和tomcat部署的web项目&#96;- tomcat真正访问的是&quot;tomcat部署的web项目&quot;,&quot;tomcat部署的web项目&quot;对应者工作空间项目下的所有资源.- WEB-INF目录下的资源不能被浏览器直接访问. ------ ### Http协议* 概念：Hyper Text Transfer Protocol 超文本传输协议 * 传输协议：定义了，客户端和服务器端通信时，发送数据的格式 * 特点： 1. 基于TCP&#x2F;IP的高级协议 2. 默认端口号:80 3. 基于请求&#x2F;响应模型的:一次请求对应一次响应 4. 无状态的：每次请求之间相互独立，不能交互数据 * 历史版本： * 1.0：每一次请求响应都会建立新的连接 * 1.1：复用连接* 请求消息数据格式 1. 请求行 请求方式 请求url 请求协议&#x2F;版本 GET &#x2F;login.html HTTP&#x2F;1.1 * 请求方式： * HTTP协议有7中请求方式，常用的有2种 * GET： 1. 请求参数在请求行中，在url后。 2. 请求的url长度有限制的 3. 不太安全 * POST： 1. 请求参数在请求体中 2. 请求的url长度没有限制的 3. 相对安全 2. 请求头：客户端浏览器告诉服务器一些信息 请求头名称: 请求头值 * 常见的请求头： 1. User-Agent：浏览器告诉服务器，我访问你使用的浏览器版本信息 * 可以在服务器端获取该头的信息，解决浏览器的兼容性问题 2. Referer：http:&#x2F;&#x2F;localhost&#x2F;login.html * 告诉服务器，我(当前请求)从哪里来？ * 作用： 1. 防盗链： 2. 统计工作： 3. 请求空行 空行，就是用于分割POST请求的请求头，和请求体的。 4. 请求体(正文)： * 封装POST请求消息的请求参数的 * 字符串格式： POST /login.html HTTP/1.1 Host: localhost User-Agent: Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:60.0) Gecko/20100101 Firefox/60.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2 Accept-Encoding: gzip, deflate Referer: http://localhost/login.html Connection: keep-alive Upgrade-Insecure-Requests: 1 username=zhangsan 12345678910111213141516171819202122 ------ ### Request## JSTLJava Server Pages Tag Library----JSP标准标签库是由Apache免费提供的用于简化和替换jsp页面上的java代码使用步骤:1.导包2.引入标签库taglib指令&lt;%@ taglib %&gt;3.使用常用标签:if &#96;&#96;&#96;jsp&lt;%@taglib prefix&#x3D;&quot;c&quot; uri&#x3D;&quot;http:&#x2F;&#x2F;java.sun.com&#x2F;jsp&#x2F;jstl&#x2F;core&quot; %&gt;&lt;%--c:if--%&gt;&lt;%--test 必须属性,接收boolean表达式,如果为真显示标签的内容,false不显示一般这个属性值结合EL表达式使用--%&gt;choose 123456&lt;%--c:chooseswitch when __case otherwis default--%&gt; foreach 1234567891011121314151617&lt;%--c:foreach--%&gt;&lt;c:forEach begin&#x3D;&quot;0&quot; end&#x3D;&quot;10&quot; step&#x3D;&quot;1&quot; var&#x3D;&quot;i&quot; &gt;$&#123;i&#125;&lt;&#x2F;c:forEach&gt;&lt;% List list&#x3D;new ArrayList(); list.add(&quot;aaa&quot;); list.add(&quot;bbb&quot;); list.add(&quot;ccc&quot;); request.setAttribute(&quot;list&quot;, list);%&gt;&lt;c:forEach items&#x3D;&quot;$&#123;list&#125;&quot; varStatus&#x3D;&quot;s&quot; var&#x3D;&quot;str&quot;&gt;$&#123;s.count&#125;$&#123;s.index&#125;&lt;&#x2F;c:forEach&gt;","categories":[{"name":"Geek","slug":"Geek","permalink":"https://casuor.top/categories/Geek/"}],"tags":[]},{"title":"WIFI 傻瓜书(未完)","slug":"geek_Wifi傻瓜书","date":"2017-09-24T16:00:00.000Z","updated":"2020-10-28T09:58:54.880Z","comments":true,"path":"2017/09/25/geek_Wifi傻瓜书/","link":"","permalink":"https://casuor.top/2017/09/25/geek_Wifi%E5%82%BB%E7%93%9C%E4%B9%A6/","excerpt":"","text":"术语SSID 即Service Set Identifier,服务集标识符，一个唯一标识符，我们的无线客户端用它与接入点进行通信。SSID可以是任何字符，最大长度为32。 WAP 即wireless application protocol，无线应用协议，开放式标准协议，利用它可以把网络上的信息传递到移动电话或其他无线通讯终端上。WAP能够运行于各种无线网络之上，如GSM,GPRS,CDMA等.WML是无线标记语言（wireless makeup language）的英文缩写，支持WAP技术的手机能浏览由WML描述的Internet内容。 AP ACCESS POINT,无线访问点或无线接入点。无线客户端需要连接无线接入点才能获得登录外部互联网的能力，无线接入点可以是一座大型无线接入设备，也可以是一台小型无线路由器。由于在有的资料中会把WAP（wireless ap）WAP(wireless application protocol)概念混淆，所以在本书中 ，都将使用该简化词汇AP来指代无线接入点。 WEP wired equivalent privacy,市面上常用的无线网络认证机制之一，他是802.11定义下的一种加密方式。简单来说，就是先在无线AP中设定一组密码，使用者要连上这个无线AP时，必须输入相同的密码才能联机。 WPA wifi protected access,市面上常用的无线网络认证机制之一分为企业和个人两种。 EAP extensible authentication protocol(扩充认证协议），一种用于验证网络设备身份分鉴权机制。 WIFI-MESH 一种新型公共无线局域网和城域网解决方案，其网络结构类似于渔网，从一个点到另一个点有很多路可以走，这样即使有个别站点故障，仍可以保障较好的覆盖。 正文关于WEPWEP及其漏洞WEP的改进高位WEP 动态WEP WPA简介","categories":[{"name":"Geek","slug":"Geek","permalink":"https://casuor.top/categories/Geek/"}],"tags":[]},{"title":"我的社交论","slug":"think-社交","date":"2017-06-28T16:00:00.000Z","updated":"2020-10-28T09:58:54.892Z","comments":true,"path":"2017/06/29/think-社交/","link":"","permalink":"https://casuor.top/2017/06/29/think-%E7%A4%BE%E4%BA%A4/","excerpt":"","text":"固然，有时也对人生怀有恐怖感，这也是理所当然！ 只是我并不将它作为前提条件来加以承认。 我要百分百地发挥自己的能力，不达到极限绝不罢休。 想拿的就拿，不想拿的就不拿，就这样生存下去。 如果不行，到不行的时候再另行考虑。 反过来想，不公平的社会同时也是大有用武之地的社会。 在本质上我是只对自己感兴趣的人，自己想什莫，自己感受什么，自己如何行动——除此之外对别的没有兴趣，所以才能把自己同别人分开来考虑。 “我不希望别人理解自己。”“这点与其他人不同，那些家伙无不蝇营狗苟地设法让周围人理解自己。 但我不那样，而觉得不被人理解也无关紧要。自己是自己，别人归别人。 然而也并不认为不被任何人理解也无所谓，希望互相理解的对象也是有的。 只不过对除此之外的人，觉得在某种程度上即使不被人理解也无可奈何，这是不可强求的事。 额,以上这段话具体摘自谁的我已然记不得了,当然一看就是灰色系的日本小说 社交呢,有则更好,没有还行,要说社交,不是所有人你都想过去搭话的,有思想的动物很奇怪呢 当时呢,读这个小说,可能是我玩游戏最疯的时候,现在明白:时间会让你赶不上,所以学习 long life ,and proper game!","categories":[{"name":"Thinking","slug":"Thinking","permalink":"https://casuor.top/categories/Thinking/"}],"tags":[]}],"categories":[{"name":"Geek","slug":"Geek","permalink":"https://casuor.top/categories/Geek/"},{"name":"Resource","slug":"Resource","permalink":"https://casuor.top/categories/Resource/"},{"name":"Reading","slug":"Reading","permalink":"https://casuor.top/categories/Reading/"},{"name":"Transfer","slug":"Transfer","permalink":"https://casuor.top/categories/Transfer/"},{"name":"Live","slug":"Live","permalink":"https://casuor.top/categories/Live/"},{"name":"Thinking","slug":"Thinking","permalink":"https://casuor.top/categories/Thinking/"}],"tags":[{"name":"Picture","slug":"Picture","permalink":"https://casuor.top/tags/Picture/"},{"name":"Reading","slug":"Reading","permalink":"https://casuor.top/tags/Reading/"}]}