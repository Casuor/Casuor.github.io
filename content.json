{"meta":{"title":"Casuor","subtitle":"","description":"","author":"Casuor","url":"https://casuor.top","root":"/"},"pages":[{"title":"comment","date":"2018-12-20T15:13:48.000Z","updated":"2020-10-28T09:58:54.894Z","comments":true,"path":"comment/index.html","permalink":"https://casuor.top/comment/index.html","excerpt":"","text":"念两句诗 叙别梦、扬州一觉。 【宋代】吴文英《夜游宫·人去西楼雁杳》"},{"title":"about","date":"2018-12-12T14:14:36.000Z","updated":"2021-03-03T12:59:10.100Z","comments":false,"path":"about/index.html","permalink":"https://casuor.top/about/index.html","excerpt":"","text":"[关于] 生活态度 要比自由还自在 要比快乐更痛快 要比无邪还无害 要比放下放得开 生活目标 财务自由，佳人相伴 简约内向观察思考,数据主义,母胎单身,爱好女,处女座 不主动，不被动（两个人的事，都有兴趣才有故事）。不将就,不暧昧（泾渭分明） 世事繁杂，追求真我，爱我所爱 jay迷,会唱小部分 爱编程爱阅读 不羁俗世，随性而活"},{"title":"donate","date":"2018-12-20T15:13:05.000Z","updated":"2020-10-28T09:58:54.895Z","comments":false,"path":"donate/index.html","permalink":"https://casuor.top/donate/index.html","excerpt":"","text":""},{"title":"lab","date":"2019-01-05T13:47:59.000Z","updated":"2020-10-28T11:03:47.143Z","comments":false,"path":"lab/index.html","permalink":"https://casuor.top/lab/index.html","excerpt":"","text":"爷的盘 One Drive Google Drive"},{"title":"links","date":"2018-12-19T15:11:06.000Z","updated":"2020-10-28T09:58:54.896Z","comments":true,"path":"links/index.html","permalink":"https://casuor.top/links/index.html","excerpt":"","text":""},{"title":"rss","date":"2018-12-20T15:09:03.000Z","updated":"2020-10-28T09:58:54.896Z","comments":true,"path":"rss/index.html","permalink":"https://casuor.top/rss/index.html","excerpt":"","text":""},{"title":"theme-sakura","date":"2019-01-04T14:53:25.000Z","updated":"2020-10-28T09:58:54.898Z","comments":false,"path":"theme-sakura/index.html","permalink":"https://casuor.top/theme-sakura/index.html","excerpt":"","text":"Hexo主题Sakura修改自WordPress主题Sakura，感谢原作者Mashiro"},{"title":"Resource","date":"2018-12-12T14:14:16.000Z","updated":"2020-10-28T09:58:54.894Z","comments":true,"path":"categories/Resource/index.html","permalink":"https://casuor.top/categories/Resource/index.html","excerpt":"","text":""},{"title":"Resource","date":"2018-12-12T14:14:16.000Z","updated":"2020-10-28T09:58:54.894Z","comments":true,"path":"categories/Thinking/index.html","permalink":"https://casuor.top/categories/Thinking/index.html","excerpt":"","text":""},{"title":"Geek","date":"2018-12-12T14:14:16.000Z","updated":"2020-10-28T09:58:54.893Z","comments":true,"path":"categories/Geek/index.html","permalink":"https://casuor.top/categories/Geek/index.html","excerpt":"","text":""},{"title":"Live","date":"2018-12-12T14:14:16.000Z","updated":"2020-10-28T09:58:54.893Z","comments":true,"path":"categories/Live/index.html","permalink":"https://casuor.top/categories/Live/index.html","excerpt":"","text":""},{"title":"comment","date":"2018-12-20T15:13:48.000Z","updated":"2020-10-28T09:58:54.894Z","comments":true,"path":"categories/Transfer/index.html","permalink":"https://casuor.top/categories/Transfer/index.html","excerpt":"","text":"念两句诗 叙别梦、扬州一觉。 【宋代】吴文英《夜游宫·人去西楼雁杳》"},{"title":"bangumi","date":"2019-02-10T13:32:48.000Z","updated":"2020-10-28T09:58:54.897Z","comments":false,"path":"tags/Comic/index.html","permalink":"https://casuor.top/tags/Comic/index.html","excerpt":"","text":""},{"title":"music","date":"2018-12-20T15:14:28.000Z","updated":"2020-10-28T09:58:54.897Z","comments":false,"path":"tags/Music/index.html","permalink":"https://casuor.top/tags/Music/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-12-12T14:14:16.000Z","updated":"2020-10-28T09:58:54.897Z","comments":true,"path":"tags/Picture/index.html","permalink":"https://casuor.top/tags/Picture/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-12-12T14:14:16.000Z","updated":"2020-10-28T09:58:54.898Z","comments":true,"path":"tags/Reading/index.html","permalink":"https://casuor.top/tags/Reading/index.html","excerpt":"","text":""}],"posts":[{"title":"geek_python_go_nodejs_ruby命令对比","slug":"geek_python_go_nodejs_ruby命令对比","date":"2021-05-24T07:04:50.125Z","updated":"2021-05-24T07:27:20.819Z","comments":true,"path":"2021/05/24/geek_python_go_nodejs_ruby命令对比/","link":"","permalink":"https://casuor.top/2021/05/24/geek_python_go_nodejs_ruby%E5%91%BD%E4%BB%A4%E5%AF%B9%E6%AF%94/","excerpt":"","text":"item go python js ruby version go version python –version node –version ruby –version build go build python -m x.py run go run [x.go] python x.py node x.js 版本管理 pyenv [shell,local,global] n 或 nvm [use] 环境隔离 VenGo python -m venv npm i -[S,D] 第三方包管理 – pip npm,yarn gem,bundler version pip -V npm,yarn version gem,bundler –version config 列举 go env pip config list npm,yarn config list config 查看 ge env key pip config get key npm,yarn config get key config 配置 go env -w key=value pip config set key value npm,yarn config set key value config 配置 registry go env -w GOPROXY=… pip config set global.index-url … npm,yarn config get,set registry … gem sources 是否有公司 mirror 无 有 有 无 config 配置 prefix pip -V npm,yarn config get,set prefix config 配置 proxy 使用 shell proxy 使用公司 mirror 一定要去掉 proxy 使用公司 mirror 一定要去掉 proxy config 配置 cache 安装包(全局) go get … pip install xxx (默认全局) npm install -g xxx, yarn add -g xxx 安装包(本地) pip install –user xxx npm install xxx, yarn add xxx (默认本地) 查看已安装包 pip list npm list [-g -depth], yarn list 导出已安装包 pip freeze 删除包 npm uninstall xxx, yarn remove xxx 安装项目中所有包 pip install -r requirements.txt packages.json：npm install, yarn gemfile: bundler install 更新已安装包 npm update, yarn upgrade","categories":[],"tags":[]},{"title":"Wallhaven Spider","slug":"geek_netbianSpider","date":"2021-05-19T16:00:00.000Z","updated":"2021-05-26T05:52:50.191Z","comments":true,"path":"2021/05/20/geek_netbianSpider/","link":"","permalink":"https://casuor.top/2021/05/20/geek_netbianSpider/","excerpt":"","text":"import json import requests import re from itertools import compress import os # 请求函数 def request_get(url, ret_type=&quot;text&quot;, timeout=5, encoding=&quot;GBK&quot;): headers = { &quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/90.0.4430.93 Safari/537.36&quot; } res = requests.get(url=url, headers=headers, timeout=timeout) res.encoding = encoding if ret_type == &quot;text&quot;: return res.text elif ret_type == &quot;image&quot;: return res.content # 抓取函数 def main(): # 获取要下载的编号 down_type = get_download_type() image_type = get_imagetype() image_type = image_type[down_type] # 获取当前要下载的图片类型 print(image_type) # 获取下载总页数 page_count = get_pages(image_type) print(&quot;总页数是：&quot;, page_count) page_count = int(page_count) urls = [f&quot;http://www.netbian.com&quot; + image_type + &quot;index_&quot; + str(i) + &quot;.htm&quot; for i in range(2, page_count)] url = &quot;http://www.netbian.com&quot; + image_type + &quot;index.htm&quot; urls.insert(0, url) for url in urls: print(&quot;抓取列表页地址为：&quot;, url) text = request_get(url) # print(&apos;抓取函数：&apos;, text) format(text) # 解析函数 def format(text): origin_text = split_str(text, &apos;&lt;div class=&quot;list&quot;&gt;&apos;, &apos;&lt;div id=&quot;footer&quot;&gt;&apos;) # print(origin_text) pattern = re.compile(&apos;href=&quot;(.*?)&quot;&apos;) hrefs = pattern.findall(origin_text) hrefs = [i for i in hrefs if i.find(&quot;desk&quot;) &gt; 0] for href in hrefs: url = f&quot;http://www.netbian.com{href}&quot; print(f&quot;正在下载：{url}&quot;) text = request_get(url) # print(&quot;页面：&quot;, text) format_detail(text) # 获取总页数 def get_pages(image_type): url = &quot;http://www.netbian.com&quot; + image_type + &quot;index.htm&quot; print(url) text = request_get(url) origin_text = split_str(text, &apos;&lt;div class=&quot;list&quot;&gt;&apos;, &apos;&lt;div id=&quot;footer&quot;&gt;&apos;) pattern = re.compile(&apos;href=&quot;(.*?)&quot;&apos;) hrefs = pattern.findall(origin_text) select = [1, 1, -1, -1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, -1] selected = [n &gt; 0 for n in select] select_hrefs = list(compress(hrefs, selected)) # print(select_hrefs) total_page = select_hrefs[-2] total_page = re.findall(&apos;\\d+&apos;, total_page) print(total_page[0]) return total_page[0] # 初始化 def get_download_type(): key_list = [] val_list = [] image_type = [&apos;日历&apos;, &apos;动漫&apos;, &apos;风景&apos;, &apos;美女&apos;, &apos;游戏&apos;, &apos;影视&apos;, &apos;动态&apos;, &apos;唯美&apos;, &apos;设计&apos;, &apos;可爱&apos;, &apos;汽车&apos;, &apos;花卉&apos;, &apos;动物&apos;, &apos;节日&apos;, &apos;人物&apos;, &apos;美食&apos;, &apos;水果&apos;, &apos;建筑&apos;, &apos;体育&apos;, &apos;军事&apos;, &apos;非主流&apos;, &apos;其他&apos;, &apos;王者荣耀&apos;, &apos;护眼&apos;, &apos;英雄联盟&apos;] select = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24] selected = dict(zip(image_type, select)) print(json.dumps(selected, ensure_ascii=False, indent=4)) download_num = input(&quot;请选择要下载的类型：&quot;) for k, v in selected.items(): key_list.append(k) val_list.append(v) download_num = int(download_num) if download_num in val_list: val_index = val_list.index(int(download_num)) print(&quot;你选择要下载的类型是：&quot;, key_list[val_index]) return download_num # 获取image分类列表 def get_imagetype(): url = &apos;http://www.netbian.com/&apos; res_content = request_get(url) origin_text = split_str(res_content, &apos;&lt;div class=&quot;head&quot;&gt;&apos;, &apos;&lt;div class=&quot;search&quot;&gt;&apos;) pattern = re.compile(&apos;href=&quot;(.*?)&quot;&apos;) hrefs = pattern.findall(origin_text) # 第一次过滤：filter # 第二次过滤：切片 image_type_url = list(filter(lambda h: str(h).startswith(&apos;/&apos;), hrefs))[:-10] return image_type_url # index.htm切割 def split_str(text, s_html, e_html): start = text.find(s_html) + len(e_html) end = text.find(e_html) origin_text = text[start:end] return origin_text def format_detail(text): origin_text = split_str(text, &apos;&lt;div class=&quot;pic&quot;&gt;&apos;, &apos;&lt;div class=&quot;pic-down&quot;&gt;&apos;) # print(origin_text) pattern = re.compile(&apos;src=&quot;(.*?)&quot;&apos;) image_src = pattern.search(origin_text).group(1) print(&quot;图片源地址：&quot;, image_src) # 获取图片名称 pattern = re.compile(&apos;title=&quot;(.*?)&quot;&apos;) image_name = pattern.search(origin_text).group(1) # print(image_name, type(image_name)) # 保存图片 save_image(image_src, image_name) # 存储函数 def save_image(image_src, image_name): content = request_get(image_src, &quot;image&quot;) pwd = os.getcwd() filename = pwd + &apos;\\\\&apos; + &apos;Downloads&apos; if not os.path.exists(filename): os.makedirs(filename) else: print(&quot;目录已存在&quot;) with open(filename + &apos;\\\\&apos; + f&quot;{image_name}.jpg&quot;, &quot;wb&quot;) as f: f.write(content) print(&quot;图片保存成功&quot;) if __name__ == &apos;__main__&apos;: main()","categories":[{"name":"Geek","slug":"Geek","permalink":"https://casuor.top/categories/Geek/"}],"tags":[]},{"title":"设计相关（part）","slug":"res_designCollections","date":"2021-05-11T16:00:00.000Z","updated":"2021-05-12T14:30:27.806Z","comments":true,"path":"2021/05/12/res_designCollections/","link":"","permalink":"https://casuor.top/2021/05/12/res_designCollections/","excerpt":"","text":"设计相关部分合集工具集安卓 照片编辑器 图叨叨 Snapseed Retouch gif助手 LOFCam 泼辣修图 图简 拼图酱 PicsArt 色采 Windows Editor [Adobe全家桶](Windows10/Adobe - Taki - TAKI君的盘 (casuor.top)) Inkscape 取色器 Pipette GIF ScreenToGif 截图 Snipaste icon Pichon Web 字体相关 找字体_ZFont.Cn_找字体_免费字体_免费商用字体,中文字体下载_zfont.cn 手机字体下载大全,免费PS字体,手机软件下载,字体之家 - 更干净的字库下载站 (17ziti.com) 字体下载_PS字体下载_书法字体_毛笔字体_艺术字体-字体设计网_ziti.cndesign.com 100font.com - 免版权字体下载、免费商用字体下载网站 DaFont - Download fonts 找字网_免费字体下载、字体在线商用授权、ttf字体分享、专业字体网站！ (zhaozi.cn) 51Font -「免费字体发布平台」为您第一时间发布商用免费字体开源字体 (17font.com) 书法字体转换器在线转换-艺术字体在线生成器设计-第一字体网 (diyiziti.com) 灵感UI Dribbble - Discover the World’s Top Designers &amp; Creative Professionals GraphicRiver - Fonts, Logos &amp; Icons Unlimited UI Kits, Icons, Templates, Themes and More - UpLabs Premium &amp; Free Design and Web Resources | Pixeden TOPYS | 创意内容平台 OPEN YOUR MIND 优优灵感-设计师灵感展现与启发-优优教程网-UiiiUiii 花瓣网_陪你做生活的设计师（创意灵感天堂，搜索、发现设计灵感、设计素材） (huaban.com) 优设网 - UISDC - 设计师交流学习平台 - 看设计文章，学软件教程，找灵感素材，尽在优设网！ Logopond - Logo, Brand &amp; Identity Inspiration 素材图标 首页 - colorhub.me - 高清无版权图片，个人和商业用途免费 懒人图库 - 矢量图,JS代码,网页素材 - 学会偷懒，懒出境界！ (lanrentuku.com) PNG images | 100 000+ Free PNG images (pngimg.com) Fonts, Graphics, Themes and More | Creative Market 大美工-设计优选 - 大美工dameigong.cn 免费的 PSD、图形和矢量文件 - 365PSD.com Free &amp; Premium Design Resources — Medialoot Download Free Vector Art, Images, &amp; Vector Graphics (freevectors.net) 觅元素_设计元素的免费下载网站_免抠素材51yuansu.com The Stocks 2 - Best royalty free stock photos, videos, mockups, icons and fonts! 無料デザイン素材 アーカイブ - PhotoshopVIP Free Resources for Designers and Developers - Freebiesbug Download Free Vector Art, Stock Photos &amp; Stock Video Footage (vecteezy.com) 站酷海洛 - 正版图片,视频,字体,音乐素材交易平台 - 站酷旗下品牌 (hellorf.com) 昵图网_原创素材共享平台www.nipic.com 千图网-免费设计图片素材网站-正版图库免费设计素材中国 (58pic.com) 包图网_专注原创商用设计图片下载，会员免费设计素材模板独家图库 (ibaotu.com) iconfont-阿里巴巴矢量图标库 www.easyicon.net DryIcons.com — Icons and Vector Graphics Free vector icons - SVG, PSD, PNG, EPS &amp; Icon Font - Thousands of free icons (flaticon.com) Free icons by first-class designers | Iconstore CG爱好者网 - ae模板 | 3D模型下载 | ae模板免费下载 | AE素材 (cgahz.com) www.cgown.com 奇迹秀—因设计·而美丽 (qijishow.com) Pixiviz (pwp.app) 设计神器 微图云 · 在线图标组成神器，让图标云、照片墙设计更简单 (weitucloud.com) 图怪兽作图神器-在线图片编辑器-PS图片制作-搞定平面设计不求人 (818ps.com) 在线PS处理图片,在线图片编辑器,在线美图秀秀,PS软件网页版,在线抠图,PS精简版-photoeditora.com 消除图片中的背景 – remove.bg TinyPNG – Compress PNG images while preserving transparency Image-to-Image Demo - Affine Layer 高清图库 拍信（PAIXIN.COM）- 中国领先的创意内容素材平台 VisualHunt 2.3 million+ Stunning Free Images to Use Anywhere - Pixabay VCG.COM - 正版商业图片_视频_音乐素材交易平台-视觉中国旗下网站 邑石网_正版图片_字体_音乐_插画_专业的正版视觉内容提供商 (yestone.com) 123rf免版税图像库 - 高质量图像无限下载 Beautiful Free Images &amp; Pictures | Unsplash 免费素材图片 · Pexels 探索 300,000 多张免费素材和免版税图像 - FreeImages.com Картинки и фотографии высокого качества | Free Stock Images GIPHY - Be Animated 摄影美图 时尚网-潮品格 新时尚 (trends.com.cn) PHOTO, site officiel du magazine 高清壁纸 Awesome Wallpapers - wallhaven.cc High Quality Wallpapers, Desktop Backgrounds, Widescreen Wallpapers - WallpaperMaiden Most inspiring and awesome desktop wallpapers - Wallls.com https://wall.alphacoders.com/","categories":[{"name":"Resource","slug":"Resource","permalink":"https://casuor.top/categories/Resource/"}],"tags":[]},{"title":"Powershell脚本学习(未完)","slug":"geek_pwsh","date":"2020-12-14T16:00:00.000Z","updated":"2021-03-16T10:36:52.423Z","comments":true,"path":"2020/12/15/geek_pwsh/","link":"","permalink":"https://casuor.top/2020/12/15/geek_pwsh/","excerpt":"","text":"Powershell脚本学习PowerShell 版本1$PSVersionTable Windows PowerShell ISE PowerShell 基本命令123456789101112131415161718192021222324252627282930313233#powershell版本$PSVersionTable#本地模块get-module -ListAvailable#问：只知道命令的一部分，如何查找命令？get-command *service*#获取帮助Get-Help#更新帮助update-help#获取更新列表Get-HotFixGet-Command#获取命令示例help Get-EventLog -Examples#访问关于主题help(man) *common*help about*#访问在线帮助help Get-Alias -Online#参数详解 #参数集和通用参数 #可选和必选参数 #位置参数#8个通用参数-Verbose-Debug-WarningAction-WarningVariable-ErrorAction-ErrorVariable-OutVariable-OutBuffer cmdletcmdlet 或 Command let 是 Windows PowerShell 环境中使用的轻量级命令。Windows PowerShell 运行时在命令提示符下调用这些 cmdlet。你可以通过 Windows PowerShell API 以编程方式创建和调用它们。 Cmdlet vs CommandCmdlet 与其他命令 shell 环境中的命令有以下不同的方式 Cmdlet 是.NET Framework 类对象; 而不仅仅是独立的可执行文件。 只需十几行代码即可轻松构建 Cmdlet。 cmdlet 不处理解析，错误呈现和输出格式。它由 Windows PowerShell 运行时完成。 Cmdlet 进程适用于不在文本流上的对象，对象可以作为输出进行流水线操作。 Cmdlet 是基于记录的，因为它们一次处理单个对象。 安装PowerShellGet12345678910#PowerShell 6及以上安装 PowerShellGetInstall-Module -Name PowerShellGet -Force#Powershell-Get download problem[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12 #WARNING: The version '1.4.6' of module 'PackageManagement' is currently in use. Retry the operation after closing the applicationsGet-Module -ListAvailable PowerShellGet#如下图#更新Update-Module -Name PowerShellGetExit 习题1 运行Update-Help 哪一个Cmdlet命令能够把其他Cmdlet命令输出的内容转化为HTML? 哪一个Cmdlet命令可以重定向输出到一个file或者打印机？ 哪一个Cmdlet命令可以操作进程（processes）? 哪一个Cmdlet命令可以向事件日志写入数据？ 创建修改导入别名（aliases）? 怎么保证你在shell中的输入都在一个脚本（transcript）中，怎么保存这个脚本到一个文本文件中？ 怎么只获取最近的100条安全事件日志记录？ 是否有办法可以获取一个远程计算机上安装的服务（services）列表？ 是否有办法看到一个远程计算机运行了什么进程？ 尝试查看Out-File这个Cmdlet命令的帮助文档》通过该Cmdlet命令输出到文件每一行记录的默认宽度大小是多少字符？是否有一个参数可以让你修改这个宽度？ 在默认情况下，Out-File将覆盖任何已经存在具有相同的文件名。是否有一个参数可以预防Cmdlet命令覆盖现有文件？ 如何查看在powershell中预先定义所有别名列表？ 怎么使用别名和缩写的参数名称来写一条最短的命令从而能检索出一台成为Server1的计算机正在运行的进程列表？ 有多少Cmdlet命令可以处理普通对象？ 哪一个帮助主题可以告诉你关于数组（arrays）的更多信息？ 答案1123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#1Update-Help#2help htmlman htmlGet-Command -noun htmlgcm -noun html#3gcm -Noun File,Printer#4gcm -Noun Processhelp *Process#5gcm -Verb write -Noun EventLoggcm -Verb \"\" -Noun EventLoghelp *log#6help *aliasgcm -Noun alias#7help transcript#8help Get-EventLog -Parameter NewestGet-EventLog -LogName Security -Newest 100#9help Get-Service -Parameter computername#NetBIOS name,IP address,fully qualified domain name#computer name/a dot ./localhost/\"127.0.0.1\"Get-Service -ComputerName \"127.0.0.1\"#10help Get-Process -Parameter computernameGet-Process -ComputerName .#11man Out-File -OnlineHelp Out-File –parameter Width#12help Out-File -Parameter NoClobber#13Get-Alias#14#旧版会有computername参数如下图，pwsh7没有此参数Function cname &#123;set-alias -confirm computername -value c&#125;ps -c Server1#15get-command –noun object #noun 包含指定名词#16help about_arrayshelp *array* 命令剖析一个命令 Cmdlet命名惯例 Cmdlet是一个 原生的powershell命令行工具。该术语仅仅存在于powershell和类似c#的.net framework语言中。Cmdlet仅仅出现在powershell中。 函数和Cmdlet类似，但不是以.net语言编写，而是以powershell自己的脚本语言编写。 工作流是嵌入powershell的工作流执行系统的一类特殊函数。 应用程序是任意类型的外部可执行程序，包括类似ping,ipconfig等命令行工具。 命令是一个通用的术语，用于代表任何或所有上面提到的术语。 规则应该以标准的动词开始，比如Get、Set、New或Pause。你可以运行Get-Verb查看允许使用的动词列表（虽然只有少部分是常用的，但你大概会看到100个左右）。在动词之后紧接着一个破折号，然后是一个单数形式的名词，比如Service或Process或EventLog。由于PowerShell允许开发人员自己命名名词，因此并没有一个“Get-Noun”的Cmdlet来显示所有名词。 这个规则的妙处在哪里？假设我们告诉你如下几个Cmdlet名称：New-Service、Get-Service、Get-Process、Set-Service等。你是否能够猜出哪一个命令可以创建一个新的Exchange邮箱？哪一个命令可以修改活动目录用户？如果你猜是“Get-Mailbox”，那么第一个就猜对了。如果你猜“Set-User”，那么第二个就非常接近了。实际上是Set-ADUser，你可以在活动目录模块的域控制器中找到该用户。重点是，通过一致的命名规则以及有限的动词集合，猜测命令名称变为可能，在此之后才是使用帮助或“Get-Command”加通配符验证猜想。估计你所需要的命令名称会变得更加简单，而无须每次都去搜索Google或Bing。 别名：命令的昵称 获取别名 1Get-Alias -Definition \"Get-Service\" 参数名称的别名 1234567#computername太长Get-EventLog -ComputerName \"canary\" -LogName 'Windows PowerShell'#获取命令get-eventlog 扩展属性参数computername的别名(gcm Get-EventLog | select -ExpandProperty parameters).computername.aliases#结果： Cn#新写法Get-EventLog -Cn \"canary\" -LogName 'Windows PowerShell' 位置参数 123456help get-childitem -full#其中-path,-filter为位置参数#Position? 1#对于位置参数来说，你无须输入参数名 称——仅需要在正确的位置提供参数值，例如： gi C:\\Users gi -path C:\\Users 位置参数的一个弊端是你必须记住每一个位置所代表的参数。你还必须首先按照正确的顺序输入位置参数，然后才能输入命名（非位置）参数。如果你将位置参数的顺序搞混，命令则会失败。对于你可能已经使用多年的简单DIR命令来说，如果提供-Path参数将会变得很怪异，没有人会这么做。但对于更复杂的命令来说，比如一行包含3至4个位置参数的命令，将难以记住每一个位置所代表的参数。 比如说： 1move file.txt users\\donjones\\ 1move -Path c:\\file.txt -Destination \\users\\donjones\\ 1move -Destination \\users\\donjones\\ -Path c:\\file.txt Show-Command 该命令允许你指定你无法用对的命令名称，并以图形化的方式将命令的参数名称展示出来。 练习2使用提供程序 什么是提供程序 一个PowerShell的提供程序，或者说PSProvider，其本质上是一个适配器。它可以接受某些数据存储，并使得这些介质看起来像是磁盘驱动器一样。你可以通过下面的命令查看当前Shell中已经存在的提供程序。 1Get-PSProvider 下面是常见的一些功能描述。 ShouldProcess——这部分提供程序支持-WhatIf和-Confirm参数，保证我们在正式执行这部分脚本之前可以对它们进行测试。 Filter——在Cmdlet中提供程序的数据时，支持-Filter参数 Credentials——该提供程序允许使用可变更的凭据连接数据存储。这也就是-Credentials参数的作用。 Transactions——该提供程序支持事务，也就是允许你在该提供程序中将多个变更作为一个原子操作进行提交或者全部回滚。 你也可以使用某个提供程序创建一个PSDrive。PSDrive可以通过一个特定的提供程序连接到某些存储数据的介质。这和在Windows资源管理器中类似，本质上是创建了一个驱动器映射。但是由于PSDrive使用了提供程序，除了可以连接磁盘之外，还能连接更多的数据存储介质。运行下面的命令，可以看到当前已连接的驱动器。 1Get-PSDrive 在上面返回的列表中，可以看到有3个驱动器使用了FileSystem提供程序，两个使用了Registry提供程序，等等。PSProvider会适配对应的数据存储，通过PSDrive机制使得数据存储可被访问，然后可以使用一系列Cmdlets去查阅或者操作每个PSDrive呈现出来的数据。大多数情况下，操作PSDrive的cmdlet名词部分都会包含“Item”。 我们将在系统中使用上述Cmdlet或者它们的别名来调用提供程序。或许对你而言，文件系统应该算是最熟悉的提供程序了，所以我们将会从文件系统PSProvider开始学习。 FileSystem的结构组成对象 磁盘驱动器 文件夹 文件 磁盘驱动器是最上层的对象，包含文件夹和文件。文件夹是一种容器对象，它可以包含文件以及其他文件夹。文件不是一种容器对象，该对象处于层级的末尾。 PowerShell中的术语和文件系统中的略有不同。因为PSDrive可能不是指向某个文件系统——比如PSDrive可以映射到注册表（显然注册表并不是一种文件系统），所以PowerShell并不会使用“文件”以及“文件夹”的说法。相反，PowerShell采用更通俗的说法——“项”（Item）。一个文件或者一个文件夹都叫作项，尽管本质上是两种不同的项。这也就是为什么前面返回的Cmdlet名字中都有“Item”字符。 每个项基本上都会存在对应的属性。比如，一个文件项可能有最后写入的时间、是否只读等属性。一些项，比如文件夹，可能包含子项（子项包含在文件夹项中）。 比如Clear、Copy、Get、Move、New、Remove、Rename以及Set等动词可以应用于这些项（比如文件或者文件夹）以及它们对应的属性（比如该项最后写入的时间或者该项是否只读）。 Item名词对应的是单独对象，比如文件夹或文件。 ItemProperty代表 一个项对应的属性。比如只读，项目创建时间，长度等。 childItem名词对应一个项包含于另一个项中。 需要记住的是，这些Cmdlet都是通用的，因为它们需要处理各种不同的数据源。但是某些Cmdlet在某些特定场合下不一定能正常工作。比如，FileSystem提供程序不支持事务，所以文件系统驱动器下的Cmdlet中的命令都不支持-UseTransaction参数。再比如，注册表不支持Filter功能，所以注册表驱动器下的Cmdlet也都不支持-Filter参数。 某些PSProvider并不具有对应的项属性。比如，Environment这个PSProvider主要用来构造PowerShell中可用的ENV：类型驱动器（如Env:\\PSModulePath）。该驱动器主要的作用是访问Windows中的环境变量，但是如下所示，它并没有对应的项属性。 1Get-ItemProperty -Path Env:\\PSModulePath 文件系统可以算作其他数据存储的模板。例如，图5.2展示了Windows注册表的结构。 注册表以类似文件系统的结构呈现，其中注册表的键等同于文件系统中的文件夹，对应的键值类似于文件系统中的文件，等等。正是这种广泛的相似性，使得文件系统成为其他形式数据源的最佳模板。所以当用PowerShell访问其他数据存储的时候，显示为驱动器的形式（可以依次展开为项以及查看对应的属性）。但是相似性到这一层级也就结束了：如果你再继续向下展开，那么你会发现不同形式的存储其实差别很大。这也就是为什么各种项的Cmdlet支持如此多的功能，但是并不是每个功能在每种存储中都能运行。 使用文件系统123cd ~ni folder [-Type](Directory)md folder 使用通配符与字面路径 大部分项的Cmdlet都包含了-Path属性。默认情况下，该属性支持通配符输入。比如，我们查看Get-ChildItem的完整帮助文档，如下所示。 1Get-Help gi -Full “*”通配符代表0个或者多个字符，“?”通配符仅代表单个字符。 12get-childitemdir “*”和“?”比较特殊，它们是通配符，所以在文件或者文件夹的名称中不允许带有“”或者“?”字符。但是在PowerShell中，并不仅仅支持文件系统格式的数据存储。在大部分其他类型的数据存储中，“”和“?”都可以包含在Item的名称中。比如，在注册表中，你可以看到一些项的名称中包含“?”字符。你应该发现了，这将导致一个问题。当在一个路径中使用了“*”或者“?”，PowerShell会如何对待，是作为一个通配符还是一个特定的字符？比如，如果你输入Windows?来寻找某个项，你到底是想寻找名称为Windows?的项，还是将“?”看成一个通配符，然后返回Windows 7或者是Windows 8的值。 针对此问题，PowerShell给出的解决办法是新增一个参数-LiteralPath。该参数并不支持通配符。 如果需要查询名字中带有或者?，就要使用-LiteralPath参数，而不要使用-Path。需要注意的是，-LiteralPath这个参数不可隐式赋予。如果确定需要使用该参数，必须显式申明-LiteralPath参数。如果你在一开始就提供了路径，如我们前面例子所示的.exe，那么它会被隐式转化为-Path参数，通配符也是如此。 demo-关闭Windows中的桌面透明特性 1234cd HKCU:cd .\\Softwarecd .\\Microsoftcd .\\Windows 12Set-ItemProperty -Path DWM -Name EnableWindowColorization -Value 0ls 练习3连接命令PowerShell通过管道（pipeline）把命令互相连接起来。管道通过传输一个命令，把其输出作为另外一个Cmdlet的输入，使得第二个命令可以通过第一个的结果作为输入并联合起来运行。 1234567891011121314151617#管道输出到csV文件ps | export-csv pr.csv#读取import pr.csv#管道输出到xml文件ps | Export-Clixml pc.xmlgc -verbGet-Command -Verb importGet-Command -Verb export#对比csv与xmlcompare-object diffhelp diffps | export-CliXML reference.xmldiff -ReferenceObject (Import-Clixml reference.xml) -DifferenceObject (Get-Process) -Property Name 在数学层面上，括号在PowerShell中用于控制执行的顺序。在前面的例子中，强制“Import-CliXML”和“Get-Process”先于“Diff”运行。接着从“Import-CLI”得到的结果被送到“-reference”参数中，而“Get-Process”的结果被送到“-difference”参数中。参数名称实际上是“-referenceObject”和“-differenceObject”，在这里你可以提供足够Shell用于识别参数的缩写名称即可。也就是本例中的“-reference”和“-difference”已经足够唯一标识这两个参数了。即使我们把这两个参数缩短到“-ref”和“-diff”，命令也依旧能运行。 相对于匹配两个完整的表格，Diff更加关注“Name”列，所以例子中使用了“-property”这个参数。如果我们不这样定义，结果将全部有差异，因为如“VM”“CPU”和“PM”这些列的值都不一样，结果集会被认为有差异。 匹配结果将以表格形式展示，对于存在于参照结果集但是不存在于差异结果集的数据，会用“&lt;=”标识符表示。对于存在于差异结果集但是不存在于参照结果集的数据，会用“=&gt;”标识符表示。而两者均存在的，则不会出现在“Diff”输出的结果中。 管道传输到文件或打印机1Dir &gt; DirectoryList.txt 其中“&gt;”符是PowerShell向后兼容旧版本cmd.exe命令的一个快捷方式。而实际上，当运行这个命令时，PowerShell底层会以下面的方式实现。 1Dir | Out-File DirectoryList.txt 。“Out-File”提供了一些参数让你定制替代的字符编码（如UTF8或Unicode）、追加内容到现有文件等功能。默认情况下，用“Out-File”创建的文件有80列宽，意味着有时候使用PowerShell需要修改命令的输出，以便适应这80列的限制 Reference安装 PowerShellGet - PowerShell | Microsoft Docs What is NetBIOS?","categories":[{"name":"Geek","slug":"Geek","permalink":"https://casuor.top/categories/Geek/"}],"tags":[]},{"title":"terminal conf","slug":"geek_color scheme","date":"2020-12-10T16:00:00.000Z","updated":"2021-03-03T13:30:10.852Z","comments":true,"path":"2020/12/11/geek_color scheme/","link":"","permalink":"https://casuor.top/2020/12/11/geek_color%20scheme/","excerpt":"","text":"ColorScheme-仿制Solarized (Dark){ &quot;name&quot;: &quot;CasuorDark&quot;, &quot;black&quot;: &quot;#002731&quot;, &quot;red&quot;: &quot;#EB4B3D&quot;, &quot;green&quot;: &quot;#05E177&quot;, &quot;yellow&quot;: &quot;#EDC87D&quot;, &quot;blue&quot;: &quot;#1498eb&quot;, &quot;purple&quot;: &quot;#B57EDC&quot;, &quot;cyan&quot;: &quot;#25c5b8&quot;, &quot;white&quot;: &quot;#9DA4B0&quot;, &quot;brightBlack&quot;: &quot;#CCCCCC&quot;, &quot;brightRed&quot;: &quot;#FF5F56&quot;, &quot;brightGreen&quot;: &quot;#788E05&quot;, &quot;brightYellow&quot;: &quot;#FFBD2E&quot;, &quot;brightBlue&quot;: &quot;#00BBFF&quot;, &quot;brightPurple&quot;: &quot;#EE82EE&quot;, &quot;brightCyan&quot;: &quot;#00FFFF&quot;, &quot;brightWhite&quot;: &quot;#C2616A&quot;, &quot;background&quot;: &quot;#00313f&quot;, &quot;foreground&quot;: &quot;#008080&quot;, &quot;selectionBackground&quot;: &quot;#93A1A1&quot;, &quot;cursorColor&quot;: &quot;#FF5F56&quot; }Oh-my-posh3 themes self{ &quot;$schema&quot;: &quot;https://raw.githubusercontent.com/JanDeDobbeleer/oh-my-posh3/main/themes/schema.json&quot;, &quot;blocks&quot;: [ { &quot;type&quot;: &quot;prompt&quot;, &quot;alignment&quot;: &quot;left&quot;, &quot;segments&quot;: [ // { // &quot;type&quot;: &quot;text&quot;, // &quot;style&quot;: &quot;plain&quot;, // &quot;foreground&quot;: &quot;#ffffff&quot;, // &quot;properties&quot;: { // &quot;prefix&quot;: &quot;&quot;, // &quot;text&quot;: &quot;&lt;#C591E8&gt;\\u276F&lt;/&gt;&lt;#69FF94&gt;\\u276F&lt;/&gt;&quot; // } // }, { &quot;type&quot;: &quot;os&quot;, &quot;style&quot;: &quot;powerline&quot;, &quot;powerline_symbol&quot;: &quot;\\uE0B0&quot;, &quot;foreground&quot;: &quot;#ffffff&quot;, &quot;background&quot;: &quot;#f35325&quot;, &quot;properties&quot;: { &quot;alpine&quot;: &quot;\\uf300&quot;, &quot;arch&quot;: &quot;\\uf303&quot;, &quot;centos&quot;: &quot;\\uf304&quot;, &quot;debian&quot;: &quot;\\uf306&quot;, &quot;elementary&quot;: &quot;\\uf309&quot;, &quot;fedora&quot;: &quot;\\uf30a&quot;, &quot;gentoo&quot;: &quot;\\uf30d&quot;, &quot;linux&quot;: &quot;\\ue712&quot;, &quot;macos&quot;: &quot;\\ue711&quot;, &quot;manjaro&quot;: &quot;\\uf312&quot;, &quot;mint&quot;: &quot;\\uf30f&quot;, &quot;opensuse&quot;: &quot;\\uf314&quot;, &quot;raspbian&quot;: &quot;\\uf315&quot;, &quot;ubuntu&quot;: &quot;\\uf31c&quot;, &quot;wsl&quot;: &quot;\\ue712&quot;, &quot;wsl_separator&quot;: &quot; on &quot;, &quot;windows&quot;: &quot;\\ue70f&quot; } }, { &quot;type&quot;: &quot;time&quot;, &quot;style&quot;: &quot;powerline&quot;, &quot;powerline_symbol&quot;: &quot;\\uE0B0&quot;, &quot;foreground&quot;: &quot;#5a4cab&quot;, &quot;background&quot;: &quot;#ffba08&quot;, &quot;properties&quot;: { &quot;time_format&quot;: &quot;15:04:05&quot;, &quot;postfix&quot;: &quot; \\uF017 &quot; } }, { &quot;type&quot;: &quot;path&quot;, &quot;style&quot;: &quot;powerline&quot;, &quot;powerline_symbol&quot;: &quot;\\uE0B0&quot;, &quot;foreground&quot;: &quot;#ffffff&quot;, &quot;background&quot;: &quot;#FF479C&quot;, &quot;properties&quot;: { &quot;prefix&quot;: &quot; \\uE5FF &quot;, &quot;home_icon&quot;: &quot;\\uF7DB&quot;, &quot;folder_icon&quot;: &quot;\\uF115&quot;, &quot;folder_separator_icon&quot;: &quot; \\uE0B0 &quot;, &quot;style&quot;: &quot;agnoster&quot; } }, { &quot;type&quot;: &quot;git&quot;, &quot;style&quot;: &quot;powerline&quot;, &quot;powerline_symbol&quot;: &quot;\\uE0B0&quot;, &quot;foreground&quot;: &quot;#193549&quot;, &quot;background&quot;: &quot;#fffb38&quot;, &quot;properties&quot;: { &quot;display_stash_count&quot;: true, &quot;display_upstream_icon&quot;: true } }, { &quot;type&quot;: &quot;battery&quot;, &quot;style&quot;: &quot;powerline&quot;, &quot;powerline_symbol&quot;: &quot;\\uE0B0&quot;, &quot;foreground&quot;: &quot;#193549&quot;, &quot;background&quot;: &quot;#F36943&quot;, &quot;properties&quot;: { &quot;battery_icon&quot;: &quot;&quot;, &quot;charged_icon&quot;: &quot;\\uE22F &quot;, &quot;charging_icon&quot;: &quot;\\uE234 &quot;, &quot;discharging_icon&quot;: &quot;\\uE231 &quot;, &quot;color_background&quot;: true, &quot;charged_color&quot;: &quot;#4caf50&quot;, &quot;charging_color&quot;: &quot;#FF479C&quot;, &quot;discharging_color&quot;: &quot;#ff5722&quot;, &quot;postfix&quot;: &quot;\\uF295 &quot;, &quot;display_charging&quot;: true } }, { &quot;type&quot;: &quot;node&quot;, &quot;style&quot;: &quot;powerline&quot;, &quot;powerline_symbol&quot;: &quot;\\uE0B0&quot;, &quot;foreground&quot;: &quot;#ffffff&quot;, &quot;background&quot;: &quot;#6CA35E&quot;, &quot;properties&quot;: { &quot;prefix&quot;: &quot; \\uE718 &quot; } }, { &quot;type&quot;: &quot;shell&quot;, &quot;style&quot;: &quot;powerline&quot;, &quot;powerline_symbol&quot;: &quot;\\uE0B0&quot;, &quot;foreground&quot;: &quot;#ffffff&quot;, &quot;background&quot;: &quot;#0077c2&quot;, &quot;properties&quot;: { &quot;prefix&quot;: &quot; \\uFCB5 &quot; } }, { &quot;type&quot;: &quot;root&quot;, &quot;style&quot;: &quot;powerline&quot;, &quot;powerline_symbol&quot;: &quot;\\uE0B0&quot;, &quot;foreground&quot;: &quot;#193549&quot;, &quot;background&quot;: &quot;#ffff66&quot; }, { &quot;type&quot;: &quot;exit&quot;, &quot;style&quot;: &quot;powerline&quot;, &quot;powerline_symbol&quot;: &quot;\\uE0B0&quot;, &quot;foreground&quot;: &quot;#ffffff&quot;, &quot;background&quot;: &quot;#ff8080&quot; } ] } ], &quot;final_space&quot;: true }","categories":[{"name":"Geek","slug":"Geek","permalink":"https://casuor.top/categories/Geek/"}],"tags":[]},{"title":"Megumi","slug":"pic_megumi","date":"2020-10-27T16:00:00.000Z","updated":"2020-10-29T13:01:41.921Z","comments":true,"path":"2020/10/28/pic_megumi/","link":"","permalink":"https://casuor.top/2020/10/28/pic_megumi/","excerpt":"","text":"直链下载","categories":[],"tags":[{"name":"Picture","slug":"Picture","permalink":"https://casuor.top/tags/Picture/"}]},{"title":"Onemanager Custom domain","slug":"geek_odcustomuri","date":"2020-09-13T16:00:00.000Z","updated":"2020-10-30T08:06:39.639Z","comments":true,"path":"2020/09/14/geek_odcustomuri/","link":"","permalink":"https://casuor.top/2020/09/14/geek_odcustomuri/","excerpt":"","text":"Onemanager &amp; Cloudflare自定义域名 OneManager 用的Tencent的云函数 原地址：https://service-ovx4zkhy-1258833316.hk.apigw.tencentcs.com/release/Aki/ 更改后：https://onedrive.casuor.top/release/Aki二改： https://onedrive.casuor.top/problem:还不是很方便，解决方法就是在Worker里动手(拼接url)，ES6不懂 start 创建Worker addEventListener( &quot;fetch&quot;,event =&gt; { let url=new URL(event.request.url); url.hostname=&quot;service-ovx4zkhy-1258833316.hk.apigw.tencentcs.com&quot;;//填字记的 let request=new Request(url+&quot;release/Aki/&quot;,event.request); event. respondWith( fetch(request) ) } ) 更新后addEventListener( &quot;fetch&quot;,event =&gt; { let url=new URL(event.request.url); url.hostname=&quot;service-ovx4zkhy-1258833316.hk.apigw.tencentcs.com&quot;; let path1=url.pathname.split(&apos;/&apos;)[1]; let path2=url.pathname.split(&apos;/&apos;)[2]; let request; if(path1==&apos;release&apos;&amp;&amp;path2==&apos;Aki&apos;){ request= new Request(url,event.request); }else{ request= new Request(url+&quot;release/Aki/&quot;,event.request); } event. respondWith( fetch(request) ) } ) 设置CNAME 添加路由 ###PS: CNAME里填哪个url都ok referencehttps://www.nbmao.com/archives/4014","categories":[{"name":"Geek","slug":"Geek","permalink":"https://casuor.top/categories/Geek/"}],"tags":[]},{"title":"LOL Leesin","slug":"pic_leesin","date":"2020-08-05T16:00:00.000Z","updated":"2020-10-28T09:58:54.888Z","comments":true,"path":"2020/08/06/pic_leesin/","link":"","permalink":"https://casuor.top/2020/08/06/pic_leesin/","excerpt":"","text":"","categories":[],"tags":[{"name":"Picture","slug":"Picture","permalink":"https://casuor.top/tags/Picture/"}]},{"title":"LOL Yasuo","slug":"pic_yasuo","date":"2020-08-05T16:00:00.000Z","updated":"2020-10-28T09:58:54.888Z","comments":true,"path":"2020/08/06/pic_yasuo/","link":"","permalink":"https://casuor.top/2020/08/06/pic_yasuo/","excerpt":"","text":"","categories":[],"tags":[{"name":"Picture","slug":"Picture","permalink":"https://casuor.top/tags/Picture/"}]},{"title":"Pride 2020 conversations","slug":"pic_pride2020conversations","date":"2020-08-02T16:00:00.000Z","updated":"2020-10-28T09:58:54.888Z","comments":true,"path":"2020/08/03/pic_pride2020conversations/","link":"","permalink":"https://casuor.top/2020/08/03/pic_pride2020conversations/","excerpt":"","text":"","categories":[],"tags":[{"name":"Picture","slug":"Picture","permalink":"https://casuor.top/tags/Picture/"}]},{"title":"Pride 2020 flags","slug":"pic_pride2020flags","date":"2020-08-02T16:00:00.000Z","updated":"2020-10-28T09:58:54.888Z","comments":true,"path":"2020/08/03/pic_pride2020flags/","link":"","permalink":"https://casuor.top/2020/08/03/pic_pride2020flags/","excerpt":"","text":"","categories":[],"tags":[{"name":"Picture","slug":"Picture","permalink":"https://casuor.top/tags/Picture/"}]},{"title":"未来简史-尤瓦尔·赫拉利","slug":"reading-未来简史","date":"2020-06-19T16:00:00.000Z","updated":"2020-10-28T09:58:54.889Z","comments":true,"path":"2020/06/20/reading-未来简史/","link":"","permalink":"https://casuor.top/2020/06/20/reading-%E6%9C%AA%E6%9D%A5%E7%AE%80%E5%8F%B2/","excerpt":"","text":"What is Dataism?wikipedia reference 尤瓦尔·诺亚·赫拉利（Yuval Noah Harari）在畅销书《 人类简史：未来简史》（2016）–第9章“数据宗教”中介绍了数据主义的迷人概念，并预见了它作为一种宗教的兴起。 首先，他声称： “数据主义说，宇宙由数据流组成，任何现象或实体的价值取决于其对数据处理的贡献” 首先，他解释了数据专家的观点： 从数据论者的角度来看，我们可以将整个人类解释为一个单一的数据处理系统，而每个人都是其处理芯片。如果是这样，我们还可以通过四种基本方法将整个历史理解为提高该系统效率的过程： 增加处理器数量。拥有10万人口的城市比拥有1000人的村庄拥有更多的计算能力。 增加处理器的种类。不同的处理器可以使用多种方式来计算和分析数据。因此，在单个系统中使用几种处理器可能会增加其动态性和创造力。农民，牧师和医生之间的对话可能会产生新颖的想法，而这在三个狩猎采集者之间的对话中永远不会出现。 增加处理器之间的连接数。如果处理器之间的连接不良，那么仅仅增加处理器的数量和种类就毫无意义。连接十个城市的贸易网络比十个孤立的城市可能带来更多的经济，技术和社会创新。 增加沿现有连接的移动自由度。如果数据不能自由流动，则连接处理器几乎没有用。如果十个城市之间的道路被强盗困扰，或者某些专制的专制制度不允许商人和旅行者按自己的意愿行进，那么修建道路就不会很有用。 到目前为止，有一个合理的，以效率为导向的观点，某种程度上是机械的。然后，他解释了目的： 如果人类确实是一个单一的数据处理系统，其输出是什么？创建了一个全新的，效率更高的数据处理系统，称为万物互联。一旦完成此任务，智人将消失。 因此，例如 资本主义之所以没有击败共产主义，是因为资本主义更具道德性，因为个人自由是神圣的，或者是因为上帝对异教徒感到愤怒。相反，资本主义赢得了冷战，因为至少在加速技术变革的时期，分布式数据处理比集中式数据处理更好。 赫拉利认为，数据主义可能成为一种宗教： 像资本主义一样，数据主义也起初是一种中立的科学理论，但现在正演变成一种声称确定对与错的宗教。这种新宗教的最高价值是“信息流”。如果生命是信息的运动，并且我们认为生命是美好的，那么我们就应该扩展，深化和传播宇宙中的信息流。根据数据论，人类的经验不是神圣的，智人不是创造的顶点，也不是未来某些人类的先驱。人类仅仅是创建万物互联的工具最终可能会从地球上散布开来，覆盖整个银河系甚至整个宇宙。这个宇宙数据处理系统就像上帝。它将无处不在，并将控制一切，人类注定要融入其中。 然后，它陈述了两个主要诫命： 首先，最重要的是，数据专家应该通过连接到越来越多的媒体，以及产生和使用越来越多的信息来最大化数据流。像其他成功的宗教一样，数据主义也是传教士。它的第二条诫命是将所有内容连接到系统，包括不想连接的异端。而且“一切”不仅仅意味着人类。这意味着一切。 因此，他认为： 然后，它陈述了两个主要诫命：​ 首先，最重要的是，数据专家应该通过连接到越来越多的媒体，以及产生和使用越来越多的信息来最大化数据流。像其他成功的宗教一样，数据主义也是传教士。它的第二条诫命是将所有内容连接到系统，包括不想连接的异端。而且“一切”不仅仅意味着人类。这意味着一切。​因此，他认为：数据学家认为，如果经验不能共享，那么它们就毫无价值，而且我们不需要-确实不能-在我们自己内部找到意义。这是生存的问题。我们必须向自己和体系证明我们仍然有价值。价值不在于拥有经验，而在于将这些经验转化为自由流动的数据。 这种说法肯定暗示了社交媒体当前令人上瘾和自恋的用法。然后，他从跨性别的角度 - 历史的角度继续： 数据主义是自1789年以来的第一项运动，它创造了一个真正新颖的价值：信息自由。我们决不能将信息自由与表达自由的旧自由主义理念相混淆。表达自由被赋予了人类，并保护了他们思考和说出自己想要的东西的权利-包括他们闭上嘴和思想对自己的权利。相反，信息自由不给予人类。它被提供给信息。而且，这种新颖的价值可能会通过赋予信息权利在人类拥有数据和限制其移动的权利之上自由流通的权利，来侵犯传统的表达自由。 如果不是一两个世纪，那么Dataist革命可能会花费几十年。但是后来，人文主义革命也并非一朝一夕发生，今天大多数数据学家都说，万物互联是神圣的，因为人类正在创造它来满足人类的需求。但是最终，万物互联本身可能会变得神圣。 再从认识论的角度来看： 数据主义为所有科学家提供了一种通用语言，架起了跨越学术鸿沟的桥梁，并可以轻松地跨学科界限导出见解。音乐学家，政治学家和细胞生物学家最终可以相互理解。在此过程中，数据主义颠覆了传统的学习金字塔。迄今为止，数据仅被视为长智力活动链中的第一步。人们应该将数据分解为信息，将信息分解为知识，将知识分解为智慧。但是，数据学家认为，人类无法再应付海量的数据，因此他们无法将数据分发到信息中，更不用说将其分发到知识或智慧中了。因此，处理数据的工作应委托给电子算法，该算法的能力远远超过人脑。实际上，这意味着数据专家对人类的知识和智慧持怀疑态度，并且更愿意将他们的信任放在大数据和计算机算法上。 在“大数据”辩论中已经对此进行了广泛讨论。但是，他指出了数据主义的另一个基本特征： 数据论最牢固地扎根于其两个母学科：计算机科学和生物学。在这两者中，生物学更为重要。正是数据主义的生物拥护将计算机科学中的有限突破变成了世界性的灾难，可以彻底改变生活的本质。您可能不同意这样的观点，即有机体是算法，而长颈鹿，西红柿和人类只是处理数据的不同方法。但是您应该知道，这是当前的科学教条，它正在改变我们的世界，面目全非。 根据这种观点，后果可能如下： 我们目前的民主体制只是不能足够快地收集和处理相关数据，而且大多数选民对生物学和控制论的理解不够充分，无法形成任何有关的意见。因此，传统的民主政治失去了对事件的控制，也无法为我们提供对未来的有意义的愿景。政府已成为纯粹的政府。它管理国家，但不再领导它。它可以确保教师按时获得报酬，并且污水处理系统不会溢出，但是却不知道该国在20年后的地位。在某种程度上，这是一件非常好的事情。将神似的技术与超级狂妄自大的政治相结合是灾难的根源。 因此， 当算法知道每个人将如何投票时，又知道一个人投票给民主党人而另一个人投票给共和党人的确切神经系统原因时，进行民主选举有什么用？人本主义命令：“听您的感受！” 数据主义现在命令：’听算法！他们知道你的感觉。 总而言之， 在一开始，它可能会加快人本主义对健康，幸福和力量的追求。数据主义通过承诺实现这些人文主义的愿望而传播。为了获得永生，幸福和神圣的创造力，我们需要处理海量数据，远远超出人脑的能力。因此，算法将为我们做到这一点。然而，一旦权威从人类转移到算法，人本主义的项目可能就变得无关紧要了。一旦我们放弃以同中心为中心的世界观，转而以以数据为中心的世界观，人类的健康和幸福就显得不那么重要了。当已经存在更好的模型时，为什么要对过时的数据处理机器那么麻烦呢？ 尽管存在事实错误，许多以前的宗教还是获得了极大的欢迎和力量。如果基督教和共产主义能够做到这一点，为什么不实行数据主义呢？ 好吧，他听起来有些夸张，挑衅甚至是疯狂。我们能否相信自己的重要性以及同时相信数据的重要性？然后：我们不能证明生物不是算法吗？这是反乌托邦。然而，数据主义确实可能成为一种宗教。实际上，当今的寡头垄断平台可能正好在倡导互联网。换句话说，它会代表的，为了使互联网监管合法化，从而规范我们的社会，政治和心理生活，以满足他们自己的需求并遵循自己的规则，最终将互联网视为一个市场，在这个市场中，数据/信息（如以前的钱）在中心，而不是个人。尽管如此，网络还是被许多人设想并用作公共领域–我不会说最多。但是，确实趋势正在以这种方式发展。不幸的是，赫拉利的愿景不是幻想。正如他所说：“ 对数据主义教条的 严格审查不仅可能是二十世纪最大的科学挑战，而且也是最紧迫的政治和经济项目。”","categories":[],"tags":[{"name":"Reading","slug":"Reading","permalink":"https://casuor.top/tags/Reading/"}]},{"title":"必知必会的Powershell指令","slug":"geek_pwshshell","date":"2020-05-21T16:00:00.000Z","updated":"2020-10-28T09:58:54.885Z","comments":true,"path":"2020/05/22/geek_pwshshell/","link":"","permalink":"https://casuor.top/2020/05/22/geek_pwshshell/","excerpt":"","text":"必知必会的Powershell指令Get-Command gcm 获取全部命令 Get-Help Get-Help 指令名 查看某一命令的具体使用方法 Clear-Host clear/cls 清屏 Get-Location gl/pwd 输出当前所在目录 Set-Location sl/cd cd ~ #返回根目录 cd.. #返回上级目录 设置当前所在目录 Get-ChildItem dir/ls 输出当前目录子项 Get-Item gi 文件/目录名 获取子项信息 gi x* 使用*通配符筛选文件,相当于linux find指令 New-Item ni 文件名 创建文件 mkdir md创建目录 Move-Item mv 文件名 目录名 移动文件 mv 目录名 目录名 移动目录 Copy-Item cp 文件名 目录名 将文件复制到某目录 Rename-Item ren 原文件名 新文件名 重命名文件或目录 Remove-Item rm 文件名/or目录/文件名 删除文件或目录 Add-Content ac 文件名 文件追加内容 Set-Content sc 文件名 设置文件内容，会覆盖原内容 Clear-Content clc 文件名 清楚文件内容 Get-Service gsv 获取当前运行的服务 Get-Process gps 获取当前运行的进程 Stop-Process kill/spss 进程名 关掉相应的进程 Start-Process start 进程名/或其他参数 start . 资源管理器打开当前所在目录 开启某个进程 Get-Alias alias 输出当前存在的别名 设置别名Set-Alias(sal)","categories":[{"name":"Geek","slug":"Geek","permalink":"https://casuor.top/categories/Geek/"}],"tags":[]},{"title":"Awesome Wallpapers","slug":"res_awesomewall","date":"2020-05-16T16:00:00.000Z","updated":"2020-10-28T09:58:54.891Z","comments":true,"path":"2020/05/17/res_awesomewall/","link":"","permalink":"https://casuor.top/2020/05/17/res_awesomewall/","excerpt":"","text":"优质壁纸站，get 一下？速览 Wallhave Wallpaperhub wallls Wallpaper Abyss Wallhavehttps://wallhaven.cc/ 特点 正如网站【Title】所展示的awesome wallpapers，确实当之无愧（壁纸网站，而不是爬虫引擎），它提供有[latest，toplist,random]等多种筛选外，当然还有search，识图，多种tags,特别的是可通过颜色筛选相类似的壁纸，并且可以裁切任意比例，壁纸大都是设计者上传，网站链接也是固定格式的，很容易按需嘿嘿嘿 Wallpaperhubhttps://wallpaperhub.app/ 特点 网站弱弱的写了一句：Designed and built by Michael Gillett，google了一下写着：Aside from being an MVP and a keen follower I am in no way affiliated with Microsoft, the same is true of my work 害，都是泪，回归正题：本站比较单一，但绝逼是不简单呐（设计精品啊），谁说微软不牛逼呢！！！ Walllshttp://wallls.com/ 特点 本站Features:[上火],开玩笑，这个是按什么列出壁纸清单的，咳咳，不得而知，猜一下，或许是访问量😜，哈哈哈 本站特点:资源可能不是很多，但是包您满意，search，tags以及Browse by color，记得以上三点不是重点，你懂的，嘿嘿嘿 Wallpaper Abysshttps://wall.alphacoders.com/ 特点 80万张壁纸的的聚集地，看了一下热门搜索，惊了😲，什么火影，海贼，鬼灭，本站更偏向社区化，可以查看注册用户数以及Api,允许使用本站构建app等，维护者是来自世界各地的small team,具体呢tldr，详情访问以上链接即可，绝对发现新大陆","categories":[{"name":"Resource","slug":"Resource","permalink":"https://casuor.top/categories/Resource/"}],"tags":[]},{"title":"html/css framework","slug":"geek_htmlcss","date":"2020-05-05T16:00:00.000Z","updated":"2020-10-28T09:58:54.883Z","comments":true,"path":"2020/05/06/geek_htmlcss/","link":"","permalink":"https://casuor.top/2020/05/06/geek_htmlcss/","excerpt":"","text":"","categories":[{"name":"Geek","slug":"Geek","permalink":"https://casuor.top/categories/Geek/"}],"tags":[]},{"title":"Typora and PicGo-Core Custom cli","slug":"geek_typora&picgocli","date":"2020-05-05T16:00:00.000Z","updated":"2020-10-28T09:58:54.886Z","comments":true,"path":"2020/05/06/geek_typora&picgocli/","link":"","permalink":"https://casuor.top/2020/05/06/geek_typora&picgocli/","excerpt":"","text":"PicGo-Core via node package manager (Requires NodeJS runtime)npm install picgo -g picgo --help picgo use cd .\\.picgo\\ cat .\\config.json { &quot;picBed&quot;: { &quot;current&quot;: &quot;github&quot;, &quot;uploader&quot;: &quot;github&quot;, &quot;github&quot;: { &quot;repo&quot;: &quot;GithubName/RepoName&quot;, &quot;branch&quot;: &quot;master&quot;, &quot;token&quot;: &quot;&quot;, &quot;path&quot;: &quot;img/&quot;, &quot;customUrl&quot;: &quot;&quot; }, &quot;transformer&quot;: &quot;path&quot; }, &quot;picgoPlugins&quot;: {} }typora custom cliwindows linuxwhich node which picgo #拼接自定义上传命令如下 nodepath picgopath upload","categories":[{"name":"Geek","slug":"Geek","permalink":"https://casuor.top/categories/Geek/"}],"tags":[]},{"title":"Developer-roadmap","slug":"trans-developer-roadmap","date":"2020-05-05T16:00:00.000Z","updated":"2020-10-28T09:58:54.892Z","comments":true,"path":"2020/05/06/trans-developer-roadmap/","link":"","permalink":"https://casuor.top/2020/05/06/trans-developer-roadmap/","excerpt":"","text":"referencehttps://hub.fastgit.org/kamranahmedse/developer-roadmap developer-roadmap Roadmap to becoming a web developer in 2020 Frontend Roadmap Backend Roadmap DevOps Roadmap","categories":[{"name":"Geek","slug":"Geek","permalink":"https://casuor.top/categories/Geek/"}],"tags":[]},{"title":"小记白嫖Microsoft365","slug":"res_小记白嫖Microsoft365","date":"2020-05-02T16:00:00.000Z","updated":"2020-10-28T09:58:54.891Z","comments":true,"path":"2020/05/03/res_小记白嫖Microsoft365/","link":"","permalink":"https://casuor.top/2020/05/03/res_%E5%B0%8F%E8%AE%B0%E7%99%BD%E5%AB%96Microsoft365/","excerpt":"","text":"小记白嫖Office365Reference美国.edu教育邮箱申请 - Zwen Topic在线申请地址：https://bergen.edu/applynow 1.申请美国卑尔根社区学院edu邮箱，建议使用新泽西州美国人信息资料。点击“New/Visiting Students Apply Now”新生/来访的学生立即申请，在点击“Create Account”创建一个帐户。 2.申请(申请随便填)提交后大约等待半天左右的时间，您会收到卑尔根社区学院发送的一封标题为「Bergen Community College – New User Account」的邮件，内含您的学生ID、用户名、初始密码规则。初始密码是您的姓氏的前两个字母，首字母为大写+ 6位数字学生ID（不包括学生ID首位零）。例如：您的姓氏（Last Name）是Smith，学生ID为0123456，初始密码即为：Sm123456. 3.登陆：https://www.outlook.com/me.bergen.edu 登陆会跳转到卑尔根社区学院帐户登录统一认证页面。 邮箱前缀是您的用户名和密码即可登录（密码不支持修改）。 卑尔根社区学院EDU邮箱托管于Microsoft Office 365，支持Microsoft Office 365桌面版的安装。可以通过Microsoft Imagine学生账号验证，Microsoft Azure学生账号激活需要通过美国电话实体卡进行身份验证。","categories":[{"name":"Resource","slug":"Resource","permalink":"https://casuor.top/categories/Resource/"}],"tags":[]},{"title":"American identity","slug":"res_AmericanIdentity","date":"2020-05-01T16:00:00.000Z","updated":"2020-10-28T09:58:54.891Z","comments":true,"path":"2020/05/02/res_AmericanIdentity/","link":"","permalink":"https://casuor.top/2020/05/02/res_AmericanIdentity/","excerpt":"","text":"美国人身份信息所需相关网站如下 https://fakena.me/ https://www.fakenamegenerator.com/advanced.php http://www.haoweichi.com/ https://www.fakeaddressgenerator.com/ https://www.ssn-verify.com/ https://www.ssnregistry.org/validate/","categories":[{"name":"Geek","slug":"Geek","permalink":"https://casuor.top/categories/Geek/"}],"tags":[]},{"title":"git-usages","slug":"geek_gitusages","date":"2020-04-24T16:00:00.000Z","updated":"2020-10-28T09:58:54.883Z","comments":true,"path":"2020/04/25/geek_gitusages/","link":"","permalink":"https://casuor.top/2020/04/25/geek_gitusages/","excerpt":"","text":"Git常用命令参考手册reference https://github.com/xjh22222228/git-manual转载学习 目录 配置 生成SSH_Key 初始化本地仓库 文件状态 日志 克隆 查看分支 切换分支 创建分支 删除分支 重命名分支 代码合并 暂存 删除 提交 推送 拉取最新内容 查看文件的改动 回滚版本 撤销 标签 Rebase Git Flow 子模块 帮助 其他 配置# 查看全局配置列表 git config -l # 查看局部配置列表 git config --local --list # 查看已设置的全局用户名/邮箱 git config --global --get user.name git config --global --get user.email # 设置全局用户名/邮箱 git config --global user.name &quot;xiejiahe&quot; git config --global user.email &quot;example@example.com&quot; # 设置本地当前工作区仓库用户名/邮箱 git config --local user.name &quot;xiejiahe&quot; git config --local user.email &quot;example@example.com&quot; # 将默认文本编辑器设置为 emacs git config --global core.editor emacs # 将默认差异化分析工具设置为 vimdiff git config --global merge.tool vimdiff生成SSH_Key# 1、粘贴以下命令，替换为您的GitHub电子邮件地址 ssh-keygen -t rsa -b 4096 -C &quot;your_email@example.com&quot; # 2、当提示“输入要在其中保存密钥的文件”时，按Enter。接受默认文件位置。 &gt; Enter a file in which to save the key (/Users/you/.ssh/id_rsa): [Press enter] # 3、在提示符下，键入一个安全密码。 &gt; Enter passphrase (empty for no passphrase): [Type a passphrase] &gt; Enter same passphrase again: [Type passphrase again] 最后需要将生成的 SSH Key 添加到 `ssh config` 中 # 1、编辑 vim ~/.ssh/config # 2、粘贴下面到 config 文件中 Host * AddKeysToAgent yes UseKeychain yes IdentityFile ~/.ssh/id_rsa初始化仓库`git init` 创建一个空的Git仓库或重新初始化一个现有的仓库 # 会在当前目录生成.git git init # 以安静模式创建，只会打印错误或警告信息 git init -q # 创建一个裸仓库, 我们一般不会用到这个命令 git init --bare文件状态# 完整查看文件状态 git status # 以短格式给出输出 git status -s # 忽略子模块 git status --ignore-submodules日志# 查看完整历史提交记录 git log # 查看前N次提交记录 commit message git log -2 # 查看前N次提交记录，包括diff git log -p -2 # 搜索关键词 git log -S Java # 只显示合并日志 git log --merges # 以图形查看日志记录, --oneline 可选 git log --graph --oneline # 列出提交者贡献数量, 只会打印作者和贡献数量 git shortlog -sn # 以提交贡献数量排序并打印出message git shortlog -n # 采用邮箱格式化的方式进行查看贡献度 git shortlog -e # 查看 README.md 文件的修改历史记录，包括时间、作者以及内容 git blame README.md克隆# https 协议 git clone https://github.com/xjh22222228/git-manual.git # SSH协议 git clone git@github.com:xjh22222228/git-manual.git # 克隆某个分支， -b 指定分支名字 git clone -b master https://github.com/xjh22222228/git-manual.git # 递归克隆，如果项目包含子模块就非常有用 git clone --recursive git@github.com:xjh22222228/git-manual.git # 克隆深度为1, 不会把历史的记录也克隆，这样可以节省克隆时间 git clone --depth=1 https://github.com/xjh22222228/git-manual.git 查看分支# 查看所有分支 git branch --all # 查看本地分支 git branch # 查看远端分支 git branch -r切换分支# 2种方法，切换到master分支 git checkout master git switch master # 切换上一个分支 git checkout - # 切换远端分支 git checkout -t origin/dev创建分支# 创建develop本地分支 git branch develop # 创建本地develop分支并切换 git checkout -b develop # 创建远程分支, 实际上创建本地分支然后推送 git checkout -b develop git push origin develop # 创建一个空的分支, 不继承父分支，历史记录是空的，一般至少需要执行4步 git checkout --orphan develop # 这一步可选，如果你真的想创建一个没有任何文件的分支 git rm -rf . # 添加并提交，否则分支是隐藏的 （执行这一步之前需要注意当前工作区必须保留一个文件，否则无法提交） git add -A &amp;&amp; git commit -m &quot;提交&quot; # 推送到远程 git push --set-upstream origin develop删除分支# 删除本地分支 git branch -d &lt;branchName&gt; # 删除远程分支 git branch -d -r origin/&lt;branchName&gt; git push origin :&lt;branchName&gt;重命名分支# 重命名当前分支 git branch -m &lt;branchName&gt; 代码合并# 两步法, 将 feature/v1.0.0 分支代码合并到 develop git checkout develop git merge feature/v1.0.0 # 或者一步法 git merge feature/v1.0.0 develop # 以安静模式合并, 把develop分支合并到当前分支并不输出任何信息 git merge develop -q暂存# 暂存所有 git add -A # 暂存某个文件 git add ./README.md # 添加当前目录所有改动文件 git add . # 暂存一系列文件 git add 1.txt 2.txt ...删除git add 的反向操作 # 删除1.txt 文件 git rm 1.txt # 删除当前所有文件, 与rm -rf 命令不同的是不会删除 .git 目录 git rm -rf . # 清除当前工作区缓存，但不会删除文件，通常用于修改文件名不生效问题 git rm -r --cached .提交# -m 提交的信息 git commit -m &quot;changes log&quot; # 提交并显示diff变化 git commit -v # 允许提交空消息，通常必须指定 -m 参数 git commit --allow-empty-message # 重写上一次提交信息，确保当前工作区没有改动 git commit --amend -m &quot;新的提交信息&quot;推送# 推送内容到主分支 git push -u origin master # 本地分支推送到远程， 本地分支:远程分支 git push origin &lt;branchName&gt;:&lt;branchName&gt; # 简写，默认推送当前分支 git push # 强制推送, -f 是 --force 缩写 git push -f 拉取最新内容# 推荐，因为不会做自动合并 git fetch origin master # 相当于git fetch 然后 git merge git pull # 后面的意思是： 远程分支名:本地分支名 git pull origin master:master # 如果是要与本地当前分支合并，则冒号后面的&lt;本地分支名&gt;可以不写 git pull origin master 查看文件的改动# 查看所有文件改动 git diff # 查看具体文件的改动 git diff README.md # 查看某个版本的改动, 后面那一窜是commitId， git log后就能看到 git diff d68a1ef2407283516e8e4cb675b434505e39dc54 # 查看某个文件的历史修改记录 git log README.md git show d68a1ef2407283516e8e4cb675b434505e39dc54 README.md 回滚版本# 回滚上一个版本 git reset --hard HEAD^ # 回滚上两个版本 git reset --hard HEAD^^ # 回退到指定版本，git log 就能看到commit id了 git reset --hard &apos;commit id&apos; # 回滚版本是不保存在 git log，如果想查看使用 git reflog 撤销# 撤销当前目录下所有文件的改动 git checkout -- . # 撤销指定文件修改 git checkout -- README.md # 暂存区回到工作区, 指定 ./README.md 文件从暂存区回到工作区 git reset HEAD ./README.md # 撤销commit, 回到工作区, 一般commit id 是前一个 git reset &lt;commit_id&gt; # 撤销commit, 并且把修改同时撤销 git reset --hard &lt;commit_id&gt;标签# 列出本地所有标签 git tag # 列出远程所有标签 git ls-remote --tags origin # 按照特定模式查找标签, `*` 模板搜索 git tag -l &quot;v1.0.0*&quot; # 创建带有附注标签 git tag -a v1.1.0 -m &quot;标签描述&quot; # 创建轻量标签, 不需要带任何参数 git tag v1.1.0 # 后期打标签, 假设之前忘记打标签了，可以通过git log查看commit id git log git tag -a v1.1.0 &lt;commit_id&gt; # 推送到远程，默认只是本地创建 git push origin v1.1.0 # 一次性推送所有标签到远程 git push origin --tags # 删除标签, 你需要再次运行 git push origin v1.1.0 才能删除远程标签 git tag -d v1.1.0 # 删除远程标签 git push origin --delete v1.1.0 # 检查标签 git checkout v1.1.0 # 查看本地某个标签详细信息 git show v1.1.0Rebase`git rebase` 主要作用可以将多个commit记录合并为一条 # 操作最近4次提交 git rebase -i HEAD~4 # 或者以 commit_id 进行操作 git rebase -i e88835de905ad396f61a0dc8c040a8ac8a34f3f8 # 放弃 git rebase 操作 git rebase --abort # 此命令主要用于解决冲突后继续执行 git rebase --continue参考：git rebase将多次commit合并为一条 GitFlowGit Flow 不是内置命令，需要单独安装 **初始化** 每个仓库都必须初始化一次 # 通常直接回车以完成默认设置 git flow init **功能** # 开启新的功能 git flow feature start v1.1.0 # 推送到远程, 在团队协作中这一步少不了 git flow feature publish v1.1.0 # 完成功能, 会将当前分支合并到 develop 然后删除分支，回到 develop git flow feature finish v1.1.0 **打补丁** hotfix是针对 `master` 进行打补丁的 # 开启新的 hotfix git flow hotfix start v1.1.0_hotifx # 推送到远程 git flow hotfix publish v1.1.0_hotifx # 完成新的hotfix, 将当前分支合并到 master 和 develop，然后删除分支，回到 develop git flow hotfix finish v1.1.0_hotifx **发布** # 开启新的 release git flow release start v1.1.0 # 推送到远程 git flow release publish v1.1.0 # 完成, 将当前分支合并到 master 和 develop，删除当前分支然后回到 develop git flow release finish v1.1.0Git flow schema 子模块具体使用还可以看这里 git submodule子模块使用教程 # 添加子模块 git submodule add https://github.com/xjh22222228/git-manual.git # 更新，有2种方法 # 一步到位 git submodule update --remote # 或者进入到子模块项目再拉取 git pull # 修复子模块分支指向 detached head git submodule foreach -q --recursive &apos;git checkout $(git config -f $toplevel/.gitmodules submodule.$name.branch || echo master)&apos; # 删除子模块 common 为子模块名称，一般删除需要三部 git submodule deinit &lt;common&gt; # 清除子模块缓存 git rm --cached common # 提交代码并推送 git commit -am &quot;Remove a submodule&quot; &amp;&amp; git push帮助# 详细打印所有git命令 git help # 打印所有git命令, 此命令不会有详细信息，更清晰一些 git help -a # 列出所有可配置的变量 git help -c其他# 查看git版本 git --version # 查看远程仓库地址 git remote -v # 记住提交账号密码 git config --global credential.helper store # 清除git已保存的用户名和密码 # windows git credential-manager uninstall # mac linux git config --global credential.helper &quot;&quot; # 或者 git config --global --unset credential.helper # 清除本地git缓存 git rm -r --cached . 附上一张鹅厂的 git 思维导图 LicenseMIT","categories":[{"name":"Geek","slug":"Geek","permalink":"https://casuor.top/categories/Geek/"}],"tags":[]},{"title":"scoop","slug":"geek_scoop","date":"2020-04-05T16:00:00.000Z","updated":"2020-10-28T09:58:54.886Z","comments":true,"path":"2020/04/06/geek_scoop/","link":"","permalink":"https://casuor.top/2020/04/06/geek_scoop/","excerpt":"","text":"reference 123456789101112131415#修改hosts#github140.82.114.3 github.com185.199.110.153 assets-cdn.github.com199.232.69.194 github.global.ssl.fastly.net199.232.68.133 raw.githubusercontent.comSet-ExecutionPolicy RemoteSigned -scope CurrentUser$env:SCOOP&#x3D;&#39;D:\\Scoop&#39;[Environment]::SetEnvironmentVariable(&#39;SCOOP&#39;, $env:SCOOP, &#39;User&#39;)$env:SCOOP_GLOBAL&#x3D;&#39;D:\\GlobalScoopApps&#39;[Environment]::SetEnvironmentVariable(&#39;SCOOP_GLOBAL&#39;, $env:SCOOP_GLOBAL, &#39;Machine&#39;) #此步骤管理员运行#确保raw.githubusercontent.com可以访问Invoke-Expression (New-Object System.Net.WebClient).DownloadString(&#39;https:&#x2F;&#x2F;get.scoop.sh&#39;) 123456789101112131415scoop install sudo -g#ssr代理scoop config proxy 127.0.0.1:1080#scoop config rm proxyscoop install aria2 #喵的死活下不动scoop install gitscoop updateSet-ItemProperty &#39;HKLM:\\SYSTEM\\CurrentControlSet\\Control\\FileSystem&#39; -Name &#39;LongPathsEnabled&#39; -Value 1scoop install innounpscoop install darkscoop checkupscoop bucket add extrasscoop install typorascoop install vscodecode $env:LocalAppData\\Packages\\Microsoft.WindowsTerminal_8wekyb3d8bbwe\\LocalState\\settings.json 12345678910111213141516171819scoop install figletscoop install cowsayscoop bucket add dorado https://github.com/h404bi/doradosudo scoop install trash -gsudo scoop install nvm -gscoop bucket add Ash258 'https://github.com/Ash258/Scoop-Ash258.git'scoop install carnacscoop bucket add iszy 'https://github.com/ZvonimirSun/scoop-iszy.git'scoop install wechatscoop install qq-dreamcastscoop install utoolsscoop install switchhostsscoop install scoop bucket add my-scoop-bucket https://github.com/destinyenvoy/my-scoop-bucketscoop install gvim#设置别名scoop alias add i 'scoop install $args[0]'scoop alias add rm 'scoop uninstall $args[0]'scoop alias add ls 'scoop list' 'List installed apps'scoop alias add up 'scoop update $args[0]' 'Update apps, or Scoop itself' 7zip 19.00 anaconda3 2020.02 [dorado] aria2 1.35.0-1 carnac 2.3.13 [extras] clash-for-windows failed ColorTool 1904.29002 cowsay 0.2013.07.19 dark 3.11.2 dismplusplus 10.1.1001.10 [extras] everything 1.4.1.969 [extras] fiddler 5.0.20202.18177 [extras] figlet 1.0-go firefox current [extras] git 2.26.2.windows.1 github 2.5.2 [extras] googlechrome 81.0.4044.138 [extras] gow 0.8.0 innounp 0.49 jetbrains-toolbox 1.17.7018 [extras] kate 20.04.1-893 [extras] mubu 1.2.4 [dorado] mysql 8.0.20 netease-music 2.7.1.198242 [iszy] nircmd 2.86 global notion 2.0.8 [Ash258] nvm 1.1.7 global oraclejdk8 8u231 [iszy] powertoys 0.18.2 [extras] pwsh-preview 7.1.0-preview.3 [Ash258] python 3.8.3 QtScrcpy 1.3.5 [dorado] rufus 3.10 [extras] screentogif 2.24.2 [extras] sudo 0.2020.01.26 global switchhosts 3.5.4 [extras] trash 2.0.0 global [dorado] typora 0.9.89 [extras] vscode 1.46.1 [extras] wechat nightly-20200515 [dorado]","categories":[{"name":"Geek","slug":"Geek","permalink":"https://casuor.top/categories/Geek/"}],"tags":[]},{"title":"亚里士多德名言","slug":"reading-亚里士多德名言英文","date":"2020-03-31T16:00:00.000Z","updated":"2020-10-28T09:58:54.889Z","comments":true,"path":"2020/04/01/reading-亚里士多德名言英文/","link":"","permalink":"https://casuor.top/2020/04/01/reading-%E4%BA%9A%E9%87%8C%E5%A3%AB%E5%A4%9A%E5%BE%B7%E5%90%8D%E8%A8%80%E8%8B%B1%E6%96%87/","excerpt":"","text":"亚里士多德名言1、Happiness is good。幸福就是至善。 2、Evil is the cause of evil。邪恶事件起因于邪恶。 3、Beauty is a gift from God。美是上帝赐予的礼物。 4、Beauty is a natural advantage。美是一种自然优势。 5、Knowledge is human nature。求知是人类的本性。 6、Education is cheap defense。教育是廉价的国防。 7、Happiness comes from our own。幸福来源于我们自己。 8、I love my teacher， I love the truth。我爱我师，我更爱真理。 9、Even God cannot change the past。即使上帝也无法改变过去。 10、Memory is the mother of wisdom。记忆为智慧之母。 11、No one can grasp the truth。没有一个人能全面把握真理。 12、Habits can make second nature。习惯能造就第二天性。 13、Happiness lies in the autonomy。幸福在于自主自足之中。 14、A genius and a madman。天才必然和疯子结成亲密的联盟。 15、Man is a natural social animal。人类是天生社会性动物。 16、Man is a natural social animal。人类是天生社会性的动物。 17、Happiness belongs to meet the people。幸福属于满足的人们。 18、The purpose of the work is to get leisure。劳动的目的是为了获得闲暇。 19、A barking dog is better than a sleeping lion with。吠犬之用，胜于睡狮。 20、Happiness lies in being self-sufficient。幸福在于自给自足之中。 21、The purpose of the work is to get free。工作的目的便是获得空闲。 22、The purpose of the war must be peace。**的目的必须是为了和平。 23、Every field of nature is wonderful。大自然的每一个领域都是美妙绝伦的。 24、Knowledge is the best food for elderly。知识是为老年准备的最好的食粮。 25、The greatest honor is to defend the country。最大的荣誉是保卫祖国的荣誉。 26、Happiness is for those who are easy to meet。幸福属于那些容易感到满足的人。 27、I love my teacher， but I love the truth。我爱我的老师，但我更爱真理。 28、Justice is the virtue of punishment in Gongming。公正是赏罚公明者的美德。 29、Courage is the path of confidence and fear。勇敢乃是自信与害怕中间之道。 30、The same bird， self converging together。羽毛相同的鸟，自会聚在一起。 31、Bad habits are formed in the unconscious。坏习惯是在不知不觉中形成的。 32、Keep oneself to oneself， not a beast or a God。离群索居者，不是野兽，便是神灵。 33、A true friend is a soul in two bodies。真正的朋友，是一个灵魂孕育在两个躯体里。 34、Real people have high Hiroyuki can benefit mankind。真正高宏之人，必能造福于人类。 35、All art， religion is only natural appendages。一切艺术、宗教都不过是自然的附属物。 36、The cause is the vivid unification of idea and practice。事业是理念和实践的生动统一。 37、Law is order， and good law is good order。法律就是秩序，有好的法律才有好的秩序。 38、Friends， they will not put the scales in their midst。是朋友，就不会把秤放在他们中间。 39、The most lucid style is formed by common language。最明晰的风格是由普通语言形成的。 40、The roots of education are bitter， but the fruit is sweet。教育的根是苦的，但其果实是甜的。 41、To overcome the fear of people to get real freedom。克服了恐惧的人才能获得真正的自由。 42、Who are friends， the essence of who are not friends。对谁都是朋友，实质对谁都不是朋友。 43、Beautiful appearance and elegant demeanor is a long。美丽的相貌和优雅的风度是一封长。 44、Live a happy life in accordance with moral standards。遵照道德准则生活就是幸福的生活。 45、The accuracy of language is the foundation of a good style。语言的准确性，是优良风格的基础。 46、Happiness is to put the soul in the most appropriate place。幸福是把灵魂安放在最适当的位置。 47、There is no man with a mad character， no great talent。没有疯狂性格的人，绝没有庞大的天才。 48、Beauty is a kind of good， and it is good for pleasure。美是一种善，其所以引起快感，正因为它善。 49、The so-called equality， is the poor do not account for the rich。所谓平等，就是穷人不占富人的便宜。 50、Education is an ornament to the rich， and a refuge for the poor。教育是富人的装饰品，穷人的避难所。 51、Education is an ornament in prosperity， adversity is a refuge。教育在顺境中是装饰品，在逆境中是避难所。 52、Human knowledge has three： theory， practical， identification。人类所需要的知识有三：理论、实用、鉴别。 53、It is only one road， the road can have many of the evil。人们为善的道路只有一条，作恶的道路可以有许多条。 54、If the evil completely becomes unbearable， it will self destruct。如果恶完全变成不堪忍受的，它也将自灭。 55、The truth will deviate from the original course， in the end is wrong。最初偏离真理毫厘，到头来就会谬之千里。 56、Intellectuals are better than illiteracy， as the living is better than dead。知识分子优于文盲，如同活人优于死人。 57、A bad man is a man who is afraid to obey， a good man is subject to love。坏人因畏惧而服从，好人因爱而服从。 58、A long， idle， and most of the time to make one’s failure and destruction。长期的无所事事最能使人衰竭和毁灭。 59、only to overcome their fear， it is possible to obtain real freedom。只有克服了自己的恐惧，才可能获得真正的自由。 60、Good is happiness。 Moderation is the highest good and extreme beauty。善就是幸福。中庸是最高的善和极端的美。 61、Education does not change human nature， can only improve human nature。教育并不能改变人性，只能改良人性。 62、Education should be provided by law， and should be the country’s affairs。教育应由法律规定，并且应是国家的事务。 63、Beautiful looks and graceful manners are a long - term recommendation。美丽的相貌和优雅的风度是一封长效的推荐信。 64、The ultimate value of life is to wake up and think， not only to survive。人生最终的价值在于觉醒和思考的，而不只在于生存。 65、People think I am the most intelligent， but I know that I do not know what。人以为我最聪明，但是我自己知道我是什么都不知。 66、The revolution should not trivial， but it is originated from the trivial things。**应不是琐细小事，但它却是起源于琐细事物。 67、Matter and form are abstract concepts， and a concrete object contains both。物质与形式是抽象概念，一个具体的事物包含着两者。 68、In any case， the form is more important than material， because it can be created。形式无论如何也比物质更重要，因为形式是可以创造的。 69、Goodness is the noble and is praiseworthy for one’s excellent conduct， worthy of praise。善性是难能可贵的，也是高尚和值得称赞的。 70、The arbitrator shall be based on equity， and the judge shall take the law as the criterion。仲裁人要以衡平法为依据，法官要以法律为准绳。 71、A good impression is a prerequisite for friendship， but it can not be confused with the two。好感是友谊的先决条件，但不能把两者混为一谈。 72、Relaxation and recreation， which are considered to be an indispensable element of life。放松与娱乐，被认为是生活中不可缺少的要素。 73、I think， and the victory over the enemy， compared to the desire of the people to fight more bravely。我认为，与战胜敌人的人相比，战胜欲望的人更加勇敢。 74、A man who loves the truth， who loves the truth when he is in no danger， loves the truth in danger。热爱真理的人在没有危险时爱着真理，在危险时更爱真理。 75、People should begin to explore from ancient to modern times， originated in the natural world of wonder。古往今来人们开始探索，都应起源于对自然万物的惊异。 1、细节决定成败。 2、成功是细节之子。 3、奥秘全在细微处。 4、天下大事，必作于细。 5、细节承载着社会的文明。 6、关注细节，成就大事。 7、机会往往隐藏在细节之中。 8、沉沉的黑夜都是白天的前奏。 9、做事不贪大，做人不计小。 10、人生最大的浪费是选择的浪费。 11、当失败不可避免时，失败也是伟大的。 12、至广大而精细微（胆要大、心要细）。 13、人的意志力是由责任感决定的。 14、个人素质一小步，民族素质一大步。 15、职场箴言：天下大事，必做于细。 16、简单的招式炼到极至就是绝招。 17、小事成就大事，细节成就完美。 18、失败就是迈向成功应付出的代价。 19、成功＝艰苦的劳动＋正确的方法＋少说空话。 20、细节成为产品或服务质量的最有力的表现形式。 21、成功=正确的定位+坚定的步伐+快乐的行进。 22、人的聪明和自己的明智及道路的选择，往往在失败以后。 23、使人疲惫不堪的不是远方的高山，而是鞋里的一粒沙子。 24、一个企业家要有明确的经营理念和对细节无限的爱。 25、无视细节的企业，它的发展必定在粗糙的砾石中停滞。 26、永远向竞争对手学习，学习每一个先进的“细节”。 27、失败也是我需要的，它与成功对我一样有价值。 28、一次失败，只是证明我们成功的决心还够坚强。 29、大事皆由小事累积而成，没有小事的积累，也难成大事。 30、为伟大的事业捐躯，从来就不能算作是失败。 31、一个不经意的细节，往往能够反映出一个人深层次的修养。 32、细节始于计划，计划同时也是一种细节，是很重要的细节。 33、任何事情，只有做到100%才是合格，99分都是不合格。 34、不放过细节。无视细节的企业，它的发展必定在粗糙的砾石中停滞。 35、细节不是“细枝末节”，而是用心，是一种认真的态度和科学的精神。 36、成功的人是跟别人学习经验，失败的人只跟自己学习经验。 37、世界上到处都是散漫粗心的人，只有那善始善终者是供不应求的。 38、没有条理、做事没有秩序的人，无论做哪一种事业都没有功效可言。 39、把每一件简单的事做好就是不简单，把每一件平凡的事做好就是不平凡。 40、有条理、有秩序的人，即使才能平庸，他的事业也往往有相当的成就。 41、普通人，大量的日子，很显然都在做一些小事，怕小事也做不好，小事也做不到位。 42、实际情况往往是这样的：想法是好的，但却没有人愿意和能够把每一件小事做透。 43、障碍与失败，是通往成功最稳靠的踏脚石，肯研究利用它们，便能从失败中培养出成功。 44、细节总是容易为人所忽视，所以往往最能反映一个人的真实状态，因而也最能表现一个人的修养。 45、当生活像一首歌那样轻快流畅时，笑颜常开乃易事；而在一切事都不妙时仍能微笑的人，才活得有价值。 46、什么是不简单？把每一件简单的事情做好就是不简单；什么是不平凡？把每一件平凡的事情做好就是不平凡。 47、世界上最难遵循的规则是度，度源于素养，而素养则来源于日常生活一点一滴的细节的积累，这种积累是一种功夫。 48、考虑到细节、注重细节的人，不仅认真对待工作，将小事做细，而且注重在做事的细节中找到机会，从而使自己走向成功之路。 49、德国企业就是凭着一丝不苟、精细严谨的做事风格，成就了一大批世界级企业巨头，打造了“德国制造”这个产品品质保证代名词的国家品牌。 50、注意细节其实是一种功夫，这种功夫是靠日积夜累培养出来的。谈到日积夜累，就不能不涉及到习惯，因为人的行为的95%都是受习惯影响的，在习惯中培养功夫，培养素质。 1、不怕学不会，只怕不肯钻。Not afraid， not afraid to drill。 2、时间是脑力劳动者的资本。Time is the capital of the brain。 3、勤能补拙是良训，一分辛苦一分才。Is a good training， a hard one before。 4、汗水换来丰收，勤学取得知识。Sweat harvest， hard to get knowledge。 5、天才无非是长久的忍耐，努力吧！Genius is nothing but a long endurance！ 6、早起多长一智，晚睡多增一闻。An early night more than a smell of wisdom。 7、平时不好学，临考悔已迟。Usually not easy to learn， too late to regret the exam。 8、灵感是从来不拜访懒汉的。Inspiration is never called on the sluggard。 9、书籍是横渡时间大海的航船。The book is the ship crossing the sea of time。 10、不怕学不成，只怕心不诚。Not afraid， afraid of heart is not sincere。 11、只要是有益的话，小孩的话也要听。As long as it is good， the child will listen to it。 12、忘记今天的人将被明天忘记。Forget today’s people will be forgotten tomorrow。 13、黑发不如勤学早，白发方悔读书迟。Black as time， white square regret later reading。 14、你若需要时间，还得自己把他造出来。If you need time， you have to make it yourself。 15、好学而不勤问非真好学者。Good learning and not often asked not to really good scholar。 16、刻苦学习的人总能实现自己的愿望。People who study hard can always achieve their wishes。 17、少年不知勤学早，白首方悔读书迟。Boy no time， white square regret later reading。 18、学成巧，总是巧；装成巧，惹人笑。They always pretend to be clever， clever； smart， funny。 19、钟不敲不鸣，人不学不灵。Don’t knock the clock not singing， people do not learn。 20、文学之知识乃是学问之门禁。Knowledge of literature is the access control of learning。 21、靠父亲的学识成不了学者。By his father’s knowledge can not become a scholar。 22、怕问路，要迷路。嘴勤不走冤枉路。Afraid to ask， get lost。 Mouth do not go astray。 23、勤奋是聪明的土壤，勤学是聪明的钥匙。Diligence is the smart is smart key soil， logistics。 24、愈学习，愈发现自己无知。The more learning， the more you find yourself ignorant。 25、水滴石穿，绳锯木断。Dripping water wears through a stone。， Little strokes fell great oaks。 26、黑发不知勤学早，白首方悔读书迟。Energy-saving， white square regret later reading。 27、聪明靠努力学习，知识靠平日积累。Smart by hard learning， knowledge on weekdays accumulation。 28、赶脚的对头是脚懒，学习的对头是自满。My head is foot lazy， complacency is the enemy of learning。 29、讷讷寡言者未必愚，喋喋利口者未必智。only silence may not be foolish， just not wise liqueur。 30、读书破万卷，下笔如有神。Having read more than ten thousand books， writing if there is god。 31、活到老，学到老，一生一世学不了。It is never too late to learn， to learn， one’s whole life。 32、人不劳动没出息，人不学习没长进。People do not work for nothing， people do not learn no progress。 33、手指有长有短，知识有高有低。学无前后，达者为师。Finger length， knowledge。 No， as teachers。 34、黄金时代是在我们的前面，而不在我们的后面。The golden age is before us， not behind us。 35、年华一去不复返，事业放弃在难成。Time gone， cause to give up in difficult to become。 36、边学边问，才有学问。若要精，人前听。Learn to ask， learned。 To be fine， people listen to。 37、刀不快，石上磨。人不会，世上学。Knife is not quick， stone grinding。 No one can go to school。 38、喜欢吹嘘的人犹如一面大鼓，响声大腹中空。Like people who brag is like a drum， the hollow sound。 39、没有加倍的勤奋，就既没有才能，也没有天才。There is no talent， no talent， no more diligent。 40、要学蜜蜂采百花，问遍百家成行家。To learn the bees gather flowers， asked all over 100 experts。 41、一分耕耘，一分收获。一艺之成，当尽毕生之力。A hard， a harvest。 A skill， when the power of life。 42、不能则学，不知则问，耻于问人，决无长进。Not to learn， I asked， ashamed to ask people， no。 43、用宝珠打扮自己，不如用知识充实自己。Dress with pearls， as to enrich themselves with knowledge。 44、劳动是知识的源泉；知识是生活的指南。Labor is the source of knowledge； knowledge is the guide to life。 45、学而不思则罔，思而不学则殆。Learning without thought is labor lost， thought without learning is perilous。 46、蜂采百花酿甜蜜，人读群书明真理。Bee stuffed sweet flowers， group of people reading the book out the truth。 47、智者千虑，必有一失；愚者千虑，必有一得。It is a wise man， there must be a loss； a fool， there will be one。 48、树不修，长不直；人不学，没知识。The tree does not repair， long not straight； people do not learn， no knowledge。 49、山有路勤为径，学海无涯苦作舟。The mountain road to the size， no end for learning suffering for the boat。 50、可得一夜安眠；勤劳一生，勤劳一日。可得幸福长眠。But a night’s sleep； a hard life， one day。 A happy death。 51、博学之，审问之，慎思之，明辩之，笃行之。Erudite， questioning， deliberative， distinguish， and faithful。 52、吹嘘自己有知识的人，等于在宣扬自己的无知。He who boasts of his knowledge is equal to his own ignorance。 53、鸟欲高飞先振翅，人求上进先读书。The bird to fly first wings， who seek to improve themselves to reading。 54、井淘三遍吃好水，人从三师武艺高。Wells wash three times to eat water， people from the three division Wu Yi high。 55、谦虚是学习的朋友，自满是学习的敌人。Humility is the learning of a friend， complacency is the enemy of study。 56、言过其实，终无大用。知识愈浅，自信愈深。No big exaggerate。 The more shallow knowledge， the more deep the confidence。 57、学问渊博的人，懂了还要问；学问浅薄的人，不懂也不问。A learned man， a man who knows not， but a man who has no knowledge。 58、不向前走，不知路远；不努力学习，不明白真理。Do not move forward， not far； don’t study hard， do not understand the truth。 59、山不厌高，水不厌深。骄傲是跌跤的前奏。The mountain is too high， the water too deep。 Pride is the prelude to fall。 60、水不流，会发臭；人不学，会落后。The water does not flow， will stink； people do not learn， will be left behind。 61、成就是谦虚者前进的阶梯，也是骄傲者后退的滑梯。Step forward achievement is modest， is proud of the slide back。 62、学问二字，须要拆开看，学是学，问是问。Learning two words， need to open to see， learning is to learn， ask is to ask。 63、一分耕耘，一分收获；要收获的好，必须耕耘的好。A point of hard work， a harvest； to gain good， must work well。 64、水满则溢，月满则亏；自满则败，自矜则愚。The water overflows， over the loss； complacency is defeated， blinded fool。 65、没有任何动物比蚂蚁更勤奋，然而它却最沉默寡言。The ant is the most industrious animal， but it most be scanty of words。 66、发奋识遍天下字，立志读尽人间书。To know the word all over the world， determined to make the world read the book。 67、心坚石也穿。好记性不如烂笔头。勤勉是成功之母。Heart stone also wear。 Forget it。 Diligence is the mother of success。 68、才华是血汗的结晶。才华是刀刃，辛苦是磨刀石。Talent is the crystallization of sweat。 Talent is the blade， hard whetstone。 69、刀钝石上磨，人笨人前学。以人为师能进步。A blunt knife grinding stone， a former school people。 To make progress by the human。 70、业精于勤荒于嬉，行成于思毁于随。Efficiency comes from diligence。 shortage in the play， was destroyed along with the line into si。 71、如果不想在世界上虚度一生，那就要学习一辈子。If you don’t want to waste your life in the world， you need to study for a lifetime。 72、书，是人类共同的精神财富，是人类进步的阶梯。Books， is the common spiritual wealth of mankind， is the ladder of human progress。 73、精神的浩瀚、想象的活跃、心灵的勤奋：就是天才。The spirit of the vast， the imagination of active， the mind of the diligence： is a genius。 74、如果有了胡子就算学识渊博，那么，山羊也可以讲课了。If the beard even so， goats can also have a large stock of information， lecture。 75、老姜辣味大，老人经验多。请教别人不折本，舌头打个滚。Ginger spicy， old experience。 Ask others not to lose money， the tongue play a roll。 76、人生有一道难题，那就是如何使一寸光阴等于一寸生命。Life has a problem， that is how to make an inch of time is an inch of life。 77、知识象烛光，能照亮一个人，也能照亮无数人。Knowledge is like a candle， it can illuminate a person， also can illuminate countless people。 78、三更灯火五更鸡，正是男儿读书时；黑发不知勤学早，白首方悔读书迟。The night， is the man； energy-saving， white square regret later reading。 79、业精于勤，荒于嬉，行成于思，毁于随。Efficiency comes from diligence。， shortage in the play， the line into Si， destroyed with。 80、包子有肉，不在皮上；人有学问，不挂嘴上。The steamed stuffed bun with meat， not on the skin； people have the knowledge， not on the mouth。 81、虚心的人，常想己之短；骄傲的人，常夸己之长。An open-minded person， often think oneself is short； proud of people， often boast of their long。 82、吾尝终日不食，终夜不寝，以思无益，不如学也。I try not eat all day long， all night without sleep， to think of useless, it is better to school。 83、试试并非受罪，问问并不吃亏。善于发问的人，知识丰富。Try not to suffer, ask does not suffer。 The man who is good at asking questions, knowledge is rich。 84、做一个积极主动的人，最重要的是心，热爱生命，勤奋实干，开放进取。To be a positive person, the most important is the heart, love life, hard work, open up。 85、学在苦中求，艺在勤中练。不怕学问浅，就怕志气短。Learn in the pain, art in the ground to practice. Not afraid of shallow knowledge, short ambition. 86、泰山不是垒的，学问不是吹的。天不言自高，地不语自厚。Taishan is not a barrier, learning is not blowing. Day never from, not a word from the thick. 87、贵有恒何必三更眠五更起，最无益只怕一日曝十日寒。Thank you why sleep before midnight, the most useless if one day ten day of cold exposure. 88、汗水和丰收是忠实的伙伴，勤学和知识是一对最美丽的情侣。Sweat and harvest is a faithful companion, learning and knowledge is one of the most beautiful couple. 89、不实心不成事，不虚心不知事。不自是者博闻，不自满者受益。Don’t not do not know solid things, with an open mind. Not since the CMP is no room for complacency, benefit. 90、好高骛远的一无所得，埋头苦干的获得知识。百艺通，不如一艺精。Ambitious be nowhere to acquire knowledge, work with quiet hard application. One hundred arts, as an art. 91、只有努力攀登顶峰的人，才能把顶峰踩在脚下。困难是人的教科书。only by trying to reach the top can the top step at the foot of the mountain. Difficult is the textbook of human. 92、人唯虚，始能知人。满招损，谦受益。满必溢，骄必败。only empty, can only be people. Pride hurts modesty benefits. Full will overflow, pride comes before a fall. 93、上如阶尽管费力，却一步比一步高。不经过琢磨，宝石也不会发光。On the first step, if the effort, but one step higher than one step. Not after pondering, the gem will not shine. 94、虚心使人进步，骄傲使人落后。虚心的人学十算一，骄傲的人学一当十。Modesty helps one to progress, conceit makes one lag behind. An open-minded person studies ten, a proud man, when ten. 95、学习如钻探石油，钻得愈深，愈能找到知识的精髓。先学爬，然后学走。Learning such as drilling, drilling deeper, more able to find the essence of knowledge. Learn to crawl before you go. 96、强中更有强中手，莫向人前自夸口。满足现在的成就，就窒息了未来。Diamond cut diamond., Mo to the people before the glory. To meet the present achievements, the future of suffocation. 97、说大话的人像爆竹，响一声就完了。鉴难明，始能照物；衡唯平，始能权物。Talk like firecrackers, a sound. Kam Ming was difficult, as matter； balance can only be the right thing Weiping. 98、日日行，不怕千万里；时时学，不怕千万卷。多练多乖，不练就呆。Every day, not afraid of thousands of miles； always learn, not afraid of ten million volumes. Practice good, do not have to stay. 99、宽阔的河平静，博学的人谦虚。秀才不怕衣衫破，就怕肚子没有货。The wide river is quiet, the learned man is humble. Not afraid of breaking the scholar clothes, but the stomach is not available. 100、一个不想蹚过小河的人，自然不想远涉重洋。针越用越明，脑越用越灵。One does not want to wade the stream of people, naturally do not want to travel across many seas. The more using the needle, the more the brain uses.","categories":[{"name":"Geek","slug":"Geek","permalink":"https://casuor.top/categories/Geek/"}],"tags":[]},{"title":"质数的孤独","slug":"reading-质数的孤独","date":"2020-03-31T16:00:00.000Z","updated":"2020-10-28T09:58:54.889Z","comments":true,"path":"2020/04/01/reading-质数的孤独/","link":"","permalink":"https://casuor.top/2020/04/01/reading-%E8%B4%A8%E6%95%B0%E7%9A%84%E5%AD%A4%E7%8B%AC/","excerpt":"","text":"质数的孤独【1】：哪种比较孤独：是活在自己的世界里，谁也不爱，还是心里爱着一个人，却始终无法向爱靠近？ –保罗·乔尔达诺 《质数的孤独》 【2】：越长大，越觉得孤独竟是生命的必然，每个人都是质数列中孤单却特别的存在。或许，说不上特别，也就算个普普通通，再或者说，用＂普通＂都夸张了些。我们都是那孤独的质数，我们都承受着质数的孤独。 –保罗·乔尔达诺 《质数的孤独》 【3】：选择只是几秒钟的事，然后用余下时间来还债。 –保罗·乔尔达诺 《质数的孤独》 【4】：与人交往都是一样的，就像一盘棋的开局，没有必要别出心裁，那毫无用处，因为两个人想要达到的目的是一样的，接下来这盘棋会自动往下进行，只有到了这个时候，谋略才能排得上用场。 –保罗·乔尔达诺 《质数的孤独》 【5】：那些我们不爱的人对我们的爱只停留在表面，很快就会挥发掉。 –保罗·乔尔达诺 《质数的孤独》 【6】：质数只能被一和它自身整除。在自然数的无穷序列中，它们处于自己的位置上，和其他所有数字一样，被前后两个数字挤着，但它们彼此间的距离却比其他数字更远一步。它们是多疑而又孤独的数字，正是由于这一点，马蒂亚觉得它们非常奇妙….. 在大学一年级的一门课上，马蒂亚知道，在质数当中还有一些更加特别的成员，数学家称之为“孪生质数”，它们是离得很近的一对质数，几乎是彼此相邻。 –保罗·乔尔达诺 《质数的孤独》 【7】：世上多余的事情，不管以什么形式出现，都与他毫无关系，当这些事与他内心的平衡以及他理性的判断发生抵触时，他宁愿视而不见，轻而易举地装作它们并不存在。如果一个障碍物出现在他面前，阻挡了他的道路，他会绕过障碍继续前进，一丝一毫也不会改变自己前行的步伐，而且会很快忘掉这个障碍。他几乎从来没有犹豫过。 –保罗·乔尔达诺 《质数的孤独》 【8】：她以一种冷漠的猎奇心理看着自己的软弱与偏执再次暴露出来，这一次她完全听任它们的摆布，反正她已是无能为力了。与自己的某些方面过不去只能落得个徒劳无功的下场，爱丽丝告诫自己，同时惬意地回想着自己的少女时代。 –保罗·乔尔达诺 《质数的孤独》 【9】：他联想到一种已经耗尽的潜力，还想到磁场中一条条看不见的磁力线，原来它们还通过空气维系在一起，而如今已荡然无存。 –保罗·乔尔达诺 《质数的孤独》 【10】：Choices are made in brief seconds and paid for in the time that remains. 用几秒钟作出选择，然后用余生为此付出代价。 –保罗·乔尔达诺 《质数的孤独》 【11】：质数只能被一和它自身整除。在自然数的无穷序列中，它们处于自己的位置上，和其他的所有数字一样，被前后两个数字挤着，但它们彼此间的距离却比其他所有数字更远一步。它们是多疑而又孤独的数字。 –保罗·乔尔达诺 《质数的孤独》 【12】：最近一年，在她和马丁分手之后，就开始感到自己与这个地方格格不入，也开始感觉到彻骨的寒冷。寒风吹干了她的皮肤，即便到了夏天也不能完全恢复弹性，然而，真要离开这里，她又下不了决心，她已经对这个地方产生了依赖，被这里深深地感染了，通常，只有那些对身体有害的东西才能让人如此上瘾。 –保罗·乔尔达诺 《质数的孤独》 【13】：在他们两人的头上浮现出一个巨大的对话框，里面写满了他们要说的话，但他们都竭力回避，双目低垂。 –保罗·乔尔达诺 《质数的孤独》 【14】：他知道这个世界只会越来越混乱，噪音最终会大到覆盖住所所有的信号，但是他相信，只要注意约束好自己的每一个动作，就会减少一些使世界缓慢解体的罪恶。 –保罗·乔尔达诺 《质数的孤独》 【15】：她用力压平双眼，想把眼球从眼眶里挤出来，让它们化作锋利的碎片，刺入每一个与她的目光相遇的男孩子的肺腑、她希望自己的目光不放过任何一个人，从而给他们留下挥之不去的印记。 –保罗·乔尔达诺 《质数的孤独》 【16】：法比奥似乎确切地掌握了献殷勤之道，他遵守时间，还会掌握说话的分寸，就像在奉行着某种外交礼仪。他能洞悉爱丽丝那深深的痛苦，但只作为旁观者，处在边缘。世上多余的事情，不管以什么形式出现，都与他毫无干系，当这些事与他内心的平衡以及他理性的判断发生抵触时，他宁愿视而不见，轻而易举地装作它们并不存在。如果一个障碍出现在他面前，阻挡了他的道路，他会绕过障碍继续前行，一丝一毫也不会改变自己前行的步伐，而且会很快忘掉这个障碍。他几乎从来没有犹豫过。 –保罗·乔尔达诺 《质数的孤独》 【17】：他们二人的宇宙正经历着缓慢而难以察觉的相互渗透，就像两颗行星在围绕同一个轴心运行，它们的轨道越来越近，注定会在时空的某一点上相会。 –保罗·乔尔达诺 《质数的孤独》 【18】：她想起那次躺在山谷里，被积雪掩埋的样子。想起那种天籁般的寂静。现在也和那时一样，没人知道她在哪里。这一次也同样没人会来，但她已不再有任何期待了。 –保罗·乔尔达诺 《质数的孤独》 【19】：然而，他越是努力把问题简单化，就越觉得混乱。他觉得自己像一只小虫被黏在了黏黏糊糊的蜘蛛网上，越是想挣脱，就被缠得越紧。 –保罗·乔尔达诺 《质数的孤独》 【20】：他的这个秘密有着一个恐怖的名字，它就像一块尼龙布一样，遮蔽住他全部的思维，使他透不过气来。他待在那里，脑子里反复思量着这件事，就像在考虑一桩他迟早要为之付出代价的罪责。……一种罪恶感从天而降，落在他身上，就好像在用脏水淋浴一样。这些脏水透入他的皮肤，隐藏在他的脏腑中，就像屋檐吞噬着老房子的墙壁那样，让他慢慢腐烂。 –保罗·乔尔达诺 《质数的孤独》 【21】：日子一天天地过去，就像溶液一样流过皮肤，每天都会从爱丽丝的文身上和他们两人的记忆中冲刷掉薄薄的一层颜色，但是文身的轮廓就像生活的环境一样依然存在着，黑色线条依然清晰，只是其中的颜色已经彼此混合在一起，最终褪成一种暗淡、单一的色调，几乎失去了任何意义。 –保罗·乔尔达诺 《质数的孤独》 【22】：平时他们也很少说话，却在一起消磨时光，他们各自专注着只属于自己的那道深渊，与对方既形影不离，又互不侵犯，不需要费很多口舌。 –保罗·乔尔达诺 《质数的孤独》 【23】：质数只能被一和它自身整除。在自然数的无穷序列中，它们处于自己的位置上，和其他所有数字一样，被前后两个数字挤着，但它们彼此间的距离却比其他数字更远一步。它们是多疑而又孤独的数字，正是由于这一点，马蒂亚觉得它们非常奇妙。有时候他会认为，它们是误入到这个序列中的，就像是串在一条项链上的小珍珠一样被禁锢在那里。有时候他也会怀疑，也许它们希望像其他所有数字一样普普通通，只是出于某种原因无法如愿。这后一种想法经常在晚间光顾他的大脑，夹杂在睡梦前凌乱而交错的各种形象之中，这个时候，他的大脑会非常疲顿，不愿再编织谎言。 –保罗·乔尔达诺 《质数的孤独》 【24】：马蒂亚的声音再也不会令他的胃搅动了，但他对马蒂亚的那种意思依然存在，而且还将永远保留，并成为他今后所有感情的唯一真实的参考标准。 –保罗·乔尔达诺 《质数的孤独》 【25】：他们俩谁也没提议放点儿音乐听。他们什么也不想做，只是待在那里，等待着星期天下午渐渐逝去，等待着到时间做那些非做不可的事，比如吃饭，睡觉和迎接新的一周。九月焦黄的日光从敞开的窗子里透射进来，街上断断续续的细碎声响也随后飘进了房间。 –保罗·乔尔达诺 《质数的孤独》","categories":[{"name":"Reading","slug":"Reading","permalink":"https://casuor.top/categories/Reading/"}],"tags":[]},{"title":"Joplin & Yosoro","slug":"res_Joplin&Yosoro","date":"2020-03-31T16:00:00.000Z","updated":"2020-10-28T09:58:54.891Z","comments":true,"path":"2020/04/01/res_Joplin&Yosoro/","link":"","permalink":"https://casuor.top/2020/04/01/res_Joplin&Yosoro/","excerpt":"","text":"JoplinJoplin is a free, open source note taking and to-do application, which can handle a large number of notes organised into notebooks. The notes are searchable, can be copied, tagged and modified either from the applications directly or from your own text editor. The notes are in Markdown format. Notes exported from Evernote via .enex files can be imported into Joplin, including the formatted content (which is converted to Markdown), resources (images, attachments, etc.) and complete metadata (geolocation, updated time, created time, etc.). Plain Markdown files can also be imported. The notes can be synchronised with various cloud services including Nextcloud, Dropbox, OneDrive, WebDAV or the file system (for example with a network directory). When synchronising the notes, notebooks, tags and other metadata are saved to plain text files which can be easily inspected, backed up and moved around. The application is available for Windows, Linux, macOS, Android and iOS (the terminal app also works on FreeBSD). A Web Clipper, to save web pages and screenshots from your browser, is also available for Firefox and Chrome. installationwindows others YosoroA beautiful Markdown Cloud Drive notebook desktop application. installationhttps://github.com/IceEnd/Yosoro","categories":[{"name":"Resource","slug":"Resource","permalink":"https://casuor.top/categories/Resource/"}],"tags":[]},{"title":"Windows10必备自启动效率工具","slug":"res-Tools","date":"2020-03-12T16:00:00.000Z","updated":"2020-10-28T09:58:54.890Z","comments":true,"path":"2020/03/13/res-Tools/","link":"","permalink":"https://casuor.top/2020/03/13/res-Tools/","excerpt":"","text":"windows10 必备自启动效率工具QuickLook开源地址https://github.com/QL-Win/QuickLook 功能简介 移植mac的一键预览功能 1.下载 建议直接在Microsoft Store搜索下载 2.使用 3.支持文件类型 PS:插件安装等详情需前往官网查看 EarTrumpet开源地址https://github.com/File-New-Project/EarTrumpet 功能简介 Volume Control for Windows 1.下载 建议直接在Microsoft Store搜索下载 2.使用 ①自定义快捷键 ②鼠标滚轮调节音量 3.预览 Snipaste开源地址https://zh.snipaste.com/ 功能简介 截图 + 贴图 1.下载 建议直接在Microsoft Store搜索下载 2.使用 截图默认为 F1，贴图为 F3 Snipaste更多高阶技巧 uTools官网https://u.tools/ PS:基于electron前端开发,社区贡献者巨多,并非开源,但也不收费 功能简介 程序快速启动器+庞大的插件系统 1.下载 [官网直达] 2.使用 [alt+space]无限可能 uTools更多技巧 3.预览 天若OCR开源版开源地址https://github.com/AnyListen/tianruoocr PS:作者基于@天若幽心 开源的代码进行完善制作而成,已停止维护. 作者维护的同类型项目:树洞ocr 功能简介 简单来说:文字识别提取,翻译,排版等 1.下载 天若OCR开源版 树洞OCR 2.使用","categories":[{"name":"Resource","slug":"Resource","permalink":"https://casuor.top/categories/Resource/"}],"tags":[]},{"title":"Taylor Swift","slug":"pic-Taylor","date":"2020-03-11T16:00:00.000Z","updated":"2020-10-28T09:58:54.887Z","comments":true,"path":"2020/03/12/pic-Taylor/","link":"","permalink":"https://casuor.top/2020/03/12/pic-Taylor/","excerpt":"","text":"声明: 本图源自:WallpaperAbyss一个不错的搜图网站","categories":[],"tags":[{"name":"Picture","slug":"Picture","permalink":"https://casuor.top/tags/Picture/"}]},{"title":"Oh-my-posh for Windows","slug":"geek_ohmyposhl","date":"2020-01-23T16:00:00.000Z","updated":"2020-10-28T09:58:54.885Z","comments":true,"path":"2020/01/24/geek_ohmyposhl/","link":"","permalink":"https://casuor.top/2020/01/24/geek_ohmyposhl/","excerpt":"","text":"oh my posh for windowsmaininstall&amp;config for powershellInstall-Module posh-git -Scope CurrentUser Install-Module oh-my-posh -Scope CurrentUser $profile cd C:\\Users\\16877\\Documents\\WindowsPowerShell\\ ls New-Item &quot;Microsoft.PowerShell_profile.ps1&quot; -type file code Microsoft.PowerShell_profile.ps1 Import-Module posh-git Import-Module oh-my-posh Set-Theme Paradoxdetail for teminal{ &quot;$schema&quot;: &quot;https://aka.ms/terminal-profiles-schema&quot;, &quot;globals&quot; : { &quot;alwaysShowTabs&quot; : true, &quot;copyOnSelect&quot; : false, &quot;defaultProfile&quot;: &quot;{61c54bbd-c2c6-5271-96e7-009a87ff44bf}&quot;, &quot;initialCols&quot; : 90, &quot;initialRows&quot; : 30, &quot;requestedTheme&quot; : &quot;system&quot;, &quot;showTabsInTitlebar&quot; : true, &quot;showTerminalTitleInTitlebar&quot; : true, &quot;wordDelimiters&quot; : &quot; ./\\\\()\\&quot;&apos;-:,.;&lt;&gt;~!@#$%^&amp;*|+=[]{}~?\\u2502&quot; }, &quot;profiles&quot;: [ { &quot;guid&quot;: &quot;{61c54bbd-c2c6-5271-96e7-009a87ff44bf}&quot;, &quot;name&quot;: &quot;Windows PowerShell&quot;, &quot;commandline&quot;: &quot;powershell.exe&quot;, &quot;hidden&quot;: false, &quot;acrylicOpacity&quot;: 0.9, &quot;colorScheme&quot;: &quot;MaterialDark&quot;, &quot;cursorColor&quot;: &quot;#ffea2e&quot;, &quot;cursorShape&quot;: &quot;filledBox&quot;, &quot;fontFace&quot;: &quot;Hack&quot;, &quot;fontSize&quot;: 12, &quot;historySize&quot;: 9001, &quot;padding&quot;: &quot;0, 0, 0, 0&quot;, &quot;snapOnInput&quot;: true, &quot;startingDirectory&quot;: &quot;%USERPROFILE%&quot;, &quot;useAcrylic&quot;: true }, { &quot;guid&quot;: &quot;{0caa0dad-35be-5f56-a8ff-afceeeaa6101}&quot;, &quot;name&quot;: &quot;cmd&quot;, &quot;commandline&quot;: &quot;cmd.exe&quot;, &quot;hidden&quot;: false }, { &quot;guid&quot;: &quot;{b453ae62-4e3d-5e58-b989-0a998ec441b8}&quot;, &quot;hidden&quot;: false, &quot;name&quot;: &quot;Azure Cloud Shell&quot;, &quot;source&quot;: &quot;Windows.Terminal.Azure&quot; } ], &quot;schemes&quot;: [ { &quot;name&quot;: &quot;Solarized Dark - Patched&quot;, &quot;black&quot;: &quot;#002831&quot;, &quot;red&quot;: &quot;#d11c24&quot;, &quot;green&quot;: &quot;#738a05&quot;, &quot;yellow&quot;: &quot;#a57706&quot;, &quot;blue&quot;: &quot;#2176c7&quot;, &quot;purple&quot;: &quot;#c61c6f&quot;, &quot;cyan&quot;: &quot;#259286&quot;, &quot;white&quot;: &quot;#eae3cb&quot;, &quot;brightBlack&quot;: &quot;#475b62&quot;, &quot;brightRed&quot;: &quot;#bd3613&quot;, &quot;brightGreen&quot;: &quot;#475b62&quot;, &quot;brightYellow&quot;: &quot;#536870&quot;, &quot;brightBlue&quot;: &quot;#708284&quot;, &quot;brightPurple&quot;: &quot;#5956ba&quot;, &quot;brightCyan&quot;: &quot;#819090&quot;, &quot;brightWhite&quot;: &quot;#fcf4dc&quot;, &quot;background&quot;: &quot;#001e27&quot;, &quot;foreground&quot;: &quot;#708284&quot; }, { &quot;background&quot;: &quot;#282C34&quot;, &quot;black&quot;: &quot;#282C34&quot;, &quot;blue&quot;: &quot;#61AFEF&quot;, &quot;brightBlack&quot;: &quot;#5A6374&quot;, &quot;brightBlue&quot;: &quot;#61AFEF&quot;, &quot;brightCyan&quot;: &quot;#56B6C2&quot;, &quot;brightGreen&quot;: &quot;#98C379&quot;, &quot;brightPurple&quot;: &quot;#C678DD&quot;, &quot;brightRed&quot;: &quot;#E06C75&quot;, &quot;brightWhite&quot;: &quot;#DCDFE4&quot;, &quot;brightYellow&quot;: &quot;#E5C07B&quot;, &quot;cyan&quot;: &quot;#56B6C2&quot;, &quot;foreground&quot;: &quot;#DCDFE4&quot;, &quot;green&quot;: &quot;#98C379&quot;, &quot;name&quot;: &quot;One Half Dark&quot;, &quot;purple&quot;: &quot;#C678DD&quot;, &quot;red&quot;: &quot;#E06C75&quot;, &quot;white&quot;: &quot;#DCDFE4&quot;, &quot;yellow&quot;: &quot;#E5C07B&quot; }, { &quot;name&quot;: &quot;Material&quot;, &quot;black&quot;: &quot;#002831&quot;, &quot;red&quot;: &quot;#b7141f&quot;, &quot;green&quot;: &quot;#457b24&quot;, &quot;yellow&quot;: &quot;#f6981e&quot;, &quot;blue&quot;: &quot;#134eb2&quot;, &quot;purple&quot;: &quot;#560088&quot;, &quot;cyan&quot;: &quot;#0e717c&quot;, &quot;white&quot;: &quot;#efefef&quot;, &quot;brightBlack&quot;: &quot;#424242&quot;, &quot;brightRed&quot;: &quot;#e83b3f&quot;, &quot;brightGreen&quot;: &quot;#7aba3a&quot;, &quot;brightYellow&quot;: &quot;#ffea2e&quot;, &quot;brightBlue&quot;: &quot;#54a4f3&quot;, &quot;brightPurple&quot;: &quot;#aa4dbc&quot;, &quot;brightCyan&quot;: &quot;#26bbd1&quot;, &quot;brightWhite&quot;: &quot;#d9d9d9&quot;, &quot;background&quot;: &quot;#eaeaea&quot;, &quot;foreground&quot;: &quot;#232322&quot; }, { &quot;name&quot;: &quot;MaterialDark&quot;, &quot;black&quot;: &quot;#212121&quot;, &quot;red&quot;: &quot;#b7141f&quot;, &quot;green&quot;: &quot;#457b24&quot;, &quot;yellow&quot;: &quot;#f6981e&quot;, &quot;blue&quot;: &quot;#134eb2&quot;, &quot;purple&quot;: &quot;#560088&quot;, &quot;cyan&quot;: &quot;#0e717c&quot;, &quot;white&quot;: &quot;#efefef&quot;, &quot;brightBlack&quot;: &quot;#424242&quot;, &quot;brightRed&quot;: &quot;#e83b3f&quot;, &quot;brightGreen&quot;: &quot;#7aba3a&quot;, &quot;brightYellow&quot;: &quot;#ffea2e&quot;, &quot;brightBlue&quot;: &quot;#54a4f3&quot;, &quot;brightPurple&quot;: &quot;#aa4dbc&quot;, &quot;brightCyan&quot;: &quot;#26bbd1&quot;, &quot;brightWhite&quot;: &quot;#d9d9d9&quot;, &quot;background&quot;: &quot;#001e27&quot;, &quot;foreground&quot;: &quot;#e5e5e5&quot; } ], &quot;keybindings&quot;: [ { &quot;command&quot;: &quot;closePane&quot;, &quot;keys&quot;: [ &quot;ctrl+w&quot; ] }, { &quot;command&quot;: &quot;copy&quot;, &quot;keys&quot;: [ &quot;ctrl+c&quot; ] }, { &quot;command&quot;: &quot;duplicateTab&quot;, &quot;keys&quot;: [ &quot;ctrl+shift+d&quot; ] }, { &quot;command&quot;: &quot;newTab&quot;, &quot;keys&quot;: [ &quot;ctrl+N&quot; ] }, { &quot;command&quot;: &quot;newTabProfile0&quot;, &quot;keys&quot;: [ &quot;ctrl+shift+1&quot; ] }, { &quot;command&quot;: &quot;newTabProfile1&quot;, &quot;keys&quot;: [ &quot;ctrl+shift+2&quot; ] }, { &quot;command&quot;: &quot;newTabProfile2&quot;, &quot;keys&quot;: [ &quot;ctrl+shift+3&quot; ] }, { &quot;command&quot;: &quot;newTabProfile3&quot;, &quot;keys&quot;: [ &quot;ctrl+shift+4&quot; ] }, { &quot;command&quot;: &quot;newTabProfile4&quot;, &quot;keys&quot;: [ &quot;ctrl+shift+5&quot; ] }, { &quot;command&quot;: &quot;newTabProfile5&quot;, &quot;keys&quot;: [ &quot;ctrl+shift+6&quot; ] }, { &quot;command&quot;: &quot;newTabProfile6&quot;, &quot;keys&quot;: [ &quot;ctrl+shift+7&quot; ] }, { &quot;command&quot;: &quot;newTabProfile7&quot;, &quot;keys&quot;: [ &quot;ctrl+shift+8&quot; ] }, { &quot;command&quot;: &quot;newTabProfile8&quot;, &quot;keys&quot;: [ &quot;ctrl+shift+9&quot; ] }, { &quot;command&quot;: &quot;nextTab&quot;, &quot;keys&quot;: [ &quot;ctrl+tab&quot; ] }, { &quot;command&quot;: &quot;openNewTabDropdown&quot;, &quot;keys&quot;: [ &quot;ctrl+shift+space&quot; ] }, { &quot;command&quot;: &quot;openSettings&quot;, &quot;keys&quot;: [ &quot;ctrl+,&quot; ] }, { &quot;command&quot;: &quot;paste&quot;, &quot;keys&quot;: [ &quot;ctrl+shift+v&quot; ] }, { &quot;command&quot;: &quot;prevTab&quot;, &quot;keys&quot;: [ &quot;ctrl+shift+tab&quot; ] }, { &quot;command&quot;: &quot;scrollDown&quot;, &quot;keys&quot;: [ &quot;ctrl+shift+down&quot; ] }, { &quot;command&quot;: &quot;scrollDownPage&quot;, &quot;keys&quot;: [ &quot;ctrl+shift+pgdn&quot; ] }, { &quot;command&quot;: &quot;scrollUp&quot;, &quot;keys&quot;: [ &quot;ctrl+shift+up&quot; ] }, { &quot;command&quot;: &quot;scrollUpPage&quot;, &quot;keys&quot;: [ &quot;ctrl+shift+pgup&quot; ] }, { &quot;command&quot;: &quot;switchToTab0&quot;, &quot;keys&quot;: [ &quot;ctrl+alt+1&quot; ] }, { &quot;command&quot;: &quot;switchToTab1&quot;, &quot;keys&quot;: [ &quot;ctrl+alt+2&quot; ] }, { &quot;command&quot;: &quot;switchToTab2&quot;, &quot;keys&quot;: [ &quot;ctrl+alt+3&quot; ] }, { &quot;command&quot;: &quot;switchToTab3&quot;, &quot;keys&quot;: [ &quot;ctrl+alt+4&quot; ] }, { &quot;command&quot;: &quot;switchToTab4&quot;, &quot;keys&quot;: [ &quot;ctrl+alt+5&quot; ] }, { &quot;command&quot;: &quot;switchToTab5&quot;, &quot;keys&quot;: [ &quot;ctrl+alt+6&quot; ] }, { &quot;command&quot;: &quot;switchToTab6&quot;, &quot;keys&quot;: [ &quot;ctrl+alt+7&quot; ] }, { &quot;command&quot;: &quot;switchToTab7&quot;, &quot;keys&quot;: [ &quot;ctrl+alt+8&quot; ] }, { &quot;command&quot;: &quot;switchToTab8&quot;, &quot;keys&quot;: [ &quot;ctrl+alt+9&quot; ] } ] }ExtrafontHackCascadia Code colortoolscoop install colortool # 注：-s 代表 schemes colortool -s # 临时查看 colortool &lt;主题名称&gt; # 定义默认值 colortool -d &lt;主题名称&gt;preview ReferenceOh my posh","categories":[{"name":"Geek","slug":"Geek","permalink":"https://casuor.top/categories/Geek/"}],"tags":[]},{"title":"Oh-my-zsh for Manjaro","slug":"geek_oh-my-zsh","date":"2020-01-12T16:00:00.000Z","updated":"2021-04-18T03:31:24.535Z","comments":true,"path":"2020/01/13/geek_oh-my-zsh/","link":"","permalink":"https://casuor.top/2020/01/13/geek_oh-my-zsh/","excerpt":"","text":"oh my zshinstallinstall zsh#查看是否已安装 zsh --version ＃查看已安装的shell cat /etc/shells #安装zsh yay -S zsh #pacman -S zsh #切换为zsh #chsh -s /bin/zsh chsh -s $(which zsh) #查看当前shell #$SHELL --version echo $SHELLinstall oh-my-zshsh -c &quot;$(curl -fsSL https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh)&quot; sh -c &quot;$(wget https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh -O -)&quot;themedirectorycd ~/.oh-my-zsh/themes lschangenano ~/.zshrc #ZSH_THEME=&quot;agnoster&quot; #为agnoster添加时间显示 echo &quot;RPROMPT=&apos;[%*]&apos;&quot; &gt;&gt; $ZSH/themes/agnoster.zsh-theme source ~/.zshrcedit zsh-themeagnoster.zsh-theme confcode agnoster.zsh-theme [Powerline-patched font]In order for this theme to render correctly, you will need a [Powerline-patched font] PS:已经有了，不用安装 [Solarized theme]默认为dark,可切换light [Show informations]Like most prompts, it will only show git information when in a git working directory.However, it goes a step further: everything from the current user andhostname to whether the last call exited with an error to whether backgroundjobs are running in this shell will all be displayed automatically whenappropriate. PS:并非所有theme显示时间 edit# Context: user@hostname (who am I and where am I) #user@hostname &lt;=&gt; %n@%m #太长删其一即可 prompt_context() { if [[ &quot;$USER&quot; != &quot;$DEFAULT_USER&quot; || -n &quot;$SSH_CLIENT&quot; ]]; then prompt_segment black default &quot;%(!.%{%F{yellow}%}.)%n@%m&quot; fi } pluginsｄefault＃tlsr cd ~/.oh-my-zsh/plugins ls启用插件nano ~/.zshrc #plugins=(git zsh-syntax-highlighting zsh-autosuggestions git-open vscode npm npx sublime z)PS:空格问题 custome Also follow these steps if you want to override plugins that ship with your oh-my-zsh installation. To override a plugin with a custom version, put your custom version at $ZSH_CUSTOM/plugins//. For example, if it’s the rvm plugin you want to override, create the directory custom/plugins/rvm and place a file called rvm.plugin.zsh inside of it. PS:dont remember add &lt;plugin_name&gt; to .zshrc example1.Clone this repository in oh-my-zsh’s plugins directory: git clone https://github.com/zsh-users/zsh-syntax-highlighting.git ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-syntax-highlightingPS:自定义plugins-locationgit clone url ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/plugins-name,额不早为啥这样写，应该是和~/.zshrc文件相关 2.Activate the plugin in ~/.zshrc: plugins=( [plugins...] zsh-syntax-highlighting)3.Restart zsh (such as by opening a new instance of your terminal emulator). last preview","categories":[{"name":"Geek","slug":"Geek","permalink":"https://casuor.top/categories/Geek/"}],"tags":[]},{"title":"Manjaro install","slug":"geek_manjaroinstall","date":"2020-01-09T16:00:00.000Z","updated":"2020-10-28T09:58:54.884Z","comments":true,"path":"2020/01/10/geek_manjaroinstall/","link":"","permalink":"https://casuor.top/2020/01/10/geek_manjaroinstall/","excerpt":"","text":"manjaro config sudo pacman-mirrors -i -c China -m rank sudo pacman -Syy sudo pacman -S nano nano /etc/pacman.conf [archlinuxcn] SigLevel = Optional TrustedOnly Server = https://mirrors.ustc.edu.cn/archlinuxcn/$arch sudo pacman -S archlinuxcn-keyring sudo pacman -Syyu sudo pacman -S fcitx-im #全部安装 sudo pacman -S fcitx-configtool sudo pacman -S fcitx-sogoupinyin nano ~/.xprofile export GTK_IM_MODULE=fcitx export QT_IM_MODULE=fcitx export XMODIFIERS=&quot;@im=fcitx&quot; #restart sudo pacman -S yay yay -S octopi[application list]latte-dock layout latte-dock typora chrome visual studio code jetbrains-toolbox wps-office sudo pacman -S wps-office-mui-zh-cn sudo pacman -S ttf-wps-fonts electron-netease-cloud-music bleachbit baidunetdisk spotify zsh sudo nano /etc/hosts 199.232.28.133 raw.githubusercontent.com sh -c &quot;$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)&quot; sh -c &quot;$(wget -O- https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)&quot; git clone https://github.com/zsh-users/zsh-syntax-highlighting.git ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-syntax-highlighting git clone git://github.com/zsh-users/zsh-autosuggestions $ZSH_CUSTOM/plugins/zsh-autosuggestions git clone https://github.com/paulirish/git-open.git $ZSH_CUSTOM/plugins/git-open git clone https://github.com/lukechilds/zsh-nvm ~/.oh-my-zsh/custom/plugins/zsh-nvm #Zsh plugin for installing, updating and loading nvm #地址：https://github.com/lukechilds/zsh-nvm sudo pacman -S autojump #plugins=(git zsh-syntax-highlighting zsh-autosuggestions git-open vscode sublime z zsh-nvm autojump) #source ~/.zshrc nvm install 12.16.2 npm install nrm -g nrm use taobao [ssr配置](https://www.jianshu.com/p/1a1bbff13e22) wget http://www.djangoz.com/ssr#//github.com/the0demiurge/CharlesScripts/blob/master/charles/bin/ssr sudo mv ssr /usr/local/bin sudo chmod 766 /usr/local/bin/ssr ssr install ssr config #设置开机启动 #在/usr/lib/systemd/system/中加入ssr.service [Unit] Description=AutoRunSSR [Service] Type=forking ExecStart=ssr start [Install] WantedBy=multi-user.target systemctl enable ssr.service systemctl start ssr.service #查看状态 systemctl status ssr.service","categories":[{"name":"Geek","slug":"Geek","permalink":"https://casuor.top/categories/Geek/"}],"tags":[]},{"title":"Nano keyboard shortcuts","slug":"geek_nano-help","date":"2020-01-05T16:00:00.000Z","updated":"2021-03-16T10:31:25.881Z","comments":true,"path":"2020/01/06/geek_nano-help/","link":"","permalink":"https://casuor.top/2020/01/06/geek_nano-help/","excerpt":"","text":"1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980Overview of nano's shortcuts The editor's keystrokes and their functions File handlingCtrl+S Save current fileCtrl+O Offer to write file (\"Save as\")Ctrl+R Insert a file into current oneCtrl+X Close buffer, exit from nanoEditingCtrl+K Cut current line into cutbufferAlt+6 Copy current line into cutbufferCtrl+U Paste contents of cutbufferAlt+T Cut until end of bufferCtrl+] Complete current wordAlt+3 Comment/uncomment line/regionAlt+U Undo last actionAlt+E Redo last undone actionSearch and replaceCtrl+Q Start backward searchCtrl+W Start forward searchAlt+Q Find next occurrence backwardAlt+W Find next occurrence forwardAlt+R Start a replacing sessionDeletionCtrl+H Delete character before cursor Ctrl+D Delete character under cursorAlt+Bsp Delete word to the leftCtrl+Del Delete word to the rightAlt+Del Delete current lineOperationsCtrl+T Execute some commandCtrl+J Justify paragraph or regionAlt+J Justify entire bufferAlt+B Run a syntax checkAlt+F Run a formatter/fixer/arrangerAlt+: Start/stop recording of macroAlt+; Replay macroMoving aroundCtrl+B One character backwardCtrl+F One character forwardCtrl+← One word backwardCtrl+→ One word forwardCtrl+A To start of lineCtrl+E To end of lineCtrl+P One line upCtrl+N One line downCtrl+↑ To previous blockCtrl+↓ To next blockCtrl+Y One page upCtrl+V One page downAlt+\\ To top of bufferAlt+/ To end of bufferSpecial movementAlt+G Go to specified lineAlt+] Go to complementary bracketAlt+↑ Scroll viewport upAlt+↓ Scroll viewport downAlt+&lt; Switch to preceding bufferAlt+&gt; Switch to succeeding bufferInformationCtrl+C Report cursor positionAlt+D Report word/line/char countCtrl+G Display help textVariousAlt+A Turn the mark on/offTab Indent marked regionShift+Tab Unindent marked regionAlt+N Turn line numbers on/offAlt+P Turn visible whitespace on/offAlt+V Enter next keystroke verbatimCtrl+L Refresh the screenCtrl+Z Suspend nano","categories":[{"name":"Geek","slug":"Geek","permalink":"https://casuor.top/categories/Geek/"}],"tags":[]},{"title":"跨平台开发NW.js与Electron(二)","slug":"geek_NWjs&Electron2","date":"2019-12-28T16:00:00.000Z","updated":"2020-10-28T09:58:54.880Z","comments":true,"path":"2019/12/29/geek_NWjs&Electron2/","link":"","permalink":"https://casuor.top/2019/12/29/geek_NWjs&Electron2/","excerpt":"","text":"为桌面应用搭建基础架构工序 构建用户使用路径创建线框图编写测试更新线框图编码确认应用工作正确 安装npm install nw npm install electron创建工作空间(略)package.json cnpm install osenv --save cnom install async --saveindex.html &lt;html&gt; &lt;head&gt; &lt;title&gt;Lorikeet&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;style.css&quot; /&gt; &lt;script src=&quot;app.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;template id=&quot;item-template&quot;&gt; &lt;div class=&quot;item&quot;&gt; &lt;img class=&quot;icon&quot; /&gt; &lt;div class=&quot;filename&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/template&gt; &lt;div id=&quot;toolbar&quot;&gt; &lt;div id=&quot;current-folder&quot;&gt; &lt;script&gt; document.write(getUsersHomeFolder()); &lt;/script&gt; &lt;/div&gt; &lt;/div&gt; &lt;div id=&quot;main-area&quot;&gt;&lt;/div&gt; &lt;/body&gt; &lt;/html&gt;app.js &apos;use strict&apos;; //cnpm install osenv --save //返回个人用户文件夹模块osenv //加载osenv模块 const osenv = require(&apos;osenv&apos;); //加载node.js文件系统模块 const fs = require(&apos;fs&apos;); //加载async模块和Node.js path模块 const async = require(&apos;async&apos;); const path = require(&apos;path&apos;); //获取个人用户文件夹路径 function getUsersHomeFolder() { return osenv.home(); } //getFilesInFoler(),获取文件夹下的列表信息 function getFilesInFoler(folderPath, cb) { fs.readdir(folderPath, cb); } //使用path模块获取文件名 function inspectAndDescribeFile(filePath, cb) { let result = { file: path.basename(filePath), path: filePath, type: &apos;&apos; }; //调用fs.stat会返回一个对象,包含文件类型 fs.stat(filePath, (err, stat) =&gt; { if (err) { cb(err); } else { if (stat.isFile()) { result.type = &apos;file&apos;; } if (stat.isDirectory()) { result.type = &apos;directory&apos;; } cb(err, result); } }); } //使用async模块调用异步函数并收集结果 function inspectAndDescribeFiles(folderPath, files, cb) { async.map(files, (file, asyncCb) =&gt; { let resolvedFilePath = path.resolve(folderPath, file); inspectAndDescribeFile(resolvedFilePath, asyncCb); }, cb); } //创建displayFile函数渲染模版实例 function displayFile(file) { const mainArea = document.getElementById(&apos;main-area&apos;); const template = document.querySelector(&apos;#item-template&apos;); let clone = document.importNode(template.content, true); clone.querySelector(&apos;img&apos;).src = `images/${file.type}.svg`; clone.querySelector(&apos;.filename&apos;).innerText = file.file; mainArea.appendChild(clone); } //创建displayFiles函数来显示列表信息 function displayFiles(err, files) { if (err) { return alert(&apos;对不起,无法显示此文件&apos;); } files.forEach(displayFile); //在displayFiles中将文件信息传递给displayFile函数 } //main(),调用该函数并将用户个人文件夹路径作为参数传递进去, //再将获取到的包含所有文件绝对路径的列表在控制台打印出来 function main() { let folderPath = getUsersHomeFolder(); getFilesInFoler(folderPath, (err, files) =&gt; { if (err) { return alert(&apos;对不起,无法加载你的Home&apos;); } inspectAndDescribeFiles(folderPath, files, displayFiles); }); } main();style.css body { padding: 0; margin: 0; font-family: &apos;Helvetica&apos;, &apos;Arial&apos;, &apos;sans&apos;; } #toolbar { top: 0px; position: fixed; background: rgb(12, 59, 97); width: 100%; z-index: 2; } #current-folder { float: left; color: white; background: rgba(0, 0, 0, 0.5); padding: 0.5em 1em; min-width: 10em; border-radius: 0.2em; margin: 1em; } #main-area { clear: both; margin: 2em; margin-top: 3em; z-index: 1; } .item { position: relative; float: left; padding: 1em; margin: 1em; width: 6em; height: 6em; text-align: center; } .item .filename { padding-top: 1em; font-size: 10pt; }","categories":[{"name":"Geek","slug":"Geek","permalink":"https://casuor.top/categories/Geek/"}],"tags":[]},{"title":"epub格式解析","slug":"geek_epub格式解析","date":"2019-12-25T16:00:00.000Z","updated":"2020-10-28T09:58:54.882Z","comments":true,"path":"2019/12/26/geek_epub格式解析/","link":"","permalink":"https://casuor.top/2019/12/26/geek_epub%E6%A0%BC%E5%BC%8F%E8%A7%A3%E6%9E%90/","excerpt":"","text":"epub格式解析Referenceepub格式解析生成Kindle可读的mobi和PDF电子书 Content一个标准的未加密的 epub 电子书大致由以下三部分组成： META-INF文件夹:包含container.xmlOEBPS文件夹:包含 images，xhtml文件，css样式和 content.opf 文件mimetype:内容为 application/epub+zip META-INF文件夹META-INF 用于存放电子书信息，默认情况包含一个 container.xml 文件： &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;container version=&quot;1.0&quot; xmlns=&quot;urn:oasis:names:tc:opendocument:xmlns:container&quot;&gt; &lt;rootfiles&gt; &lt;rootfile full-path=&quot;OEBPS/content.opf&quot; media-type=&quot;application/oebps-package+xml&quot;/&gt; &lt;/rootfiles&gt; &lt;/container&gt;该文件告诉电子书阅读器，文件的根文件路径和格式。除去 container.xml 文件外，标准还规定了其他可选文件： manifest.xml 文件列表metadata.xml 元数据sigatures.xml 数字签名encryption.xml 加密rights.xml 权限管理 OEBPS文件夹OPF文件opf 文件是 epub 最为重要的文件，是标准的 xml 文件，文件的根元素是 &lt;package&gt; &lt;package version=&quot;2.0&quot; unique-identifier=&quot;BookId&quot; xmlns=&quot;http://www.idpf.org/2007/opf&quot;&gt;此文件的主要内容由下面组成： 第一部分，&lt;metadata&gt; 元数据，包含书籍的出版信息，主要由两个子元素组成 dc:metadata 元素，使用 Dublin Core， 包含 15 项核心元素：dc:titledc:creator 责任者dc:subject 主题关键词dc:descriptiondc:publisherdc:contributordc:datedc:typedc:formatdc:identifierdc:source 来源dc:languagedc:relationdc:coverage 覆盖范围dc:rights 权限描述 meta 标签，扩展元素，如果有信息在上面标签中无法描述，则扩展到该meta中 举例 &lt;metadata xmlns:opf=&quot;http://www.idpf.org/2007/opf&quot; xmlns:dc=&quot;http://purl.org/dc/elements/1.1/&quot;&gt; &lt;dc:language&gt;zh-CN&lt;/dc:language&gt; &lt;dc:title&gt;圣殿春秋&lt;/dc:title&gt; &lt;dc:creator opf:role=&quot;aut&quot; opf:file-as=&quot;雨浪飘零&quot;&gt;『英』肯·福莱特&lt;/dc:creator&gt; &lt;dc:publisher&gt;上海译文出版社&lt;/dc:publisher&gt; &lt;meta content=&quot;0.9.6&quot; name=&quot;Sigil version&quot; /&gt; &lt;dc:date xmlns:opf=&quot;http://www.idpf.org/2007/opf&quot; opf:event=&quot;modification&quot;&gt;2016-07-16&lt;/dc:date&gt; &lt;dc:identifier opf:scheme=&quot;UUID&quot; id=&quot;BookId&quot;&gt;urn:uuid:97cabb7a-2ab9-4fe2-a56b-c075114f2187&lt;/dc:identifier&gt; &lt;meta name=&quot;cover&quot; content=&quot;cover.jpg&quot; /&gt; &lt;/metadata&gt;第二部分为 &lt;mainfest&gt; 文件列表，该列表中包含出版物的所有文件，每一行由一个item构成 &lt;item id=&quot;ncx&quot; href=&quot;toc.ncx&quot; media-type=&quot;application/x-dtbncx+xml&quot;/&gt;其中： id 为文件 id href 为文件相对路径 media-type 为文件的媒体类型 &lt;manifest&gt; &lt;item id=&quot;ncx&quot; href=&quot;toc.ncx&quot; media-type=&quot;application/x-dtbncx+xml&quot;/&gt; &lt;item id=&quot;Preface03.xhtml&quot; href=&quot;Text/Preface03.xhtml&quot; media-type=&quot;application/xhtml+xml&quot;/&gt; &lt;item id=&quot;Part00.xhtml&quot; href=&quot;Text/Part00.xhtml&quot; media-type=&quot;application/xhtml+xml&quot;/&gt; &lt;item id=&quot;Part01.xhtml&quot; href=&quot;Text/Part01.xhtml&quot; media-type=&quot;application/xhtml+xml&quot;/&gt; &lt;item id=&quot;Part02.xhtml&quot; href=&quot;Text/Part02.xhtml&quot; media-type=&quot;application/xhtml+xml&quot;/&gt; &lt;item id=&quot;appendix.xhtml&quot; href=&quot;Text/appendix.xhtml&quot; media-type=&quot;application/xhtml+xml&quot;/&gt; &lt;item id=&quot;main.css&quot; href=&quot;Styles/main.css&quot; media-type=&quot;text/css&quot;/&gt; &lt;item id=&quot;Title.xhtml&quot; href=&quot;Text/Title.xhtml&quot; media-type=&quot;application/xhtml+xml&quot;/&gt; &lt;item id=&quot;Intro1.xhtml&quot; href=&quot;Text/Intro1.xhtml&quot; media-type=&quot;application/xhtml+xml&quot;/&gt; &lt;item id=&quot;Author.html&quot; href=&quot;Text/Author.html&quot; media-type=&quot;application/xhtml+xml&quot;/&gt; &lt;item id=&quot;Preface01.xhtml&quot; href=&quot;Text/Preface01.xhtml&quot; media-type=&quot;application/xhtml+xml&quot;/&gt; &lt;item id=&quot;cover.xhtml&quot; href=&quot;Text/cover.xhtml&quot; media-type=&quot;application/xhtml+xml&quot;/&gt; &lt;item id=&quot;part01.jpg&quot; href=&quot;Images/part01.jpg&quot; media-type=&quot;image/jpeg&quot;/&gt; &lt;item id=&quot;Part06_17.xhtml&quot; href=&quot;Text/Part06_17.xhtml&quot; media-type=&quot;application/xhtml+xml&quot;/&gt; &lt;item id=&quot;chapter.png&quot; href=&quot;Images/chapter.png&quot; media-type=&quot;image/png&quot;/&gt; &lt;item id=&quot;logo.png&quot; href=&quot;Images/logo.png&quot; media-type=&quot;image/png&quot;/&gt; &lt;item id=&quot;cover.jpg&quot; href=&quot;Images/cover.jpg&quot; media-type=&quot;image/jpeg&quot;/&gt; &lt;item id=&quot;cover_slim.jpg&quot; href=&quot;Images/cover~slim.jpg&quot; media-type=&quot;image/jpeg&quot;/&gt; &lt;item id=&quot;Monarch.ttf&quot; href=&quot;Fonts/Monarch.ttf&quot; media-type=&quot;application/x-font-ttf&quot;/&gt; &lt;item id=&quot;backcover.xhtml&quot; href=&quot;Text/backcover.xhtml&quot; media-type=&quot;application/xhtml+xml&quot;/&gt; &lt;item id=&quot;backcover.jpg&quot; href=&quot;Images/backcover.jpg&quot; media-type=&quot;image/jpeg&quot;/&gt; &lt;item id=&quot;backcover_slim.jpg&quot; href=&quot;Images/backcover~slim.jpg&quot; media-type=&quot;image/jpeg&quot;/&gt; &lt;item id=&quot;Info.xhtml&quot; href=&quot;Text/Info.xhtml&quot; media-type=&quot;application/xhtml+xml&quot;/&gt; &lt;/manifest&gt;第三部分为&lt;spine toc=&quot;ncx&quot;&gt;提供图书线性阅读的次序，由子元素 itemref 组成 &lt;itemref idref=&quot;cover.xhtml&quot;&gt;其中 idref 为 manifest 中列出的 id &lt;spine toc=&quot;ncx&quot;&gt; &lt;itemref idref=&quot;cover&quot; /&gt; &lt;itemref idref=&quot;copyright&quot; /&gt; &lt;/spine&gt;第四部分为 &lt;guide&gt; ，列出了电子书的特定页面，比如封面，目录，序言等等，属性值指向文件地址。该部分可选。 &lt;guide&gt; &lt;reference type=&quot;cover&quot; title=&quot;封面&quot; href=&quot;Text/cover.xhtml&quot;/&gt; &lt;/guide&gt;第五部分，&lt;tour&gt; 导读，根据读者的不同水平，按照一定次序选择电子书部分页面组成导读，可选。 NCX文件ncx文件也是 epub 中非常重要的文件，该文件用于电子书的目录，文件命名通常为 toc.ncx，ncx 文件也是一个 xml 文件。ncx 全称为 Navigation Center eXtended。 ncx文件中最主要的节点是 navMap，navMap节点又由很多 navPoint 节点组成，navPoint 节点由 navLabel 和 content 节点组成。 &lt;navMap&gt; &lt;navPoint id=&quot;navPoint-1&quot; playOrder=&quot;1&quot;&gt; &lt;navLabel&gt; &lt;text&gt;圣殿春秋&lt;/text&gt; &lt;/navLabel&gt; &lt;content src=&quot;Text/cover.xhtml&quot;/&gt; &lt;navPoint id=&quot;navPoint-2&quot; playOrder=&quot;2&quot;&gt; &lt;navLabel&gt; &lt;text&gt;作品简介&lt;/text&gt; &lt;/navLabel&gt; &lt;content src=&quot;Text/Intro1.xhtml&quot;/&gt; &lt;/navPoint&gt; ... &lt;navPoint id=&quot;navPoint-7&quot; playOrder=&quot;7&quot;&gt; &lt;navLabel&gt; &lt;text&gt;前言&lt;/text&gt; &lt;/navLabel&gt; &lt;content src=&quot;Text/Preface03.xhtml&quot;/&gt; &lt;/navPoint&gt; &lt;/navPoint&gt; &lt;/navMap&gt; navPoint 节点中，playOrder 属性定义当前项在目录中的次序，text 子节点则定义了目录的名字 content 子节点 src 属性定义了章节文件的具体位置 navPoint 节点可以嵌套，形成了整本书的层级结构。 opf 文件定义了读者在顺序阅读时用到的章节和顺序，而 ncx 文件则定义了目录中用到的章节和顺序。如果存在附录形式的内容，希望在目录中出现，而不希望在正文中出现时，而已通过设置两个不同来达到目的。 在了解了这些标准内容之后，解析 epub 格式就比较简单了，python 可以使用 ebooklib 这个库。他的使用相对比较简单，也就一个 epub 类，具体使用可以参考 GitHub，不过需要注意的是很多 epub 格式的书并没有完全按照标准生成，所以有些地方还得自己 hack。","categories":[{"name":"Geek","slug":"Geek","permalink":"https://casuor.top/categories/Geek/"}],"tags":[]},{"title":"知乎-什么样的男生注定单身?","slug":"trans-知乎-什么样的男生注定单身","date":"2019-12-25T16:00:00.000Z","updated":"2020-10-28T09:58:54.892Z","comments":true,"path":"2019/12/26/trans-知乎-什么样的男生注定单身/","link":"","permalink":"https://casuor.top/2019/12/26/trans-%E7%9F%A5%E4%B9%8E-%E4%BB%80%E4%B9%88%E6%A0%B7%E7%9A%84%E7%94%B7%E7%94%9F%E6%B3%A8%E5%AE%9A%E5%8D%95%E8%BA%AB/","excerpt":"","text":"State文章内容转载自:知乎-什么样的男生注定单身?侵删,联系方式 Content 1、目测条件一般，有自己的想法和见地，看过一些书，情商也不低，不会显得急不可待，语出惊人。看上去介于单调和闷之间，但内心怀有强烈的情感。一般不会显得浮躁，在熟人面前幽默感爆棚，在陌生人面前不会特意表现自己，但跟女生一说话，就有种难以掩饰的微尬和不自然。 2、不会帅得在人群中引起骚动，也不会丑得让人扭头就走，看上去就不太像个有故事的人。可能穿得比较干净，但一定不潮，内心深处，想摆脱肤浅，容易自省，跟大家吐槽的俗low男不沾边，动不动容易觉得特别。 3、不擅长KTV，篮球，可能会喜欢跑步，看书，思想逻辑类的事物，但优点都不具备那种直观可展示性，常常沦为大型聚会的配角，但也不会夸张的卖弄自己。 4、内心戏很丰富，对所追求的爱情，脑海中有一幅自己的想象蓝图。没事不会主动找女生，对有感觉的女生，在微信聊天中对用到的表情包，标点，波浪线都有思考，并且使之尽量看起来装作随性自然，不敢喋喋不休地打扰，很怕被嫌弃，越界，导致很少产生亲密关系。 5、在精神和道德上容易自我感觉良好，常常要用尊严掩饰自卑，学不会不要脸，无法像舔狗一样存活，但生活也没给他一个机会来检验自己是不是舔狗。 6、对感情上有洁癖，对爱情本身的向往超过爱一个具体的人，内心多年保持一种在精神层面对美好事物的追求，不想随便找一个女朋友破坏了自己内心多年来对爱情的想象。 7、看着青春气数已尽，在岁月狂奔的途中，有情人结成眷侣的背景下，会回过头来观察自己，发现自己一直是孤家寡人，而别人一不小心已经有了前前任了。会冷静或者极度失望地对自己挑刺，容易感到气馁无望，进一步增长对情感和未来的焦虑和渴求。 8、工作和生活以及爱好，稳定得像一潭死水，生活中连公车时刻表都难得出错，更不会有意外的人事出现打破你的生活轨迹，难有一个可撬动的点来系统的改变些什么，感情空白或者一直处于空白状态是大几率事件。 9、明明没什么情感经历，生活也平淡如水，但随着年龄渐长，不知不觉熬出了身心的沧桑感。 10、常年容易装作不屑，也容易孤单，在生活中一点一点被动妥协后，容易失去存在感，容易漫不经心，在皆随他去和求而不得中，平静如日，不出意外的话可以一举单身到70岁。 discuss 很有趣,评论也是有趣,说是巴纳姆效应又称福勒效应，星相效应，是1948年由心理学家伯特伦·福勒通过试验证明的一种心理学现象，人们常常认为一种笼统的、一般性的人格描述十分准确地揭示了自己的特点，当人们用一些普通、含糊不清、广泛的形容词来描述一个人的时候，人们往往很容易就接受这些描述，并认为描述中所说的就是自己。 个人观点:是生活中有如上描述的人,举个例子哈：比如他他他他，额好了，而这个效应也不是适用所有类似的人。心理学上这是个不错的方法，嘿嘿嘿。","categories":[{"name":"Transfer","slug":"Transfer","permalink":"https://casuor.top/categories/Transfer/"}],"tags":[]},{"title":"跨平台开发NW.js与Electron(一)","slug":"geek_NWjs&Electron1","date":"2019-12-24T16:00:00.000Z","updated":"2020-10-28T09:58:54.879Z","comments":true,"path":"2019/12/25/geek_NWjs&Electron1/","link":"","permalink":"https://casuor.top/2019/12/25/geek_NWjs&Electron1/","excerpt":"","text":"Node.js桌面应用优势之一 通常，开发桌面应用要求开发者们精通像C++、Objective-C，或者C#这样的语言以及像.NET、Qt、Cocoa或者GTK这样的框架。对于部分开发者而言，准入门槛有点高，很可能会放弃使用这些技术来构建桌面应用。像Electron和NWjs这样的Nodejs桌面应用框架最棒的地方就在于它&gt;们大大降低了开发者的准入门槛。支持开发者使用HTML、CSS和J&gt;avaScript开发桌面应用，而且还可以在Web应用和桌面应用之间共享同一份代码，这无异于是给Web开发者打开了一扇通往成为桌面应用开发者的门。 缘起Referencebook:跨平台桌面应用开发 基于Electron与NW.JS site:历史细节Electron Is Electron originally forked from NW.js, or is it just inspired by NW.js (if so, is it a fork of any existing repository) ?两框架对比技术差异NW.js vs electronNW.js中文网演变node-webkit—&gt;NW.jsAtom Shell —&gt;Electron NW.jsReferenceCross Platform Desktop Applications NW.js介绍安装NW.js cnpm install -g nw构建hello-world应用package.json { &quot;name&quot; : &quot;hello world nwjs&quot;, &quot;main&quot; : &quot;index.html&quot;, &quot;version&quot; : &quot;1.0.0&quot; }index.html &lt;html&gt; &lt;head&gt; &lt;title&gt;Hello World&lt;/title&gt; &lt;style&gt; body { background-image: linear-gradient(45deg, #EAD790 0%, #EF8C53 100%); text-align: center; } button { background: rgba(0,0,0,0.40); box-shadow: 0px 0px 4px 0px rgba(0,0,0,0.50); border-radius: 8px; color: white; padding: 1em 2em; border: none; font-family: &apos;Roboto&apos;, sans-serif; font-weight: 100; font-size: 14pt; position: relative; top: 40%; cursor: pointer; outline: none; } button:hover { background: rgba(0,0,0,0.30); } &lt;/style&gt; &lt;link href=&apos;https://fonts.googleapis.com/css?family=Roboto:300&apos; rel=&apos;stylesheet&apos; type=&apos;text/css&apos;&gt; &lt;script&gt; function sayHello () { alert(&apos;Hello World&apos;); } &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;button onclick=&quot;sayHello()&quot;&gt;Say Hello&lt;/button&gt; &lt;/body&gt; &lt;/html&gt;nw即可运行 NW.js有哪些特性 通过JS访问操作系统原生的UI和API 控制应用视窗的大小和行为在应用视窗中显示菜单项的工具条在用户右击的时候，在应用视窗中添加上下文菜单。在操作系统托盘菜单中添加应用的菜单项。访问操作系统的剪贴板，读写其中的内容。使用计算机中默认指定的应用打开文件、文件夹以及URL。通过操作系统的通知系统显示通知。 在应用中使用Node.js和npm应用 web应用与NW.js开发的桌面应用的区别，后者，前后端代码的界限很模糊，因为同一段JavaScript代码共享了前后端的上下文 https://github.com/nw-cn/awesome-nwjshttps://github.com/sindresorhus/awesome 同一份代码构建支持多操作系统的应用app-&gt;npm install -g nw-builder&amp;nwbuild app/-&gt;build Electron介绍Electron是GitHub开发的桌面应用开发框架。它最早的名字叫Atom Shell，是为GitHub的文本编辑器Atom构建的。它支持使用HTML、CSS和JavaScript来构建跨平台的桌面应用。自它2013年11月发布以来，越来越流行，不少创业公司和大公司都纷纷用它来构建他们的桌面应用。不仅Atom在用Electron，连聊天应用Slack（https:/www.slack.com）的桌面客户端应用也在用，这家创业公司截至2016年4月估值已达38亿美金。 Electron是如何工作的以及它和NW.js的区别是什么1.整合chromium和Node.js的方式不同 在NW.js中,chromium是直接被打补丁打进去的,因此Node.js和chromium共享了同一个JavaScript上下文.在electron中而是通过chromium的Content API以及使用了Node.js的node_bindings 2.处理JavaScript上下文时和NW.js不同 在NW.js中,维护一个共享的JavaScript上下文在electron中,多个独立的JavaScript上下文(main&amp;renderer进程) 3.入口不同 在NW.js中,html文件为入口在electron中,js文件为入口 安装Electron cnpm install electron cnpm install nodemon构建electron hello world 应用 package.json { &quot;name&quot;: &quot;hello_world&quot;, &quot;main&quot;: &quot;main.js&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;scripts&quot;: { &quot;start&quot;: &quot;nodemon --watch main.js --exec electron .&quot; } }main.js &apos;use strict&apos;; const electron = require(&apos;electron&apos;); const app = electron.app; const BrowserWindow = electron.BrowserWindow; let mainWindow = null; app.on(&apos;window-all-closed&apos;, () =&gt; { if (process.platform !== &apos;darwin&apos;) app.quit(); }); app.on(&apos;ready&apos;, () =&gt; { mainWindow = new BrowserWindow(); mainWindow.loadURL(`file://${__dirname}/index.html`); mainWindow.on(&apos;closed&apos;, () =&gt; { mainWindow = null; }); });index.html 同上 cnpm start Electron 有哪些特性支持创建多视窗，而且每个视窗都有自己独立的JavaScript上下文。通过shell和screenAPI整合了桌面操作系统的特性。支持获取计算机电源状态。支持阻止操作系统进入省电模式（对于演示文稿类应用非常有用）。支持创建托盘应用。支持创建菜单和菜单项。支持为应用增加全局键盘快捷键。支持通过应用更新来自动更新应用代码。支持汇报程序崩溃。支持自定义Dock菜单项。支持操作系统通知。支持为应用创建启动安装器。 NW.js和Electron支持创建哪类应用ListNW.js APPSElectron APPS","categories":[{"name":"Geek","slug":"Geek","permalink":"https://casuor.top/categories/Geek/"}],"tags":[]},{"title":"Wallhaven Spider","slug":"geek-wallhavenspider","date":"2019-12-20T16:00:00.000Z","updated":"2020-10-28T09:58:54.877Z","comments":true,"path":"2019/12/21/geek-wallhavenspider/","link":"","permalink":"https://casuor.top/2019/12/21/geek-wallhavenspider/","excerpt":"","text":"referencehttps://www.cnblogs.com/simple-li/p/11202461.html 说明:初学Python,目前再啃廖雪峰的教程 额,这个写的有点问题,所以以下是改造吧,额不使用lxml也是可以的,就简单的拼接字符串问题,但效率可能慢点 otherlxml etree的用法 python中去除字符串中空白字符的最简单方法 string=&quot;hello world &quot; string.replace(&quot; &quot;,&quot;&quot;)delete blank Problem1.文件下载进程随时会出现假死状态,需要大改,并封装一下搜索下载,美滋滋 2.pychram控制台接收一个输入的网址,回车自动跳到浏览器 分析​ 1.文件读写 ​ 2.抓包,解析文件地址 ​ 3.下载文件 实现代码# 爬取某网站的壁纸图片 import os import random import requests from lxml import etree import time # 伪装浏览器 headers = { &quot;User-Agent&quot;: &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_5)AppleWebKit/537.36 (KHTML, like Gecko) Chrome/59.0.3071.104 Safari/537.36&quot;, } # 定义创建文件路径函数，将下载的文件存储到该路径 def CreatePath(filepath): if not os.path.exists(filepath): os.makedirs(filepath) # 获取壁纸首页网页信息并解析 def getUrlText(url): respons = requests.get(url, headers=headers) # 获取网页信息 urlText = respons.text html = etree.HTML(urlText) # 使用lxml解析网页 return html # 提取壁纸链接地址列表 def getWallUrl(url): hrefUrl = getUrlText(url) section = hrefUrl.xpath(&apos;//section[@class=&quot;thumb-listing-page&quot;]&apos;)[0] # 获取section标签 hrefList = section.xpath(&apos;./ul//@href&apos;) # 获取首页图片对应链接地址 return hrefList # 获取当前时间 def getTime(): nowtime = time.strftime(&apos;%Y-%m-%d %H:%M:%S&apos;, time.localtime(time.time())) return nowtime # 解析壁纸下载地址 def downWall(url, page): &apos;&apos;&apos; :param url: 网页地址 :param page: 下载页数 :return: 下载结束提醒 &apos;&apos;&apos; global i, n m = 0 page += 1 for i in range(1, page): hrefList = getWallUrl(url + str(i)) print(&apos;第&apos; + str(i) + &apos;页&apos;) print(hrefList) n = 0 print(&apos;开始下载第{}页壁纸&apos;.format(i)) for href in hrefList: n += 1 imgUrl = getUrlText(href) # 获取壁纸链接网页信息并解析 imgSrc = imgUrl.xpath(&apos;//img[@id=&quot;wallpaper&quot;]/@src&apos;)[0].strip() print(imgSrc) try: res = requests.get(imgSrc) print(res, res.status_code) pic_path = &apos;/wallpaper/Picture/&apos; + imgSrc[31:] print(pic_path) with open(pic_path, &apos;wb&apos;) as f: f.write(res.content) f.close() print(&apos;{}:第{}页第{}张壁纸下载完成&apos;.format(getTime(), i, n)) time.sleep(random.uniform(0, 3)) except Exception as e: print(repr(e)) m = m + n return print(&apos;{}:所有壁纸已下载完成，一共{}页{}张&apos;.format(getTime(), i, m)) # url = &apos;https://wallhaven.cc/search?q=id%3A711&amp;ref=fp&amp;tdsourcetag=s_pcqq_aiomsg&amp;page=&apos; def main(): filepath = (&apos;/wallpaper/Picture/&apos;) # 存储路径。 page = int(input(&apos;请输入你想下载的页数:&apos;)) CreatePath(filepath) downWall(&apos;https://wallhaven.cc/search?q=id%3A3799&amp;page=&apos;, page) if __name__ == &apos;__main__&apos;: main()","categories":[{"name":"Geek","slug":"Geek","permalink":"https://casuor.top/categories/Geek/"}],"tags":[]},{"title":"Beautiful girl","slug":"pic_beautifulgirl","date":"2019-12-20T16:00:00.000Z","updated":"2020-10-28T09:58:54.887Z","comments":true,"path":"2019/12/21/pic_beautifulgirl/","link":"","permalink":"https://casuor.top/2019/12/21/pic_beautifulgirl/","excerpt":"","text":"声明: 本图源爬取自wallhave,有任何问题联系删除","categories":[],"tags":[{"name":"Picture","slug":"Picture","permalink":"https://casuor.top/tags/Picture/"}]},{"title":"寂寞的游戏-袁哲生","slug":"reading-寂寞的游戏","date":"2019-12-19T16:00:00.000Z","updated":"2020-10-28T09:58:54.889Z","comments":true,"path":"2019/12/20/reading-寂寞的游戏/","link":"","permalink":"https://casuor.top/2019/12/20/reading-%E5%AF%82%E5%AF%9E%E7%9A%84%E6%B8%B8%E6%88%8F/","excerpt":"","text":"寂寞的游戏-袁哲生 这本书前几天了解到,吃饭时,哔哩哔哩的一个纪录片节目[但是还有书籍],胡歌配音,第一集便聊到了这本书,索性我也去瞧瞧 人一旦开始躲藏就很难停下来了,这点我始终深信不疑. 自序 ​ 很久以前，我曾听朋友说过，从前在某地有某些人做了一个实验，他们聚集在一起，守候着一个进入弥留状态的人，在他快要断气之前和刚刚死去之后各秤了一次体重，结果发现前后相差若干毫克，证明人的生命确实有灵魂存在。那若干毫克便是灵魂的体重。 这样的实验和结论未免有些草率，我当时心想，人的身体随时都在散发汗气，那位被实验者死前可能因为紧张或者痛苦而忙得满头大汗也说不定，损失掉的若干毫克并不能全记在灵魂的账上。但是朋友来自一个热衷精神生活的家庭，若不能证明“人类确有灵魂”一事，也许会带给他心理上极大的恐慌，因此我便对他表达了我的坚信不疑。如果我的演技还可以的话，相信当时在我闪烁的眼神中，大概也曾经短暂地发散出一丝信仰的光辉吧！ 另外，我还有一位热衷锻炼身体的朋友，他是镇上有名的田径选手，专攻百米短跑。那时，我们同在一所国中念书，每到朝会集合或是放学打扫的时间，都可以在操场的一隅，看见朋友不分冷热晴雨，总是身着一件雪白的紧身背心，和一条短到不能再短的运动裤，脚上是一双跑起来刷刷响的钉鞋。他在体育老师的细心呵护，和全校女生的注目之下，一遍又一遍反复地练习起跑、抬腿、冲刺等动作。在那样理想的状况之下，有史以来，我首次诚心地联想到，人类有可能是地球上最美丽的生物之一。 有一天，朋友请我在学校旁的冰果室吃冰，他看起来很兴奋，因为那天他的速度进步了零点零几秒（正确的数字我忘记了）；我也颇为得意，因为角落里有一群女生对我投来一种既羡慕又嫉妒的眼光。这种感受很奇怪，好像那些女生的眼神都有重量似的，每一双眼睛各放射出若干毫克，再乘上某种凌厉的速度向我横扫而来，一碗冰吃得我满头大汗。 就这样，我的早期生活便慢慢地陷入这种对“若干毫克”或是“零点零几秒”的轻微迷惑之中。当周遭的朋友以愈来愈频繁的次数询问我有关“生命的意义”，或是“人为什么而活”的问题时，我便一步一步地踏入了那古老而坚固的迷宫之中了。久了之后，这样伤感情的问题便很少听人提起了，除了用所谓“习惯成自然”的适应能力来解释之外——或者还有另外一个很重要的原因，那便是朋友愈来愈少了。 令人难忘的是，当年我的朋友们在肯定了人的灵魂确实重量若干，或是奔跑的速度竟然可以如何的时候，脸上所洋溢出的神圣光彩。这么些年来，这两个谜题我始终还想不清楚，也不知该走向哪一边。我不知该如何计算自己的正确体重，也没有努力地锻炼过双腿。幸好，朋友是愈来愈少了。 或者说，年岁渐长之后，交朋友的方式就慢慢变得不一样了。 前一阵子，途经一处风景地区，在一个不太起眼的民宅神坛前，看到一群人围在一个乩童模样的人身旁，他们在一种诡异而敏感的气氛中期待着。那个人盘腿端坐在一张矮桌上，上身赤裸发红，一手持羽扇，一手执米酒，身体微微晃动着；他偶尔会睁开迷蒙的双眼，灌一口酒，然后又迅速合上眼，嘴角不时地抽动着。那些围在他身旁的男男女女似乎很渴望他开口说话，因此，一旦见他嘴上稍有异状，便探头探脑地向前推挤起来，待乩童闭口不语之后，接着又是一大段沉默。 我已经很多年不曾看到有人这样认真地去聆听别人说话了。当时，若不是因为室内已经太过拥挤的关系，我也很希望能置身其间。我期盼可以意外地，透过乩童的口，听到某个老朋友的声音；那时候，或许那位乩童的体重会莫名其妙地增加了若干毫克也说不定。 那次经历，让我对乩童这个行业产生了一种很亲切的感受。那是一种很古老而充满失望的能量，它让人们维系了一份非常间接的友谊关系。我始终忘不了那个满身酒气，表情扭曲，端坐在矮桌上左摇右晃的身影。在众目睽睽之下，他就像一台破旧的老收音机，不断地发出滋滋响的杂讯，只偶然地，在最理想的状况下，勉强接收到几句话，或是写下一句费人猜疑的诗行…… 这本《寂寞的游戏》让我又回到了老路上，当然，也遇到了一些“老问题”和“老朋友”；我很高兴自己能有机会多走几步路，如果人真的还有来生，希望下辈子我可以不费吹灰之力地再次想起“他们”的点点滴滴。","categories":[],"tags":[{"name":"Reading","slug":"Reading","permalink":"https://casuor.top/tags/Reading/"}]},{"title":"Windows的奇技淫巧","slug":"res-windows","date":"2019-10-27T16:00:00.000Z","updated":"2020-10-28T09:58:54.891Z","comments":true,"path":"2019/10/28/res-windows/","link":"","permalink":"https://casuor.top/2019/10/28/res-windows/","excerpt":"","text":"[TOC] 浏览器Chrome EDGE Firefxo 通信telegram TG群reference1reference2 截图Snipaste 视频播放器Potplayer爱奇艺万能联播MPC-HC 网络电视ZY Player柠檬影视 在线视频(大都是个人维护,易失效,这类网站巨多)919yy影视在线影视 音频播放器GrooveMusicPlayer 音乐播放器网易云音乐&amp;解锁灰色歌曲QQ音乐 系统工具Dism++ Windows10Manager Geek Uninstaller 360驱动大师 图像处理泼辣修图||PhotoShop 图床工具PicGo 配合Github搭建自己的CDN 录屏&amp;Gif班迪录屏&amp;screentogif OfficeOfficeTool 系统下载激活工具microsoft-iso-downloader 建议配合IDM使用 下载工具IDM 搜索工具Everything UTools 输入法手心输入法 Rime 办公同步协作石墨文档 seafile PDF阅读器&amp;编辑器sumatrapdf MovaviPDF Editor 思维导图Xmind Mindmaster 护眼软件护眼宝 手机控制电脑Hipc OCR识别工具天若OCR文字识别 远程控制TeamViewer 电子书转换Calibre cloudconvert PS:电子书下载 文档下载 Markdown 编辑器Typora Sublime Text 3 图表工具Draw.io PS:有UWP版的 Microsoft Whiteboard https://tableconvert.com/ 文件云同步onedrive(教育版5T) PS:配合RaiDrive使用 坚果云 磁力工具FDM WebTorrent Desktop 基于 node.js、WebRTC 的开源技术，任何人都可以通过 Github 获取源码并搭建一个视频网站 😂 然而这个太折腾了。https://webtorrent.io/desktop/ 如果碰到无法播放的情况 https://instant.io/ 批处理工具去除快捷方式角标 reg add &quot;HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Icons&quot; /v 29 /d &quot;%systemroot%\\system32\\imageres.dll,197¡å /t reg_sz /f taskkill /f /im explorer.exe attrib -s -r -h &quot;%userprofile%\\AppData\\Local\\iconcache.db&quot; del &quot;%userprofile%\\AppData\\Local\\iconcache.db&quot; /f /q start explorer pause去除小盾牌 reg add &quot;HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Icons&quot; /v 29 /d &quot;%systemroot%\\system32\\imageres.dll,197&quot; /t reg_sz /f reg add &quot;HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Icons&quot; /v 77 /d &quot;%systemroot%\\system32\\imageres.dll,197&quot; /t reg_sz /f taskkill /f /im explorer.exe attrib -s -r -h &quot;%userprofile%\\AppData\\Local\\iconcache.db&quot; del &quot;%userprofile%\\AppData\\Local\\iconcache.db&quot; /f /q start explorer +美化工具致美化 PS:先看教程再使用 Wallhaven Wallpaper PS:如何爬取wallhaven图片 TODOMicrosoft TODO","categories":[{"name":"Resource","slug":"Resource","permalink":"https://casuor.top/categories/Resource/"}],"tags":[]},{"title":"社区资源(一)","slug":"live_socialotes1","date":"2019-10-15T16:00:00.000Z","updated":"2020-10-28T09:58:54.887Z","comments":true,"path":"2019/10/16/live_socialotes1/","link":"","permalink":"https://casuor.top/2019/10/16/live_socialotes1/","excerpt":"","text":"Never go out there to see what happens,go out there to make things happen. 天气晴🌞,微风 🍓杂记 图床 https://imgchr.com/ Blog plugins https://aplayer.js.org/#/ highlight.js https://highlightjs.org/ Table Convert https://tableconvert.com/ 就业情况爬虫 http://yehe.37he.cn/job/#/education 妹子图爬虫 https://github.com/chenjiandongx/mzitu 百度网盘提取码 https://github.com/wu-dada/baidupankey https://pnote.net/pan/ 树洞ocr https://github.com/AnyListen/tools-ocr Markdown语法 https://spec.commonmark.org/0.29/ scrcpy gui https://github.com/Tomotoes/scrcpy-gui/blob/master/README.zh_CN.md 电子书下载 http://ireadweek.com/ 电子书转换 https://cloudconvert.com/ Auto.js https://hyb1996.github.io/AutoJs-Docs/#/ github DNS https://www.ipaddress.com/","categories":[{"name":"Live","slug":"Live","permalink":"https://casuor.top/categories/Live/"}],"tags":[]},{"title":"网易云音乐去灰色","slug":"res-cloudmusic","date":"2019-10-13T16:00:00.000Z","updated":"2020-10-28T09:58:54.890Z","comments":true,"path":"2019/10/14/res-cloudmusic/","link":"","permalink":"https://casuor.top/2019/10/14/res-cloudmusic/","excerpt":"","text":"reference必应搜索unblockmusic即可,项目已开源,去fuck吧 come here网易云音乐去灰色原理: 屏蔽网易DNS解析+换源 工具: 太极https://www.coolapk.com/apk/me.weishu.expunblock music pro 2.7https://github.com/nining377/UnblockMusicPro_Xposed/releases 网易云音乐6.1(其他没修改的版本也可以)链接:https://pan.baidu.com/s/1USpV_WsPG10YXFZXHuGZxw 提取码:9123 操作: 文字教程☞ 1.三个都安装好 2.打开太极，将网易云音乐安装到太极中 3.在模块页面勾选ump2.7(简写) 4.重启网易云音乐(后台终止)，即ok了 视频教程☞链接:https://pan.baidu.com/s/1h5mwNGeaP9yEvLFSysAqgQ 提取码:7508PS:视频教程由网友提供。 新增云村清洁工:使用同ump2.7,打开显示未激活，忽略. 链接:https://pan.baidu.com/s/1zM3mu0pMU7l-CGgxk1BLSw 提取码:0ct3效果图","categories":[{"name":"Resource","slug":"Resource","permalink":"https://casuor.top/categories/Resource/"}],"tags":[]},{"title":"Electron Notes","slug":"geek_Electron入门","date":"2019-09-27T16:00:00.000Z","updated":"2020-10-28T09:58:54.877Z","comments":true,"path":"2019/09/28/geek_Electron入门/","link":"","permalink":"https://casuor.top/2019/09/28/geek_Electron%E5%85%A5%E9%97%A8/","excerpt":"","text":"Electorn技术栈环境搭建1.Node.js 2.GitNVM常用命令： 123456789101112nvm arch #版本64or32nvm install [version] [arch] #安装nvm list [available] #显示安装版本或已经安装的版本nvm on nvm offnvm proxy [url]nvm node_mirror [url]nvm npm_mirror[url]nvm uninstall &lt;version&gt;nvm use [version] [arch]nvm root [path]nvm version npm初始化 12345678910#查看部分配置信息npm config ls#修改全局Node moudle位置初始位置：prefix = \"C:\\\\Users\\\\16877\\\\AppData\\\\Roaming\\\\npm\"cache = \"C:\\\\Users\\\\16877\\\\AppData\\\\Roaming\\\\npm-cache\"修改：npm config set prefix \"F:\\Develop_Node.js\\Gobal_Npm_Module\"npm config set cache \"F:\\Develop_Node.js\\Gobal_Npm_Cache\"#修改Npm cache位置 PS:其他也可以设置 安装cnpm 123npm install -g cnpm --registry=https://registry.npm.taobao.org#此外需添加环境变量cnpm -v PS :problem: 1The process cannot access the file because it is being used by another process. 方案1：淘宝镜像 12nvm node_mirror https://npm.taobao.org/mirrors/node/nvm npm_mirror https://npm.taobao.org/mirrors/npm/ 方案2：直接下载个exe安装到nvm所指定的路径名称改为(LTS版本：’v12.13.1’) 3.Electorn (1)克隆示例项目的仓库 1git clone https://github.com/electron/electron-quick-start (2)进入仓库 1cd electron-quick-start (3)安装依赖并启动 123456cnpm install or npm installnpm start#使用npm卡住需在.npmrc文件添加registry=https://registry.npm.taobao.orgelectron_mirror=\"https://npm.taobao.org/mirrors/electron/\"PS:install.js文件中有electron_mirror这一项，使用cnpm没问题 npm地址 进程和线程什么是进程什么是线程进程与线程的区别1.内存使用方面的区别2.通信机制方面的区别3.量级方面的区别 Electorn 主进程和渲染进程chrom 多进程管理{主进程+渲染进程}main process使用和系统对接的Electorn API-创建菜单,创建菜单,上传文件等创建渲染进程-Render Process全面支持Node.js有且只有一个程序入口点Render Process可以有多个,每个对应一个窗口每个都是一个单独的进程全面支持Node.js和Dom API可使用部分Electron 进程Multi-process Architecture 创建Browser Windowcnpm install –save-dev nodemonEdit package.json 1234567891011121314151617181920212223&#123; \"name\": \"electron-quick-start\", \"version\": \"1.0.0\", \"description\": \"A minimal Electron application\", \"main\": \"main.js\", \"scripts\": &#123; \"start\": \"nodemon --watch main.js --exec electron .\" &#125;, \"repository\": \"https://github.com/electron/electron-quick-start\", \"keywords\": [ \"Electron\", \"quick\", \"start\", \"tutorial\", \"demo\" ], \"author\": \"GitHub\", \"license\": \"CC0-1.0\", \"devDependencies\": &#123; \"electron\": \"^7.1.2\", \"nodemon\": \"^2.0.1\" &#125;&#125; Main.js 123456789101112131415// Modules to control application life and create native browser window//common.jsconst &#123;app, BrowserWindow&#125; = require('electron')app.on('ready', () =&gt; &#123; let mainWindow = new BrowserWindow( &#123; width: 800, height: 500, webPreferences: &#123; nodeIntegration:true &#125; &#125; ) mainWindow.loadFile('index.html')&#125;) 进程间的通信Electron使用IPC(interprocess communication)进行通信 开发者工具: DevtronAn Electron DevTools Extension 123456# Install Devtron$ npm install --save-dev devtron# Run the following from the Console tab of your app's DevToolsrequire('devtron').install()# You should now see a Devtron tab added to the DevTools 使用IPC进行通信ipcMainipcRenderer 使用remote实现跨进程访问react特性声明式写法组件化一次学习,随处编写 react install 1234npx create-react-app my-app#为何不使用npm install -g create-react-appcd my-appnpm start npx的用法 npx说明 12#node_moudles/.bin/nodemon --versionnpx nodemon --version","categories":[{"name":"Geek","slug":"Geek","permalink":"https://casuor.top/categories/Geek/"}],"tags":[]},{"title":"GNU Wget for Windows","slug":"geek_gnuweget","date":"2019-09-25T16:00:00.000Z","updated":"2020-10-28T09:58:54.883Z","comments":true,"path":"2019/09/26/geek_gnuweget/","link":"","permalink":"https://casuor.top/2019/09/26/geek_gnuweget/","excerpt":"","text":"GNU WegetIntroductionGNU Wget是一个免费软件包，可使用HITP，HTTPS，FTP和FTPS等最广泛使用的Internet协议来检索文件。 它是一种非交互式的命令行工具，因此可以很容易地从脚本，cron jobs,不支持X-Windows的终端等中调用它。GNU Wget具有许多使检索大型文件或镜像整个Web或FTP站点变得容易的功能，包括： 可以使用REST和RANGE恢复中止的下载 可以使用文件名通配符并递归镜像目录 基于NLS的消息文件，适用于多种语言 (可选)将已加载文档中的绝对链接转换为相对链接，以便已卸载文档可以在本地彼此链接 在大多数类似UNIX的操作系统以及Microsoft Windows上运行 支持HTTP代理·支持HTTP cookie 支持持久的HTTP连接 无人值守/后台操作 使用本地文件时间戳确定镜像时是否需要重新下载文档GNU Wget是根据GNU通用公共许可证发行的。 Install镜像 UsereferenceFSF社区手册 https://builtvisible.com/download-your-website-with-wget/ https://www.cnblogs.com/Randy0528/archive/2011/10/21/2219831.html otherGUN项目 推荐书籍unix编程艺术 名人了解: 理查德·马修·斯托曼 Ken Thompson 时间:1969 最初的unix是一个第三系统,由兼容分时系统(ctss,compatible time-sharing system)系统演变而成,Unix的父辈是颇具开拓性的Multics项目,该项目视图建立一个具备众多功能的信息功用体/应用工具(information utility),能够很漂亮地支持大群用户对大型计算机的交互式分时使用.Multics最后因不堪自身重负崩溃但Unix诞生了.","categories":[{"name":"Geek","slug":"Geek","permalink":"https://casuor.top/categories/Geek/"}],"tags":[]},{"title":"电子书聚合","slug":"res-books","date":"2019-09-25T16:00:00.000Z","updated":"2020-10-28T09:58:54.890Z","comments":true,"path":"2019/09/26/res-books/","link":"","permalink":"https://casuor.top/2019/09/26/res-books/","excerpt":"","text":"电子书分类及阅读工具科普常见的电子书格式主要有：pdf、epub、mobi、azw3、caj、pdg、pdz、djvu、uvz、umd、keb、chm、ceb、txt、ps等 手机上epub格式推荐用掌阅iReader、fbreader等来阅读，mobi格式推荐用Kindle App阅读。 iOS上(iPhone、iPad)阅读azw3格式可使用MOBI Reader (https:/itunes.apple.com/us/app/mobi-reader-reader-for-mobi/id1007491919%3Fmt%3D8)，支持的电子书文件格式包括mobi, azw, azw3等… Android上，请参阅 Bravo Yeung：Android 上有什么功能比较强大的阅读器？ (https://www.zhihu.com/question/20833061/answer/44334041) 电脑上可以用Calibre、fbreader、SumatraPDF进行阅读，其中Calibre能阅读大多数格式(pdf、epub、mobi、azw3、caj、txt等)的电子书，还能进行各种格式电子书的转换。据说azw3后缀可改为Mobi格式喔，表示暂未试过~ sumatraPDF能打开epub、mobi、PDF、djvu、txt、chm、ps(单页的ps文件、多页的ps文件都支持)等格式的电子书。 epub掌阅精品需用掌阅iReader阅读，caj格式需用CAJviewer打开，pdz格式需用超星阅读器打开，解密过的pdg或uvz格式需用Unicorn viewer打开，djvu推荐用WinDjView打开。 长话短说就是：mobi或epub格式的在电脑上可以用软件Calibre或sumatraPDF打开，手机上推荐kindle App或掌阅，电子书格式转换请用Calibre… 中文电子书 ePUBee电子书库 http://cn.epubee.com/books/ 这个网站的电子书应有尽有，先免费注册个账号，还有公众号’ePUBee电子书’，在公众号中回复书名即可下载、或发送到邮箱、或发送到kindle~ 不过，本人首推在电脑浏览器中下载的方法： Step 1: 搜索到文件后，点文件下方的“保存到Cloud ID”; Step 2: 用同一个浏览器打开个人文件列表 http://cn.epubee.com/files.aspx ; Step 3: 点击Step 2的图中的文件格式(epub、mobi、azw3、PDF等，如红框所示)就可以下载了，但现在非VIP用户每天共可下载3个文件。 Readfree·me http://readfree.me/ PS:有惊喜 书舟-免费电子书分享平台 http://kindle.archiew.top Calibre-web | Recently Added Books http://book.cnxile.com/ Readfree·me http://readfree.me/ 我的小书屋-最新最全电子书免费下载 http://mebook.cc/ 云海免费电子图书馆| 免费电子图书下载 http://www.pdfbook.cn/ 苦瓜书盘 https://kgbook.com/ kindle免费电子书资源下载推送_支持mobi格式 - kindle178 http://www.kindle178.com/ 周读：提供免费电子书下载、分享。包括mobi、epud、pdf、txt格式 http://www.ireadweek.com/ 走读派 - Kindle电子书瀑布流 http://zoudupai.com/ 书语者电子图书馆 Kindle电子书 http://book.shuyuzhe.com/ 早安社区 - 简单阅读自由分享雅俗共赏_全国十大原创精校电子书网站 http://www.zasq.net/forum.php 网上读书园地 - 论坛 http://readfree.net/bbs/forum.php 缤闹kindle论坛 http://www.binnao.com/forum.php 国学数典 http://bbs.gxsd.com.cn/forum.php 益书网：优质电子书资源分享、下载与推送 https://kindbook.cn/ 图书资源 – 书伴（原名“Kindle伴侣”） https://bookfere.com/ebook 许多书(建设中) https://xuduoshu.com/about/ 书多多 - 好用的电子书搜索引擎 - 搜书就用书多多 http://www.shuduoduo.me/ 奇异书屋 http://www.talebook.org/ Kindle资源库SoKindle一起分享阅读的乐趣 https://www.so-kindle.com/ SoKindle - 免费电子书分享交流下载 https://sokindle.com/ iPad 电子书资源分享区 - 威锋论坛 - 威锋网 http://url.cn/5vNxgkF 爱问共享资料_在线资料分享平台 http://ishare.iask.sina.com.cn/ Android 漫畫小說-Android 資源分享-Android 台灣中文網 - APK.TW https://apk.tw/forum-368-1.html 英文电子书 Libgen Online Library:https://libgen.pw/ Electronic library http://booksc.org/ http://bookzz.org/ http://en.booksee.org/ Books-share.com - Free ebooks http://www.books-share.com/ ITeBookShare http://www.itebookshare.com/ Sci-Hub: removing barriers in the way of science http://www.sci-hub.cc/ 七彩英语 - 英文电子书下载站 PDF|TXT格式英文原版原著下载http://www.qcenglish.com/ BookDL › eBooks for PC &amp; Mobile Devices https://bookdl.com/ Free eBooks For Your Kindle or Other eReader | ManyBooks http://manybooks.net/ Welcome to Open Library | Open Libraryhttps://openlibrary.org/ Feedbooks | Free eBooks and Best Sellers http://www.feedbooks.com/ Ebook4Expert https://ebook4expert.com/ Download Amazing Free Ebooks in pdf, epub &amp; kindlehttp://www.obooko.com/ Scribd - Read books, audiobooks, and more https://zh.scribd.com/ E-Books Directory - Categorized Books, Short Reviews, Free Downloads http://www.e-booksdirectory.com/ 其他 亿年书海 - 电子书 wiki 网 http://www.inien.com/w/#/Index 直达号 http://zhidahao.com/?from=ppurl.com 掌上书苑-主页https://www.cnepub.com/ 古登堡计划（中文书籍） Gutenberg http://www.gutenberg.org/ 完美文库 http://www.wmwk.org/Search.aspx 好讀 http://haodoo.net/ 学习资料库，免费共享各类学习资料，学习资料免费下载 http://www.xuexi111.com/ E书吧-免费电子书下载 http://www.eshuba.com/ 漫画书电子版 日漫小站 - 电子书专用漫画下载 http://www.jp-comic.com/ Vol.moe = Kindle漫畫推送下載|mobi漫畫|Kobo漫畫|epub漫畫 - vol.moe http://vol.moe/ 简单易用的EPUB、MOBI电子书制作网站： 乐书-写书、写手册、团队文档管理,电子书制作 -乐书 http://www.lebook.me/ 优书 - 最简单易用的EPUB、MOBI电子书制作软件http://www.youshu.net/ 读远 - 干货集合地(用微博登录) 建设中 (http://readfar.com/) 相关参考： 免费电子书网站汇总http://shedingkong.lofter.com/post/302b9d_d324ec 原文地址： https://zhuanlan.zhihu.com/p/28472412 推荐本人常用微信公众号:幸福的味道&amp;网站:www.ireadweek.com","categories":[{"name":"Resource","slug":"Resource","permalink":"https://casuor.top/categories/Resource/"}],"tags":[]},{"title":"Electron Notes","slug":"geek_electron","date":"2019-09-24T16:00:00.000Z","updated":"2020-10-28T09:58:54.882Z","comments":true,"path":"2019/09/25/geek_electron/","link":"","permalink":"https://casuor.top/2019/09/25/geek_electron/","excerpt":"","text":"Electorn技术栈环境搭建1.Node.js 2.GitNVM常用命令： 123456789101112nvm arch #版本64or32nvm install [version] [arch] #安装nvm list [available] #显示安装版本或已经安装的版本nvm on nvm offnvm proxy [url]nvm node_mirror [url]nvm npm_mirror[url]nvm uninstall &lt;version&gt;nvm use [version] [arch]nvm root [path]nvm version npm初始化 12345678910#查看部分配置信息npm config ls#修改全局Node moudle位置初始位置：prefix = \"C:\\\\Users\\\\16877\\\\AppData\\\\Roaming\\\\npm\"cache = \"C:\\\\Users\\\\16877\\\\AppData\\\\Roaming\\\\npm-cache\"修改：npm config set prefix \"F:\\Develop_Node.js\\Gobal_Npm_Module\"npm config set cache \"F:\\Develop_Node.js\\Gobal_Npm_Cache\"#修改Npm cache位置 PS:其他也可以设置 安装cnpm 123npm install -g cnpm --registry=https://registry.npm.taobao.org#此外需添加环境变量cnpm -v PS :problem: 1The process cannot access the file because it is being used by another process. 方案1：淘宝镜像 12nvm node_mirror https://npm.taobao.org/mirrors/node/nvm npm_mirror https://npm.taobao.org/mirrors/npm/ 方案2：直接下载个exe安装到nvm所指定的路径名称改为(LTS版本：’v12.13.1’) 3.Electorn (1)克隆示例项目的仓库 1git clone https://github.com/electron/electron-quick-start (2)进入仓库 1cd electron-quick-start (3)安装依赖并启动 123456cnpm install or npm installnpm start#使用npm卡住需在.npmrc文件添加registry=https://registry.npm.taobao.orgelectron_mirror=\"https://npm.taobao.org/mirrors/electron/\"PS:install.js文件中有electron_mirror这一项，使用cnpm没问题 npm地址 进程和线程什么是进程什么是线程进程与线程的区别1.内存使用方面的区别2.通信机制方面的区别3.量级方面的区别 Electorn 主进程和渲染进程chrom 多进程管理{主进程+渲染进程}main process使用和系统对接的Electorn API-创建菜单,创建菜单,上传文件等创建渲染进程-Render Process全面支持Node.js有且只有一个程序入口点Render Process可以有多个,每个对应一个窗口每个都是一个单独的进程全面支持Node.js和Dom API可使用部分Electron 进程Multi-process Architecture 创建Browser Windowcnpm install –save-dev nodemonEdit package.json 1234567891011121314151617181920212223&#123; \"name\": \"electron-quick-start\", \"version\": \"1.0.0\", \"description\": \"A minimal Electron application\", \"main\": \"main.js\", \"scripts\": &#123; \"start\": \"nodemon --watch main.js --exec electron .\" &#125;, \"repository\": \"https://github.com/electron/electron-quick-start\", \"keywords\": [ \"Electron\", \"quick\", \"start\", \"tutorial\", \"demo\" ], \"author\": \"GitHub\", \"license\": \"CC0-1.0\", \"devDependencies\": &#123; \"electron\": \"^7.1.2\", \"nodemon\": \"^2.0.1\" &#125;&#125; Main.js 123456789101112131415// Modules to control application life and create native browser window//common.jsconst &#123;app, BrowserWindow&#125; = require('electron')app.on('ready', () =&gt; &#123; let mainWindow = new BrowserWindow( &#123; width: 800, height: 500, webPreferences: &#123; nodeIntegration:true &#125; &#125; ) mainWindow.loadFile('index.html')&#125;)","categories":[{"name":"Geek","slug":"Geek","permalink":"https://casuor.top/categories/Geek/"}],"tags":[]},{"title":"Electron Fiddle","slug":"geek_electronFiddle","date":"2019-09-24T16:00:00.000Z","updated":"2020-10-28T09:58:54.882Z","comments":true,"path":"2019/09/25/geek_electronFiddle/","link":"","permalink":"https://casuor.top/2019/09/25/geek_electronFiddle/","excerpt":"","text":"Electron Fiddle介绍create and play with small Electron experiments. It greets you with a quick-start template after opening – change a few things, choose the version of Electron you want to run it with, and play around. Then, save your Fiddle either as a GitHub Gist or to a local folder. Once published on GitHub, anyone can quickly try your Fiddle out by just entering it in the address bar. 功能探索Electron Fiddle包含了探索平台所需的一切。它还包括Electron中可用的每个API的示例. 代码风格 Fiddle包括Microsoft出色的Monaco编辑器，该编辑器支持Visual Studio Code。它还会自动为当前所选版本的Electron安装类型定义，以确保您始终只需单击几次即可获得所有Electron API。 编译打包 Complete Tool Start with Fiddle, Continue Wherever Fiddle 不是一个IDE,但是是一个不错的开始","categories":[{"name":"Geek","slug":"Geek","permalink":"https://casuor.top/categories/Geek/"}],"tags":[]},{"title":"哔哩哔哩-汪峰-空空如也","slug":"trans-B站-空空如也","date":"2019-08-27T16:00:00.000Z","updated":"2020-10-28T09:58:54.892Z","comments":true,"path":"2019/08/28/trans-B站-空空如也/","link":"","permalink":"https://casuor.top/2019/08/28/trans-B%E7%AB%99-%E7%A9%BA%E7%A9%BA%E5%A6%82%E4%B9%9F/","excerpt":"","text":"B站呵呵系列多上B站,快乐多多转载自:AV25757959,侵删,联系方式 岁月不饶人,能救赎自己的只有自己","categories":[{"name":"Transfer","slug":"Transfer","permalink":"https://casuor.top/categories/Transfer/"}],"tags":[]},{"title":"Flutter Notes","slug":"geek_Flutter","date":"2019-08-24T16:00:00.000Z","updated":"2020-10-28T09:58:54.879Z","comments":true,"path":"2019/08/25/geek_Flutter/","link":"","permalink":"https://casuor.top/2019/08/25/geek_Flutter/","excerpt":"","text":"起步移动开发技术简介跨平台技术简介H5+原生（Cordova、Ionic、微信小程序）​ 动态内容通过H5实现(原生的网页加载控件webview,不难理解),APP相当于浏览器.这种模式称为混合应用,或Hybrid APP.​ 代表:微信小程序​ 混合开发技术:​ webview实质上是一个浏览器内核,实现交互需要js,而对于js直接操纵系统(原生API)能力有限,即需要使用原生与H5混合的开发模式.​ js与原生API之间通信遵守一个标准协议,协议实现的工具:webview javascipt bridge.​ JavaScript开发+原生渲染的方式主要优点如下： 采用Web开发技术栈，社区庞大、上手快、开发成本相对较低。原生渲染，性能相比H5提高很多。动态化较好，支持热更新。 ​ 不足： 渲染时需要JavaScript和原生之间通信，在有些场景如拖动可能会因为通信频繁导致卡顿。JavaScript为脚本语言，执行时需要JIT(Just In Time)，执行效率和AOT(Ahead Of Time)代码仍有差距。由于渲染依赖原生控件，不同平台的控件需要单独维护，并且当系统更新时，社区控件可能会滞后；除此之外，其控件系统也会受到原生UI系统限制，例如，在Android中，手势冲突消歧规则是固定的，这在使用不同人写的控件嵌套时，手势冲突问题将会变得非常棘手。:Hybrid(杂种;混合物) JavaScript开发+原生渲染 （React Native、Weex、快应用）​ React Native简介​ React Native (简称RN)是Facebook于2015年4月开源的跨平台移动应用开发框架，是Facebook早先开源的JS框架 React 在原生移动应用平台的衍生产物，目前支持iOS和Android两个平台。RN使用Javascript语言，类似于HTML的JSX，以及CSS来开发移动应用，因此熟悉Web前端开发的技术人员只需很少的学习就可以进入移动应用开发领域。​ 由于RN和React原理相通，并且Flutter也是受React启发，很多思想也都是相通的，万丈高楼平地起，我们有必要深入了解一下React原理。React是一个响应式的Web框架，我们先了解一下两个重要的概念：DOM树与响应式编程。​ &gt;DOM树:​ &gt;响应式编程:​ PS:​ &gt;react?​ -Weex简介​ Weex是阿里巴巴于2016年发布的跨平台移动端开发框架，思想及原理和React Native类似，最大的不同是语法层面，Weex支持Vue语法和Rax语法，Rax 的 DSL(Domain Specific Language) 语法是基于 React JSX 语法而创造。与 React 不同，在 Rax 中 JSX 是必选的，它不支持通过其它方式创建组件，所以学习 JSX 是使用 Rax 的必要基础。而React Native只支持JSX语法。​ -快应用简介​ 采用JavaScript语言开发，原生控件渲染，与React Native和Weex相比主要有两点不同：​ 快应用自身不支持Vue或React语法，其采用原生JavaScript开发，其开发框架和微信小程序很像，值得一提的是小程序目前已经可以使用Vue语法开发（mpvue），从原理上来讲，Vue的语法也可以移植到快应用上。​ React Native和Weex的渲染/排版引擎是集成到框架中的，每一个APP都需要打包一份，安装包体积较大；而快应用渲染/排版引擎是集成到ROM中的，应用中无需打包，安装包体积小，正因如此，快应用才能在保证性能的同时做到快速分发。 自绘UI+原生(QT for mobile、Flutter)​ QT :​ 初识FlutterFlutter简介 Flutter 是 Google推出并开源的移动应用开发框架，主打跨平台、高保真、高性能。开发者可以通过 Dart语言开发 App，一套代码同时运行在 iOS 和 Android平台。 Flutter提供了丰富的组件、接口，开发者可以很快地为 Flutter添加 native扩展。同时 Flutter还使用 Native引擎渲染视图，这无疑能为用户提供良好的体验。 跨平台自绘引擎Flutter与用于构建移动应用程序的其它大多数框架不同，因为Flutter既不使用WebView，也不使用操作系统的原生控件。 相反，Flutter使用自己的高性能渲染引擎来绘制widget。这样不仅可以保证在Android和iOS上UI的一致性，而且也可以避免对原生控件依赖而带来的限制及高昂的维护成本。 Flutter使用Skia作为其2D渲染引擎，Skia是Google的一个2D图形处理函数库，包含字型、坐标转换，以及点阵图都有高效能且简洁的表现，Skia是跨平台的，并提供了非常友好的API，目前Google Chrome浏览器和Android均采用Skia作为其绘图引擎。 目前Flutter目前默认支持iOS、Android、Fuchsia（Google新的自研操作系统）三个移动平台。但Flutter亦可支持Web开发（Flutter for web）和PC开发，本书的示例和介绍主要是基于iOS和Android平台的，其它平台读者可以自行了解。 高性能 Flutter高性能主要靠两点来保证，首先，Flutter APP采用Dart语言开发。Dart在 JIT（即时编译）模式下，速度与 JavaScript基本持平。但是 Dart支持 AOT，当以 AOT模式运行时，JavaScript便远远追不上了。速度的提升对高帧率下的视图数据计算很有帮助。其次，Flutter使用自己的渲染引擎来绘制UI，布局数据等由Dart语言直接控制，所以在布局过程中不需要像RN那样要在JavaScript和Native之间通信，这在一些滑动和拖动的场景下具有明显优势，因为在滑动和拖动过程往往都会引起布局发生变化，所以JavaScript需要和Native之间不停的同步布局信息，这和在浏览器中要JavaScript频繁操作DOM所带来的问题是相同的，都会带来比较可观的性能开销。 采用Dart语言开发这是一个很有意思，但也很有争议的问题，在了解Flutter为什么选择了 Dart而不是 JavaScript之前我们先来介绍两个概念：JIT和AOT。 目前，程序主要有两种运行方式：静态编译与动态解释。 静态编译的程序在执行前全部被翻译为机器码，通常将这种类型称为AOT （Ahead of time）即 “提前编译”； 动态解释执行的则是一句一句边翻译边运行，通常将这种类型称为JIT（Just-in-time）即“即时编译”。 AOT程序的典型代表是用C/C++开发的应用，它们必须在执行前编译成机器码，而JIT的代表则非常多，如JavaScript、python等，事实上，所有脚本语言都支持JIT模式。但需要注意的是JIT和AOT指的是程序运行方式，和编程语言并非强关联的，有些语言既可以以JIT方式运行也可以以AOT方式运行，如Java、Python，它们可以在第一次执行时编译成中间字节码、然后在之后执行时可以直接执行字节码，也许有人会说，中间字节码并非机器码，在程序执行时仍然需要动态将字节码转为机器码，是的，这没有错，不过通常我们区分是否为AOT的标准就是看代码在执行之前是否需要编译，只要需要编译，无论其编译产物是字节码还是机器码，都属于AOT。 现在我们看看Flutter为什么选择Dart语言？笔者根据官方解释以及自己对Flutter的理解总结了以下几条（由于其它跨平台框架都将JavaScript作为其开发语言，所以主要将Dart和JavaScript做一个对比）： 开发效率高 Dart运行时和编译器支持Flutter的两个关键特性的组合： 基于JIT的快速开发周期：Flutter在开发阶段采用，采用JIT模式，这样就避免了每次改动都要进行编译，极大的节省了开发时间； 基于AOT的发布包: Flutter在发布时可以通过AOT生成高效的ARM代码以保证应用性能。而JavaScript则不具有这个能力。 高性能 Flutter旨在提供流畅、高保真的的UI体验。为了实现这一点，Flutter中需要能够在每个动画帧中运行大量的代码。这意味着需要一种既能提供高性能的语言，而不会出现会丢帧的周期性暂停，而Dart支持AOT，在这一点上可以做的比JavaScript更好。 3.快速内存分配 Flutter框架使用函数式流，这使得它在很大程度上依赖于底层的内存分配器。因此，拥有一个能够有效地处理琐碎任务的内存分配器将显得十分重要，在缺乏此功能的语言中，Flutter将无法有效地工作。当然Chrome V8的JavaScript引擎在内存分配上也已经做的很好，事实上Dart开发团队的很多成员都是来自Chrome团队的，所以在内存分配上Dart并不能作为超越JavaScript的优势，而对于Flutter来说，它需要这样的特性，而Dart也正好满足而已。 4.类型安全 由于Dart是类型安全的语言，支持静态类型检测，所以可以在编译前发现一些类型的错误，并排除潜在问题，这一点对于前端开发者来说可能会更具有吸引力。与之不同的，JavaScript是一个弱类型语言，也因此前端社区出现了很多给JavaScript代码添加静态类型检测的扩展语言和工具，如：微软的TypeScript以及Facebook的Flow。相比之下，Dart本身就支持静态类型，这是它的一个重要优势。 5.Dart团队就在你身边 看似不起眼，实则举足轻重。由于有Dart团队的积极投入，Flutter团队可以获得更多、更方便的支持，正如Flutter官网所述“我们正与Dart社区进行密切合作，以改进Dart在Flutter中的使用。例如，当我们最初采用Dart时，该语言并没有提供生成原生二进制文件的工具链（这对于实现可预测的高性能具有很大的帮助），但是现在它实现了，因为Dart团队专门为Flutter构建了它。同样，Dart VM之前已经针对吞吐量进行了优化，但团队现在正在优化VM的延迟时间，这对于Flutter的工作负载更为重要。” Flutter框架结构 Flutter Framework这是一个纯 Dart实现的 SDK，它实现了一套基础库，自底向上，我们来简单介绍一下： 底下两层（Foundation和Animation、Painting、Gestures）在Google的一些视频中被合并为一个dart UI层，对应的是Flutter中的dart:ui包，它是Flutter引擎暴露的底层UI库，提供动画、手势及绘制能力。 Rendering层，这一层是一个抽象的布局层，它依赖于dart UI层，Rendering层会构建一个UI树，当UI树有变化时，会计算出有变化的部分，然后更新UI树，最终将UI树绘制到屏幕上，这个过程类似于React中的虚拟DOM。Rendering层可以说是Flutter UI框架最核心的部分，它除了确定每个UI元素的位置、大小之外还要进行坐标变换、绘制(调用底层dart:ui)。 Widgets层是Flutter提供的的一套基础组件库，在基础组件库之上，Flutter还提供了 Material 和Cupertino两种视觉风格的组件库。而我们Flutter开发的大多数场景，只是和这两层打交道。 Flutter Engine这是一个纯 C++实现的 SDK，其中包括了 Skia引擎、Dart运行时、文字排版引擎等。在代码调用 dart:ui库时，调用最终会走到Engine层，然后实现真正的绘制逻辑。 学习Flutter资源 官网：阅读Flutter官网的资源是快速入门的最佳方式，同时官网也是了解最新Flutter发展动态的地方，由于目前Flutter仍然处于快速发展阶段，所以建议读者还是时不时的去官网看看有没有新的动态。 源码及注释：源码注释应作为学习Flutter的第一文档，Flutter SDK的源码是开源的，并且注释非常详细，也有很多示例，实际上，Flutter官方的SDK文档就是通过注释生成的。源码结合注释可以帮你解决大多数问题。 Github：如果遇到的问题在StackOverflow上也没有找到答案，可以去github flutter 项目下提issue。 Gallery源码：Gallery是Flutter官方示例APP，里面有丰富的示例，读者可以在网上下载安装。Gallery的源码在Flutter源码“examples”目录下。 搭建Flutter开发环境获取Flutter SDKFlutterSDK Windows下安装解压到任意盘: 用户变量: Path:追加xxx/Flutter/Bin/ 新建: 变量名=变量值 1PUB_HOSTED_URL&#x3D;https:&#x2F;&#x2F;pub.flutter-io.cn 1FLUTTER_STORAGE_BASE_URL&#x3D;https:&#x2F;&#x2F;storage.flutter-io.cn 重启电脑 运行flutter doctor -v 逐步解决 1.安装插件 Flutter&amp;Dart 2.配置环境变量 ANDROID_HOME=F:\\Develop_AndroidStudio\\AndroidSDK\\platform-tools Path下添加F:\\Develop_AndroidStudio\\AndroidSDK\\platform-tools Problem:Android license status Unknow. Solution: https://www.wandouip.com/t5i325108/ 简要记录下: F:\\Develop_AndroidStudio\\AndroidSDK\\tools\\bin目录下 执行: 1sdkmanager.bat --update 出现错误: 1234567891011Exception in thread &quot;main&quot; java.lang.NoClassDefFoundError: javax&#x2F;xml&#x2F;bind&#x2F;annotation&#x2F;XmlSchema at com.android.repository.api.SchemaModule$SchemaModuleVersion.&lt;init&gt;(SchemaModule.java:156) at com.android.repository.api.SchemaModule.&lt;init&gt;(SchemaModule.java:75) at com.android.sdklib.repository.AndroidSdkHandler.&lt;clinit&gt;(AndroidSdkHandler.java:81) at com.android.sdklib.tool.sdkmanager.SdkManagerCli.main(SdkManagerCli.java:73) at com.android.sdklib.tool.sdkmanager.SdkManagerCli.main(SdkManagerCli.java:48)Caused by: java.lang.ClassNotFoundException: javax.xml.bind.annotation.XmlSchema at java.base&#x2F;jdk.internal.loader.BuiltinClassLoader.loadClass(BuiltinClassLoader.java:583) at java.base&#x2F;jdk.internal.loader.ClassLoaders$AppClassLoader.loadClass(ClassLoaders.java:178) at java.base&#x2F;java.lang.ClassLoader.loadClass(ClassLoader.java:521) ... 5 more 根据笔者的解决方法:(原因是java版本8就可以java9之后阉割了一些库,本人12.0.2) 需要添加jaxb相关依赖： 下载: :jack_o_lantern: activation.jar:jack_o_lantern: jaxb-api.jar:jack_o_lantern: jaxb-core.jar:jack_o_lantern: jaxb-impl.jar:jack_o_lantern: jaxb-jxc.jar:jack_o_lantern: jaxb-xjc.jar jar地址: java2s jar-download mvnjar xxx/AndroidSDK/tools/jaxb PS:jaxb为新建目录,jar包放在此目录下(放在lib下也可以,配置对就行) Sublime打开Bin下 sdkmanager.bat 第66行 1set CLASSPATH&#x3D;%APP_HOME%\\jaxb\\activation.jar;%APP_HOME%\\jaxb\\jaxb-impl.jar;%APP_HOME%\\jaxb\\jaxb-xjc.jar;%APP_HOME%\\jaxb\\jaxb-core.jar;%APP_HOME%\\jaxb\\jaxb-jxc.jar;%APP_HOME%\\jaxb\\jaxb-api.jar;%APP_HOME%\\lib\\dvlib-26.0.0-dev.jar;%APP_HOME%\\lib\\jimfs-1.1.jar;%APP_HOME%\\lib\\jsr305-1.3.9.jar;%APP_HOME%\\lib\\repository-26.0.0-dev.jar;%APP_HOME%\\lib\\j2objc-annotations-1.1.jar;%APP_HOME%\\lib\\layoutlib-api-26.0.0-dev.jar;%APP_HOME%\\lib\\gson-2.3.jar;%APP_HOME%\\lib\\httpcore-4.2.5.jar;%APP_HOME%\\lib\\commons-logging-1.1.1.jar;%APP_HOME%\\lib\\commons-compress-1.12.jar;%APP_HOME%\\lib\\annotations-26.0.0-dev.jar;%APP_HOME%\\lib\\error_prone_annotations-2.0.18.jar;%APP_HOME%\\lib\\animal-sniffer-annotations-1.14.jar;%APP_HOME%\\lib\\httpclient-4.2.6.jar;%APP_HOME%\\lib\\commons-codec-1.6.jar;%APP_HOME%\\lib\\common-26.0.0-dev.jar;%APP_HOME%\\lib\\kxml2-2.3.0.jar;%APP_HOME%\\lib\\httpmime-4.1.jar;%APP_HOME%\\lib\\annotations-12.0.jar;%APP_HOME%\\lib\\sdklib-26.0.0-dev.jar;%APP_HOME%\\lib\\guava-22.0.jar PS:前6项是追加进去的,如下: 1%APP_HOME%\\jaxb\\activation.jar;%APP_HOME%\\jaxb\\jaxb-impl.jar;%APP_HOME%\\jaxb\\jaxb-xjc.jar;%APP_HOME%\\jaxb\\jaxb-core.jar;%APP_HOME%\\jaxb\\jaxb-jxc.jar;%APP_HOME%\\jaxb\\jaxb-api.jar; 保存OK,继续Bin下执行 1sdkmanager.bat --update 至此,会出现: 12Some Android licenses not accepted. To resolve this, run: flutter doctor --android-licenses 根据指示执行: 1flutter doctor --android-licenses 一路y+回车就ok了. 连接Android设备要准备在Android设备上运行并测试您的Flutter应用，您需要安装Android 4.1（API level 16）或更高版本的Android设备. 在您的设备上启用 开发人员选项 和 USB调试 。详细说明可在Android文档中找到。 使用USB将手机插入电脑。如果您的设备出现提示，请授权您的计算机访问您的设备。 在终端中，运行 flutter devices 命令以验证Flutter识别您连接的Android设备。 运行启动您的应用程序 flutter run。 默认情况下，Flutter使用的Android SDK版本是基于你的 adb 工具版本。 如果您想让Flutter使用不同版本的Android SDK，则必须将该 ANDROID_HOME 环境变量设置为SDK安装目录。 使用Android模拟器要准备在Android模拟器上运行并测试您的Flutter应用，请按照以下步骤操作： 在您的机器上启用 VM acceleration . 启动 Android Studio&gt;Tools&gt;Android&gt;AVD Manager 并选择 Create Virtual Device. 选择一个设备并选择 Next。 为要模拟的Android版本选择一个或多个系统映像，然后选择 Next. 建议使用 x86 或 x86_64 image . 在 Emulated Performance下, 选择 Hardware - GLES 2.0 以启用 硬件加速. 验证AVD配置是否正确，然后选择 Finish。 有关上述步骤的详细信息，请参阅 Managing AVDs. 在 Android Virtual Device Manager中, 点击工具栏的 Run。模拟器启动并显示所选操作系统版本或设备的启动画面. 运行 flutter run 启动您的设备. 连接的设备名是 Android SDK built for,其中 platform 是芯片系列, 如 x86. 体验第一个FlutterAPP创建 一直在creat,发现文件夹已创建了一些文件,就结束了Android Studio进程,重启.直接去文件夹打开项目,然而问题又出现了. 缺少依赖包: can not get packages from”https://pub.flutter-io.cn/%2xx&quot; 应该是镜像路径问题.复制去看了下: 目的网址应该是https://pub.flutter-io.cn/ 后面应该是配置错误. 然后在环境变量中,加入了/ 1FLUTTER_STORAGE_BASE_URL&#x3D;https:&#x2F;&#x2F;storage.flutter-io.cn&#x2F; 1UB_HOSTED_URL&#x3D;https:&#x2F;&#x2F;pub.flutter-io.cn&#x2F; 重启OK了.","categories":[{"name":"Geek","slug":"Geek","permalink":"https://casuor.top/categories/Geek/"}],"tags":[]},{"title":"Draw.io","slug":"res-draw.io","date":"2019-07-24T16:00:00.000Z","updated":"2020-10-28T09:58:54.890Z","comments":true,"path":"2019/07/25/res-draw.io/","link":"","permalink":"https://casuor.top/2019/07/25/res-draw.io/","excerpt":"","text":"Draw.io桌面Draw.io Release ONLINEhttps://draw.io 扩展GET以前知道这格式文件，没有详细了解使用。 SVG可以算是目前最最火热的图像文件格式了，它的英文全称为Scalable Vector Graphics，意思为可缩放的矢量图形。它是基于XML（Extensible Markup Language），由World Wide Web Consortium（W3C）联盟进行开发的。严格来说应该是一种开放标准的矢量图形语言，可让你设计激动人心的、高分辨率的Web图形页面。用户可以直接用代码来描绘图像，可以用任何文字处理工具打开SVG图像，通过改变部分代码来使图像具有交互功能，并可以随时插入到HTML中通过浏览器来观看。 ●SVG 指可伸缩矢量图形 (Scalable Vector Graphics) ●SVG 用来定义用于网络的基于矢量的图形 ●SVG 使用 XML 格式定义图形 ●SVG 图像在放大或改变尺寸的情况下其图形质量不会有所损失 ●SVG 是万维网联盟的标准 ●SVG 与诸如 DOM 和 XSL 之类的 W3C 标准是一个整体","categories":[{"name":"Geek","slug":"Geek","permalink":"https://casuor.top/categories/Geek/"}],"tags":[]},{"title":"转载-WallpaperAPI","slug":"trans-Blog-wallpaperAPI","date":"2019-06-27T16:00:00.000Z","updated":"2020-10-28T09:58:54.892Z","comments":true,"path":"2019/06/28/trans-Blog-wallpaperAPI/","link":"","permalink":"https://casuor.top/2019/06/28/trans-Blog-wallpaperAPI/","excerpt":"","text":"360壁纸转载自:AV25757959,侵删,联系方式接口一：获取壁纸分类 http://cdn.apc.360.cn/index.php?c=WallPaper&amp;a=getAllCategoriesV2&amp;from=360chrome 这个接口很简单，直接请求上述网址，就可以得到 json 数据。返回的数据中有个 data 数组，其中的“name”就是获取到的壁纸分类名，“id”就是这个分类对应的ID值。 接口二：根据壁纸分类ID获取分类下壁纸图片 http://wallpaper.apc.360.cn/index.php? c=WallPaper&amp;a=getAppsByCategory &amp;cid=【刚才获取到的分类ID】 &amp;start=【从第几幅图开始(用于分页)】 &amp;count=【每次加载的数量】&amp;from=360chrome 通过这个接口获取到的数据有点多，但主要要用到的只有几个。一是 data 数组中的 url 值，就是我们要获取的图片链接。它的格式类似于： http://p15.qhimg.com/bdr/__85/t0151ad4ac41239cb58.jpg 我们可以根据它来获取这张图片的指定分辨率以及指定画质的图片，以上图为例，如果我们要获取分辨率为 1024*768 ，画质为 80 (最高为100)的图片，只需将上述链接的 “bdr/__85” 替换为 “bdm/1024_768_80” 即可。替换后的图片链接如下： http://p19.qhimg.com/bdm/1024_768_80/t0151ad4ac41239cb58.jpg （注：有些图片如果原图本身就小，不会被拉伸） 除去 url 值，data 数组中的 tag 是图片对应的标签，如果需要也可以进行获取。 接口三：获取最近更新的壁纸http://wallpaper.apc.360.cn/index.php?c=WallPaper&amp;a=getAppsByOrder&amp;order=create_time&amp;start=【偏移量，从0开始】&amp;count=【加载张数】&amp;from=360chrome 这个接口的参数是固定的，并且获取到的数据格式与接口二的一样。这里就不在赘述了。 必应壁纸Bing搜索的首页每天都会推送一张很漂亮的图片，把它保存下来，当做电脑桌面或是自己的网站背景图还不是美滋滋…… 既然要抓取这张图片，首先就得弄清这张图是从何而来的。经过对必应首页的抓包，我们可以获得首页图的获取API。它的格式是这样的： http://cn.bing.com/HPImageArchive.aspx?format=js&amp;idx=0&amp;n=1 注意，这里有几个GET参数，它们的作用分别是： n，必要参数。这是输出信息的数量。比如n=1，即为1条，以此类推，至多输出8条。 format，非必要。返回结果的格式，不存在或者等于xml时，输出为xml格式，等于js时，输出json格式 idx，非必要。不存在或者等于0时，输出当天的图片，-1为已经预备用于明天显示的信息，1则为昨天的图片，以此类推，idx最多获取到前16天的图片信息 这里将n设定为1、format设定为js、idx设定为1，去发出GET请求，返回的数据是这样的： 123456789101112131415161718192021222324252627&#123; \"images\": [ &#123; \"startdate\": \"20161222\", \"fullstartdate\": \"201612221600\", \"enddate\": \"20161223\", \"url\": \"/az/hprichbg/rb/TheDomeEdinburgh_ZH-CN11993142817_1920x1080.jpg\", \"urlbase\": \"/az/hprichbg/rb/TheDomeEdinburgh_ZH-CN11993142817\", \"copyright\": \"爱丁堡一家叫做The Dome的夜店，苏格兰 (© Marty McKillop/500px)\", \"copyrightlink\": \"http://www.bing.com/search?q=The+Dome,+Edinburgh&amp;form=hpcapt&amp;mkt=zh-cn\", \"quiz\": \"/search?q=Bing+homepage+quiz&amp;filters=WQOskey:%22HPQuiz_20161222_TheDomeEdinburgh%22&amp;FORM=HPQUIZ\", \"wp\": false, \"hsh\": \"376393c9b49c6d8d1a6e7c2d38343105\", \"drk\": 1, \"top\": 1, \"bot\": 1, \"hs\": [] &#125; ], \"tooltips\": &#123; \"loading\": \"正在加载...\", \"previous\": \"上一个图像\", \"next\": \"下一个图像\", \"walle\": \"此图片不能下载用作壁纸。\", \"walls\": \"下载今日美图。仅限用作桌面壁纸。\" &#125;&#125; 其中的“images”节点下的“url”值便是我们要获取的图像地址。我们把它取出来，再加上Bing的网址前缀(http://cn.bing.com)即组合成了完整的图像地址。比如说上面返回数据的完整图像地址是这样的： http://cn.bing.com/az/hprichbg/rb/TheDomeEdinburgh_ZH-CN11993142817_1920x1080.jpg 知道了背景图的获取方式，接下来就是用PHP去动态抓取了。 如果你只是单纯的想用作网页背景的话，你只需新建一个php文件，里面贴入如下代码： 12345678&lt;?php$str = file_get_contents('http://cn.bing.com/HPImageArchive.aspx?idx=0&amp;n=1'); //从bing获取数据if(preg_match(\"/&lt;url&gt;(.+?)&lt;\\/url&gt;/ies\",$str,$matches))&#123; //正则匹配抓取图片url $imgurl='http://cn.bing.com'.$matches[1];&#125;else&#123; //如果由于某些原因，没抓取到图片地址 $imgurl='http://img.infinitynewtab.com/InfinityWallpaper/2_14.jpg'; //使用默认的图像(默认图像链接可修改为自己的)&#125;header(\"Location: $imgurl\"); //header跳转 然后把这个php文件上传到你的服务器或者是网站空间，访问这个php应该就能看到被跳转到了Bing的图片。 使用方法：直接将那个php文件的绝对地址当做图片放进网页中即可。 比如说，如果你的这个php的地址为“http://www.myweb.cn/bing.php”，那么你在你自己的网页的css中这么写就能当背景使用了： 123456789body&#123; width:100%; height:100%; background: url(http://www.myweb.cn/bing.php) no-repeat; -moz-background-size: cover; /*背景图片拉伸以铺满全屏*/ -ms-background-size: cover; -webkit-background-size: cover; background-size: cover;&#125; 以上方法只是简单地跳转，如果想要抓取这张图片并保存到服务器呢？这里直接贴代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&lt;?php/** * php抓取bing每日图片并保存到服务器 * 作者：mengkun (mkblog.cn) * 日期：2016/12/23 */$path = 'temp'; //设置图片缓存文件夹$filename = date(\"Ymd\") . '.jpg'; //用年月日来命名新的文件名if (!file_exists($path.'/'. $filename)) //如果文件不存在，则说明今天还没有进行缓存&#123; if(!file_exists($path)) //如果目录不存在 &#123; mkdir($path, 0777); //创建缓存目录 &#125; $str = file_get_contents('http://cn.bing.com/HPImageArchive.aspx?format=js&amp;idx=0&amp;n=1'); //读取必应api，获得相应数据 $str = json_decode($str,true); $imgurl = 'http://cn.bing.com'.$str['images'][0]['url']; //获取图片url $img = grabImage($imgurl, $path.'/'.$filename); //读取并保存图片 $handle = fopen(\"dat.txt\", \"a\"); //用于存放图片信息，如果不需要保存图片的相关信息，可以把下面这些去掉。 if ($handle) &#123; $copyright = $str['images'][0]['copyright']; //说明 $startdate = $str['images'][0]['startdate']; $fullstartdate = $str['images'][0]['fullstartdate']; $enddate = $str['images'][0]['enddate']; $urlbase = $str['images'][0]['urlbase']; $copyrightlink = $str['images'][0]['copyrightlink']; $quiz = $str['images'][0]['quiz']; $wp = $str['images'][0]['wp']; $hsh = $str['images'][0]['hsh']; $drk = $str['images'][0]['drk']; $top = $str['images'][0]['top']; $bot = $str['images'][0]['bot']; $tempArr = array(\"imgurl\"=&gt;$imgurl,\"copyright\"=&gt;$copyright, \"startdate\"=&gt;$startdate, \"fullstartdate\"=&gt;$fullstartdate, \"enddate\"=&gt; $enddate, \"urlbase\"=&gt;$urlbase, \"copyrightlink\"=&gt; $copyrightlink, \"quiz\"=&gt;$quiz, \"wp\"=&gt; $wp, \"hsh\"=&gt;$hsh,\"drk\"=&gt;$drk, \"top\"=&gt; $top, \"bot\"=&gt; $bot); //将相关信息放进数组中 fwrite($handle, json_encode($tempArr) .\"\\r\\n\"); //最终以json格式保存在文本文档中 fclose($handle); &#125;&#125;/** * 远程抓取图片并保存 * @param $url 图片url * @param $filename 保存名称和路径 */function grabImage($url, $filename = \"\")&#123; if($url == \"\") return false; //如果$url地址为空，直接退出 if ($filename == \"\") //如果没有指定新的文件名 &#123; $ext = strrchr($url, \".\"); //得到$url的图片格式 $filename = date(\"Ymd\") . $ext; //用天月面时分秒来命名新的文件名 &#125; ob_start(); //打开输出 readfile($url); //输出图片文件 $img = ob_get_contents(); //得到浏览器输出 ob_end_clean(); //清除输出并关闭 $size = strlen($img); //得到图片大小 $fp2 = @fopen($filename, \"a\"); fwrite($fp2, $img); //向当前目录写入图片文件，并重新命名 fclose($fp2); return $filename; //返回新的文件名&#125; 这样，如果这个php被访问，它就会自动启动抓取并保存。你可以用阿里云监控或其他类型的网站监控服务来实现每天自动运行这个php。","categories":[{"name":"Transfer","slug":"Transfer","permalink":"https://casuor.top/categories/Transfer/"}],"tags":[]},{"title":"oh-my-posh for windows terminal","slug":"geek_powershell","date":"2019-06-24T16:00:00.000Z","updated":"2020-10-28T09:58:54.885Z","comments":true,"path":"2019/06/25/geek_powershell/","link":"","permalink":"https://casuor.top/2019/06/25/geek_powershell/","excerpt":"","text":"仓库地址：oh my posh","categories":[{"name":"Geek","slug":"Geek","permalink":"https://casuor.top/categories/Geek/"}],"tags":[]},{"title":"JsDeliver-usages","slug":"geek_jsDelivrUsage","date":"2019-04-24T16:00:00.000Z","updated":"2020-10-28T09:58:54.883Z","comments":true,"path":"2019/04/25/geek_jsDelivrUsage/","link":"","permalink":"https://casuor.top/2019/04/25/geek_jsDelivrUsage/","excerpt":"","text":"GitHub CDNWe recommend using npm for projects that support it for better UX - npm packages are searchable on our website, and package pages show additional useful information, such as description and link to homepage.We use a permanent S3 storage to ensure all files remain available even if GitHub goes down, or a repository or a release is deleted by its author. Files are fetched directly from GitHub only the first time, or when S3 goes down.Load any GitHub release, commit, or branch: https://cdn.jsdelivr.net/gh/user/repo@version/fileLoad an exact version of a file: https://cdn.jsdelivr.net/gh/jquery/jquery@3.2.1/dist/jquery.min.jshttps://cdn.jsdelivr.net/gh/jquery/jquery@32b00373b3f42e5cdcb709df53f3b08b7184a944/dist/jquery.min.jsUse a version range instead of an exact version: https://cdn.jsdelivr.net/gh/jquery/jquery@3.2/dist/jquery.min.jshttps://cdn.jsdelivr.net/gh/jquery/jquery@3/dist/jquery.min.jsIf you use this feature and a file you requested is not available in the newest release, the link will keep working thanks to our version-fallback feature. We’ll continue to serve the file from older release instead of failing with a 404 error.Omit the version completely or use “latest” to load the latest one (not recommended for production usage): https://cdn.jsdelivr.net/gh/jquery/jquery@latest/dist/jquery.min.jshttps://cdn.jsdelivr.net/gh/jquery/jquery/dist/jquery.min.jsRequesting the latest version (as opposed to “latest major” or “latest minor”) is dangerous because major versions usually come with breaking changes. Only do this if you really know what you are doing.Add “.min” to any JS/CSS file to get a minified version - if one doesn’t exist, we’ll generate it for you. All generated files come with source maps and can be easily used during development: https://cdn.jsdelivr.net/gh/jquery/jquery@3.2.1/src/core.min.jsMinifying a large file can take several seconds. However, we store all generated files in our permanent storage, so this delay only applies to the first few requests.Get a directory listing: https://cdn.jsdelivr.net/gh/jquery/jquery@3.2.1/https://cdn.jsdelivr.net/gh/jquery/jquery@3.2.1/dist/Combine multiple filesOur combine endpoint allows you to load several files from npm and GitHub endpoints in one request: https://cdn.jsdelivr.net/combine/url1,url2,url3All features that work for individual files (version ranges, minification, etc.) work here as well. All combined files come with source maps and can be easily used during development. https://cdn.jsdelivr.net/combine/gh/jquery/jquery@3.2/dist/jquery.min.js,gh/twbs/bootstrap@3.3/dist/js/bootstrap.min.jshttps://cdn.jsdelivr.net/combine/npm/bootstrap@3.3/dist/css/bootstrap.min.css,npm/bootstrap@3.3/dist/css/bootstrap-theme.min.cssCombining large/many files can take several seconds. However, we store all generated files in our permanent storage, so this delay only applies to the first few requests. ProblemPackage size exceeded the configured limit of 50 MB","categories":[{"name":"Geek","slug":"Geek","permalink":"https://casuor.top/categories/Geek/"}],"tags":[]},{"title":"PHP Notes","slug":"geek_learningphp","date":"2019-04-24T16:00:00.000Z","updated":"2020-10-28T09:58:54.884Z","comments":true,"path":"2019/04/25/geek_learningphp/","link":"","permalink":"https://casuor.top/2019/04/25/geek_learningphp/","excerpt":"","text":"PHP学习笔记配置ApacheServerPS::alarm_clock:IDE好用. 安装apache服务httpd -k install -n &quot;Apache Server&quot; 注：设置下面servername 即可，但一般使用虚拟主机，可以不对其设置 设置ServerName(可省略) F:\\Develop_Apache_HttpServer\\httpd-2.4.39-win64-VC15\\Apache24\\conf\\httpd.conf 227 #ServerName www.example.com:80 228 #ServerName localhost --设置设置监听端口listen 80每次更改重启服务 本机：localhost:80 cmd进入Apache目录测试配置是否有错误httpd -t //测试配置是否OK网站根目录 DocumentRoot &quot;${SRVROOT}/htdocs&quot; &lt;Directory &quot;${SRVROOT}/htdocs&quot;&gt; 修改htdocs即可更改后出现forbidden &lt;Directory &quot;${SRVROOT}/htdocs&quot;&gt;#记得更改这个路径,一改全改 # # Possible values for the Options directive are &quot;None&quot;, &quot;All&quot;, # or any combination of: # Indexes Includes FollowSymLinks SymLinksifOwnerMatch ExecCGI MultiViews # # Note that &quot;MultiViews&quot; must be named *explicitly* --- &quot;Options All&quot; # doesn&apos;t give it to you. # # The Options directive is both complicated and important. Please see # http://httpd.apache.org/docs/2.4/mod/core.html#options # for more information. # Options Indexes FollowSymLinks # # AllowOverride controls what directives may be placed in .htaccess files. # It can be &quot;All&quot;, &quot;None&quot;, or any combination of the keywords: # AllowOverride FileInfo AuthConfig Limit # AllowOverride None # # Controls who can get stuff from this server. # Require all granted &lt;/Directory&gt;默认打开文档&lt;IfModule dir_module&gt; DirectoryIndex index.html &lt;/IfModule&gt;配置能否浏览目录结构&lt;Directory &quot;${SRVROOT}/htdocs&quot;&gt; # # Possible values for the Options directive are &quot;None&quot;, &quot;All&quot;, # or any combination of: # Indexes Includes FollowSymLinks SymLinksifOwnerMatch ExecCGI MultiViews # # Note that &quot;MultiViews&quot; must be named *explicitly* --- &quot;Options All&quot; # doesn&apos;t give it to you. # # The Options directive is both complicated and important. Please see # http://httpd.apache.org/docs/2.4/mod/core.html#options # for more information. # Options Indexes FollowSymLinks #看这里，去掉Indexes就访问不到了 # # AllowOverride controls what directives may be placed in .htaccess files. # It can be &quot;All&quot;, &quot;None&quot;, or any combination of the keywords: # AllowOverride FileInfo AuthConfig Limit # AllowOverride None # # Controls who can get stuff from this server. # Require all granted &lt;/Directory&gt;配置虚拟主机(一台机器，多个网站) 第一步 12345#行号 内容510 # Virtual hosts #去除注释511 Include conf&#x2F;extra&#x2F;httpd-vhosts.conf 第二步 本机目录：F:\\Develop_Apache_HttpServer\\httpd-2.4.39-win64-VC15\\Apache24\\conf\\extra\\httpd-vhosts.conf 123456789101112131415161718注： 特意的要去host文件去设置域名 htdocs在这里即是根目录与config文件中要相同 由于多个虚拟主机一同工作，所以需设置域名 #*:80 监听绑定在当前电脑上的任意IP的80端口&lt;VirtualHost *:80&gt;#根目录 DocumentRoot &quot;$&#123;SRVROOT&#125;&#x2F;htdocs&quot;#域名，需要在C盘hosts文件(C:\\Windows\\System32\\drivers\\etc\\hosts)去设置本机为此域名(127.0.0.1 apache.store) ServerName apache.store#显示错误反馈邮箱，暂时用不到 #ServerAdmin webmaster@dummy-host2.example.com#错误日志 ErrorLog &quot;logs&#x2F;apache.store-error.log&quot;#日志 CustomLog &quot;logs&#x2F;apache.store-access.log&quot; common&lt;&#x2F;VirtualHost&gt;这个虚拟主机配置是默认配置。测试：apache.store 请求响应流程 让Apache支持PHP（解压PHP，加载模块，addtype ）配置主配置文件 把apache的工作交给php做（apache雇佣php工作） 配置前浏览器原样输出 配置内容 配置完成 重启服务测试效果如图 apache与PHP的关系 PHP基础PHP简介PHP:Hypertext Preprocessor https://www.php.net/manual/zh/history.php.php PHP开发工具PHP Storm 配置: 出现图二的情况: PHP语法基础PHP代码块及注释1234567&lt;?php//此处是PHP代码?&gt;/*当是纯的PHP代码时，可省略闭合的\"?&gt;\"*/#单行注释 PHP大小写敏感问题(变量)1.PHP自定义函数，类和关键字（如echo ,if else）不关心大小写。 2.变量（存储信息的容器）大小写敏感。 变量规则： 变量以$符号开头，其后是变量的名称 变量名称必须以字母或下划线开头 变量名称不能以数字开头 变量名称只能包含字母数字字符和下划线（a-z,0-9以及_） 变量名称对大小写敏感（$y和$Y是两个不同的变量） 注： 变量在赋值时创建，创建输出文本需加双引号。 变量的作用域: local（局部）global（全局）static（静态） 函数之外声明的变量拥有 Global 作用域，只能在函数以外进行访问。 函数内部声明的变量拥有 LOCAL 作用域，只能在函数内部进行访问。 123456789101112131415161718&lt;?php$x=5; // 全局作用域function myTest() &#123; $y=10; // 局部作用域 echo \"&lt;p&gt;测试函数内部的变量：&lt;/p&gt;\"; echo \"变量 x 是：$x\"; echo \"&lt;br&gt;\"; echo \"变量 y 是：$x\";&#125; myTest();echo \"&lt;p&gt;测试函数之外的变量：&lt;/p&gt;\";echo \"变量 x 是：$x\";echo \"&lt;br&gt;\";echo \"变量 y 是：$x\";?&gt; PHP global 关键词global 关键词用于访问函数内的全局变量。 123456789101112&lt;?php$x=5;$y=10;function myTest() &#123; global $x,$y; $y=$x+$y;&#125;myTest();echo $y; // 输出 15?&gt; PHP 同时在名为 $GLOBALS[index] 的数组中存储了所有的全局变量。下标存有变量名。这个数组在函数内也可以访问，并能够用于直接更新全局变量。 上面的例子可以这样重写： 1234567891011&lt;?php$x=5;$y=10;function myTest() &#123; $GLOBALS['y']=$GLOBALS['x']+$GLOBALS['y'];&#125; myTest();echo $y; // 输出 15?&gt; PHP全局变量——超全局变量PHP 中的许多预定义变量都是“超全局的”，这意味着它们在一个脚本的全部作用域中都可用。在函数或方法中无需执行 global $variable; 就可以访问它们。 这些超全局变量是： 123456789$GLOBALS $_SERVER $_REQUEST $_POST $_GET $_FILES $_ENV $_COOKIE $_SESSION $GLOBALS 用于在 PHP 脚本中的任意位置访问全局变量（从函数或方法中均可）。 PHP 在名为 $GLOBALS[index] 的数组中存储了所有全局变量。变量的名字就是数组的键。 123456789&lt;?php$x=75;$y=25;function addition()&#123; $GLOBALS['variable'] = $GLOBALS['x'] +$GLOBALS['y'];&#125;addition();echo \"$variable\";?&gt; $SERVER 保存关于报头、路径和脚本位置的信息。 详见:PHP教程.pdf_P35 1234567891011121314&lt;?phpecho $_SERVER['PHP_SELF'];echo \"&lt;br&gt;\";echo $_SERVER['HTTP_HOST'];echo \"&lt;br&gt;\";echo $_SERVER['SERVER_NAME'];echo \"&lt;br&gt;\";echo $_SERVER['HTTP_REFERER'];echo \"&lt;br&gt;\";echo $_SERVER['HTTP_USER_AGENT'];echo \"&lt;br&gt;\";echo $_SERVER['SCRIPT_NAME'];echo \"&lt;br&gt;\"; $REQUEST PHP $_REQUEST 用于收集 HTML 表单提交的数据。 12345678910111213141516//REQUEST用于获取html表单提交的数据&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=\"&lt;?php echo $_SERVER['PHP_SELF'];?&gt;\" method=\"post\"&gt;Name: &lt;input type=\"text\" name=\"name\"&gt;&lt;input type=\"submit\"&gt;&lt;/form&gt;&lt;?php$name = $_REQUEST['name'];echo $name;?&gt;&lt;/body&gt;&lt;/html&gt; $POSTPHP $_POST 广泛用于收集提交 method=”post” 的 HTML 表单后的表单数据。$_POST 也常用于传递变量。 12345678910111213141516PHP $_POST 广泛用于收集提交 method=\"post\" 的 HTML 表单后的表单数据。$_POST 也常用于传递变量。&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=\"&lt;?php echo $_SERVER['PHP_SELF'];?&gt;\" method=\"post\"&gt;Name: &lt;input type=\"text\" name=\"name\"&gt;&lt;input type=\"submit\"&gt;&lt;/form&gt;&lt;?php$name = $_POST['name'];echo $name;?&gt;&lt;/body&gt;&lt;/html&gt; $GET PHP $_GET 也可用于收集提交 HTML 表单 (method=”get”) 之后的表单数据。 $_GET 也可以收集 URL 中的发送的数据。 12345678&lt;html&gt;&lt;body&gt;&lt;a href=\"$_GET.php?subject=php&amp;web=www.w3cschool.com.cn\"&gt;TEST $_GET&lt;/a&gt;&lt;br&gt;&lt;?phpecho 'study&amp;nbsp;'.$_GET['subject'].'at&amp;nbsp'.$_GET['web'];?&gt;&lt;/body&gt;&lt;/html&gt; $FILES $_FILES 主要用在当需要上传二进制文件的地方，录入上传一个abc.mp3文件，则服务器端需要获得该文件的相关信息，则通过变量 $_FILES 来取得。$_FILES 超级全局变量包含通过POST方法向服务器上传的数据的有关信息。这个超级全局变量与其他的变量有所不同，它是一个二维数组，包含5个元素。 注:① 在 PHP 4.1.0 版本以前该数组的名称为 $HTTP_POST_FILES，它并不像 $_FILES 一样是自动全局变量。PHP 3 不支持 $HTTP_POST_FILES 数组。② 如果表单中没有选择上传的文件，则 PHP 变量 1$_FILES[‘userfile’][‘size’] _的值将为 0， 1$_FILES[‘userfile’][‘tmp_name’] 将为 none。③ error字段5个错误码： UPLOAD_ERR_OK 文件成功上传UPLOAD_ERR_INI_SIZE 文件大小超出了MAX_FILE_SIZE 指令所指定的最大值。UPLOAD_ERR_FORM_SIZE 文件大小超出了MAX_FILE_SIZE 隐藏表单域参数（可选）指定的最大值。UPLOAD_ERR_PARTIAL 文件只上传了一部分UPLOAD_ERR_NO_FILE 上传表单中没有指定文件 1234567891011&lt;html&gt;&lt;body&gt;&lt;form action=\"$_FILES.php\" method=\"post\" enctype=\"multipart/form-data\"&gt;&lt;input type=\"file\" name=\"file\" &gt;&lt;input type=\"submit\" name=\"submit\" value=\"上传\"&gt;&lt;/form&gt;&lt;?phpecho $_FILES['file']['name'];?&gt;&lt;/body&gt;&lt;/html&gt; $ENV PHP中的$_ENV是一个包含服务器端环境变量的数组，不同系统不完全一样。部分变量示例：$_ENV[ ‘HOSTNAME’ ] 服务器的主机名$_ENV[ ‘SHELL’ ] 系统 shell $_ENV只是被动的接受服务器端的环境变量并把它们转换为数组元素，你可以尝试直接输出它： 123456789&lt;?php//输出内容格式清晰，ThinkPHP可以直接用dump()var_dump($_ENV);echo \"&lt;hr&gt;\";//输出到屏幕print_r($_ENV);echo \"&lt;hr&gt;\";//输出key-value键值对foreach($_ENV as $key=&gt;$val)&#123;echo $key.'--------'.$val.'&lt;br&gt;';&#125; $_COOKIE cookie 常用于识别用户。cookie 是服务器留在用户计算机中的小文件。每当相同的计算机通过浏览器请求页面时，它同时会发送 cookie。通过 PHP，您能够创建并取回 cookie 的值。 12345678910&lt;html&gt;&lt;body&gt;&lt;?phpsetcookie(\"user\", \"Alex Porter\", 3600); echo $_COOKIE['user'];?&gt;&lt;/body&gt;&lt;/html&gt; $_SESSION PHP session 变量用于存储有关用户会话的信息，或更改用户会话的设置。Session 变量保存的信息是单一用户的，并且可供应用程序中的所有页面使用。 当您运行一个应用程序时，您会打开它，做些更改，然后关闭它。这很像一次会话。计算机清楚你是谁。它知道你何时启动应用程序，并在何时终止。但是在因特网上，存在一个问题：服务器不知道你是谁以及你做什么，这是由于 HTTP 地址不能维持状态。通过在服务器上存储用户信息以便随后使用，PHP session 解决了这个问题（比如用户名称、购买商品等）。不过，会话信息是临时的，在用户离开网站后将被删除。如果您需要永久储存信息，可以把数据存储在数据库中。Session 的工作机制是：为每个访问者创建一个唯一的 id (UID)，并基于这个 UID 来存储变量。UID 存储在 cookie 中，亦或通过 URL 进行传导。 1234567891011121314151617181920212223&lt;html&gt;&lt;body&gt;&lt;?php//①开始 PHP Session ://在您把用户信息存储到 PHP session 中之前，首先必须启动会话。//注释：session_start() 函数必须位于 标签之前//session_start();//②存储 和使用Session 变量：$_SESSION['views']=1;echo \"views=\". $_SESSION['views'];//③终结 Session//如果您希望删除某些 session 数据，可以使用 unset() 或 session_destroy() 函数。//通过 unset() 函数用于释放指定的 session 变量：unset($_SESSION['views']);//通过 session_destroy() 函数彻底终结 session：//session_destroy();?&gt;&lt;/body&gt;&lt;/html&gt; PHP魔术变量PHP 向它运行的任何脚本提供了大量的预定义常量。 不过很多常量都是由不同的扩展库定义的，只有在加载了这些扩展库时才会出现，或者动态加载后，或者在编译时已经包括进去了。 有八个魔术常量它们的值随着它们在代码中的位置改变而改变。 __LINE__ 123&gt;&lt;?php&gt;echo \"&lt;br&gt;\";&gt;echo \"这是第\".__LINE__.\"行！\"; _FILE_ 123456&lt;!--文件的完整路径和文件名。如果用在被包含文件中，则返回被包含的文件名自 PHP 4.0.2 起，__FILE__总是包含一个绝对路径（如果是符号连接，则是解析后的绝对路径），而在此之前的版本有时会包含一个相对路径。--&gt;&lt;?phpecho &#39;此文件位置在&#39;.__FILE__.&#39;.&#39;; _DIr_ 123456&lt;!--__DIR__文件所在的目录。如果用在被包括文件中，则返回被包括的文件所在的目录。它等价于 dirname(__FILE__)。除非是根目录，否则目录中名不包括末尾的斜杠。(PHP 5.3.0中新 增)--&gt;&lt;?phpecho &#39;该文件位于 “ &#39; . __DIR__ . &#39; ” &#39;; _FUNCTION_ 12345678910&lt;!--__FUNCTION__函数名称（PHP 4.3.0 新加）。自 PHP 5 起本常量返回该函数被定义时的名字（区分大小写）。在 PHP 4 中该值总是小写字母的。--&gt;&lt;?phpfunction test()&#123;echo &#39;方法名是&#39;.__FUNCTION__;&#125;test(); _CLASS_ 1234567891011121314151617181920&lt;!--类的名称（PHP 4.3.0 新加）。自 PHP 5 起本常量返回该类被定义时的名字（区分大小写）。在 PHP 4 中该值总是小写字母的。类名包括其被声明的作用区域（例如 Foo\\Bar）。注意自 PHP 5.4 起 __CLASS__ 对 trait 也起作用。当用在 trait 方法中时，__CLASS__ 是调用 trait 方法的类的名字。--&gt;&lt;?phpclass test&#123; function _print() &#123; echo &#39;类名为：&#39; . __CLASS__ . &quot;&lt;br&gt;&quot;; echo &#39;函数名为：&#39; . __FUNCTION__; &#125;&#125;$t &#x3D; new test();$t-&gt;_print();?&gt; __TRAIT__ 12345678910111213141516171819202122&lt;!--__TRAIT__Trait 的名字（PHP 5.4.0 新加）。自 PHP 5.4.0 起，PHP 实现了代码复用的一个方法，称为 traits。Trait 名包括其被声明的作用区域（例如 Foo\\Bar）。从基类继承的成员被插入的 SayWorld Trait 中的 MyHelloWorld 方法所覆盖。其行为 MyHelloWorld 类 中定义的方法一致。优先顺序是当前类中的方法会覆盖 trait 方法，而 trait 方法又覆盖了基类中的方 法。--&gt;&lt;?phpclass Base&#123; public function sayhello()&#123; echo &quot;hello&quot;; &#125;&#125;trait SayWorld&#123; public function sayhello()&#123; parent::sayhello(); echo &quot;world&quot;; &#125;&#125;class Myhelloworld extends Base&#123; use SayWorld;&#125;$o&#x3D;new Myhelloworld();$o-&gt;sayhello(); __METHOD__ 123456789&lt;!--返回该方法被定义时的名字（区分大小写）。--&gt;&lt;?phpfunction test()&#123; echo &#39;函数名为:&#39;.__METHOD__;&#125;test(); _NAMESPACE_ 1234&lt;?php namespace MyProject;echo &#39;命名空间为：&quot;&#39;, __NAMESPACE__, &#39;&quot;&#39;; &#x2F;&#x2F; 输出 &quot;MyProject&quot; \\?&gt; PHP命名空间PHP 命名空间可以解决以下两类问题： 用户编写的代码与PHP内部的类/函数/常量或第三方类/函数/常量之间的名字冲突。 为很长的标识符名称(通常是为了缓解第一类问题而定义的)创建一个别名（或简短）的名称，提高 源代码的可读性 定义命名空间 默认情况下，所有常量、类和函数名都放在全局空间下，就和PHP支持命名空间之前一样。命名空间通过关键字namespace 来声明。如果一个文件中包含命名空间，它必须在其它所有代码之前 声明命名空间。语法格式如下: 123&lt; ?php &#x2F;&#x2F; 定义代码在 &#39;MyProject&#39; 命名空间中 namespace MyProject; &#x2F;&#x2F; ... 代码 ... 你也可以在同一个文件中定义不同的命名空间代码，如： 12345678&lt; ?php namespace MyProject1; &#x2F;&#x2F; MyProject1 命名空间中的PHP代码 namespace MyProject2; &#x2F;&#x2F; MyProject2 命名空间中的PHP代码 &#x2F;&#x2F; 另一种语法 namespace MyProject3 &#123; &#x2F;&#x2F; MyProject3 命名空间中的PHP代码 &#125; ?&gt; ps:不建议使用这种语法在单个文件中定义多个命名空间。建议使用下面的大括号形式的语法。 12345678910111213&lt;?phpnamespace MyProject &#123; const CONNECT_OK = 1; class Connection &#123; /* ... */ &#125; function connect() &#123; /* ... */ &#125;&#125;namespace AnotherProject &#123; const CONNECT_OK = 1; class Connection &#123; /* ... */ &#125; function connect() &#123; /* ... */ &#125;&#125;?&gt; 将全局的非命名空间中的代码与命名空间中的代码组合在一起，只能使用大括号形式的语法。全局代码必须用一个不带名称的 namespace 语句加上大括号括起来，例如： 1234567891011121314&lt;?phpnamespace MyProject &#123;const CONNECT_OK = 1;class Connection &#123; /* ... */ &#125;function connect() &#123; /* ... */ &#125;&#125;namespace &#123; // 全局代码session_start();$a = MyProject\\connect();echo MyProject\\Connection::start();&#125;?&gt; 在声明命名空间之前唯一合法的代码是用于定义源文件编码方式的 declare 语句。所有非 PHP 代码包 括空白符都不能出现在命名空间的声明之前. 12345678910111213141516171819202122232425262728&lt;?php declare(encoding='UTF-8'); //定义多个命名空间和不包含在命名空间中的代码namespace MyProject &#123; const CONNECT_OK = 1; class Connection &#123; /* ... */ &#125; function connect() &#123; /* ... */ &#125;&#125;namespace &#123; session_start(); $a = MyProject\\connect(); echo MyProject\\connect()::start();&#125;?&gt;&lt;!--F:\\Develop_PHP\\php-7.1.31-Win32-VC14-x64\\php.exe F:\\Develop_Apache_HttpServer\\httpd-2.4.39-win64-VC15\\Apache24\\htdocs\\PHP_Projects\\PrimarySyntax\\NameSpace\\NameSpace.phpPHP Warning: declare(encoding=...) ignored because Zend multibyte feature is turned off by settings in F:\\Develop_Apache_HttpServer\\httpd-2.4.39-win64-VC15\\Apache24\\htdocs\\PHP_Projects\\PrimarySyntax\\NameSpace\\NameSpace.php on line 1PHP Fatal error: Uncaught Error: Class name must be a valid object or a string in F:\\Develop_Apache_HttpServer\\httpd-2.4.39-win64-VC15\\Apache24\\htdocs\\PHP_Projects\\PrimarySyntax\\NameSpace\\NameSpace.php:16Stack trace:#0 &#123;main&#125; thrown in F:\\Develop_Apache_HttpServer\\httpd-2.4.39-win64-VC15\\Apache24\\htdocs\\PHP_Projects\\PrimarySyntax\\NameSpace\\NameSpace.php on line 16Process finished with exit code 255--&gt; 子命名空间 与目录和文件的关系很象，PHP 命名空间也允许指定层次化的命名空间的名称。因此，命名空间的名 字可以使用分层次的方式定义: 12345678910111213&lt;?phpnamespace MyProject\\Sub\\Level;&#x2F;&#x2F;声明分层次的单个命名空间const CONNECT_OK &#x3D; 1;class Connection&#123; &#x2F;* ... *&#x2F;&#125;function Connect()&#123; &#x2F;* ... *&#x2F;&#125;?&gt; 上面的例子创建了 常量 MyProject\\Sub\\Level\\CONNECT_OK， 类 MyProject\\Sub\\Level\\Connection 函数 MyProject\\Sub\\Level\\Connection。 命名空间使用 PHP 命名空间中的类名可以通过三种方式引用： 非限定名称，或不包含前缀的类名称，例如 $a=new foo(); 或 foo::staticmethod();。如果当前命名空间是 currentnamespace，foo 将被解析为 currentnamespace\\foo。如果使用 foo 的代码是全局的，不包含在任何命名空间中的代码，则 foo 会被解析为foo。 PS：如果命名空间中的函数或常量未定义，则该非限定的函数名称或常量名称会被解析为全局函数名称或常量名称。 限定名称,或包含前缀的名称，例如 $a = new subnamespace\\foo(); 或 subnamespace\\foo::staticmethod();。如果当前的命名空间是 currentnamespace，则 foo 会被解析为 currentnamespace\\subnamespace\\foo。如果使用 foo 的代码是全局的，不包含在任何命名空间中的代码，foo 会被解析为subnamespace\\foo。 完全限定名称，或包含了全局前缀操作符的名称，例如， $a = new \\currentnamespace\\foo(); 或 \\currentnamespace\\foo::staticmethod();。在这种情况下，foo 总是被解析为代码中的文字名(literal name)currentnamespace\\foo。 DEMO01 123456789&lt;?phpnamespace Foo\\Bar\\Subnamespace;const FOO=1;function foo()&#123;&#125;class foo&#123; static function staticmethod()&#123;&#125;&#125;?&gt; DEMO02 12345678910111213141516171819202122232425262728293031323334353637383940&lt;?phpnamespace Foo\\Bar;//命名空间为Foo\\Bar,位于Foo下include \"Demo01NameSpace.php\";//echo \"全局代码应包含在全局名称空间声明中\";const FOO=2;function Foo()&#123;&#125;class Foo&#123; static function staticmethod()&#123;&#125;&#125;/* 非限定名称 */foo();// 解析为 Foo\\Bar\\foo这个函数foo::staticmethod();// 解析为类 Foo\\Bar\\foo的静态方法staticmethod。echo FOO;// 解析为 Foo\\Bar\\ FOO这个常量/* 限定名称 */subnamespace\\foo();// 解析为函数 Foo\\Bar\\subnamespace\\foosubnamespace\\foo::staticmethod();// 解析为类 Foo\\Bar\\subnamespace\\foo,// 以及类的方法 staticmethodecho subnamespace\\FOO;/// 解析为常量 Foo\\Bar\\subnamespace\\FOO/* 完全限定名称 */\\Foo\\Bar\\foo();// 解析为函数 Foo\\Bar\\foo\\Foo\\Bar\\foo::staticmethod();// 解析为类 Foo\\Bar\\foo, 以及类的方法 staticmethodecho \\Foo\\Bar\\FOO;// 解析为常量 Foo\\Bar\\FOO DEMO03 123456789&lt;?phpnamespace Foo;//命名空间为Foofunction strlen() &#123;&#125;const INI_ALL = 3;class Exception &#123;&#125;$a = \\strlen('hi'); // 调用全局函数strlen$b = \\INI_ALL; // 访问全局常量 INI_ALL$c = new \\Exception('error'); // 实例化全局类 Exception :orange: PS:不就是路径访问的结构,具体怎么实现不知道 命名空间和动态语言特征 PHP 命名空间的实现受到其语言自身的动态特征的影响。因此，如果要将下面的代码转换到命名空间中，动态访问元素。 DEMO01 1234567891011121314151617&lt;?phpclass cname&#123; function __construct() &#123; echo __METHOD__,\"\\n\";//输出方法名:__construct &#125;&#125;function fname()&#123; echo __FUNCTION__,\"\\n\";//输出方法名:fname&#125;const conname=\"global\";//常量:conname$a='cname';$obj = new $a;//打印cname::__construct$b='fname';$b(); //打印fnameecho constant('conname'),\"\\n\";//打印conname 输出结果: 12cname::__construct fname global &#x2F;&#x2F;嗯结果打印了全局的结构类,方法,常量 必须使用完全限定名称（包括命名空间前缀的类名称）。注意因为在动态的类名称、函数名称或常量名称中，限定名称和完全限定名称没有区别，因此其前导的反斜杠是不必要的。 动态访问命名空间的元素 DEMO02 1234567891011121314151617181920212223242526272829303132333435&lt;?phpnamespace namespacename;class cname&#123; function __construct() &#123; echo __METHOD__,\"\\n\"; &#125;&#125;function fname()&#123; echo __FUNCTION__,\"\\n\";&#125;const constname = \"global\";include 'Demo04NameSpace&amp;Dynamic.php';$a = 'cname';$obj = new $a; // prints classname::__construct$b = 'fname';$b(); // prints funcnameecho constant('constname'), \"\\n\"; // prints global//echo constant(\"namespacename\\constname\"),\"\\n\";/* note that if using double quotes, \"\\\\namespacename\\\\classname\" must be used */$a = '\\namespacename\\cname';$obj = new $a; // prints namespacename\\classname::__construct$a = 'namespacename\\cname';$obj = new $a; // also prints namespacename\\classname::__construct$b = 'namespacename\\fname';$b(); // prints namespacename\\funcname$b = '\\namespacename\\fname';$b(); // also prints namespacename\\funcnameecho constant('\\namespacename\\constname'), \"\\n\"; // prints namespacedecho constant('namespacename\\constname'), \"\\n\"; // also prints namespaced?&gt; 输出结果: 1error:Couldn&#39;t find constant constname :orange: PS:这这讲的不是一个问题吗 namespace关键字和__NAMESPACE__常量 PHP static 关键词通常，当函数完成/执行后，会删除所有变量。不过，有时我需要不删除某个局部变量。实现这一点需要首次声明变量时使用 static 关键词。 123456789101112131415&lt;?phpfunction myTest() &#123; static $x=0; echo $x; $x++;&#125;myTest();myTest();myTest();?&gt; 然后，每当函数被调用时，这个变量所存储的信息都是函数最后一次被调用时所包含的信息。 注释：该变量仍然是函数的局部变量。 PHP数据类型PHP是一种松散型语言，不用告知类型，自动数据类型。 字符串、整数、浮点数、逻辑、数组、对象、NULL。 字符串可以是引号内的任何文本。您可以使用单引号或双引号。 整数是没有小数的数字。 整数规则： 整数必须有至少一个数字（0-9）整数不能包含逗号或空格整数不能有小数点整数正负均可可以用三种格式规定整数：十进制、十六进制（前缀是 0x）或八进制（前缀是 0） PHP var_dump() 会返回变量的数据类型和值。 1234567891011121314151617181920212223&lt;?php$x=5985;var_dump($x);echo(\"&lt;br&gt;\");$x=-345;var_dump($x);echo(\"&lt;br&gt;\");$x=0x8C;var_dump($x);echo(\"&lt;br&gt;\");$x=047;var_dump($x);echo(\"&lt;br&gt;\");?&gt;结果：int(5985)int(-345)int(140)int(39) 浮点数是有小数点或指数形式的数字。 1234567891011121314151617&lt;?php$x=10.365;var_dump($x);echo(\"&lt;br&gt;\");$x=2.4e3;var_dump($x);echo(\"&lt;br&gt;\");$x=8E-5;var_dump($x);echo(\"&lt;br&gt;\");?&gt;结果： float(10.365)float(2400)float(8.0E-5) 逻辑是 true 或 false。 数组在一个变量中存储多个值。 123456&lt;?php$cars=array(\"volvo\",\"bwm\",\"saab\");var_dump($cars);?&gt;结果：array(3) &#123; [0]=&gt; string(5) \"volvo\" [1]=&gt; string(3) \"bwm\" [2]=&gt; string(4) \"saab\" &#125; 创建数组 在 PHP 中， array() 函数用于创建数组： 1array(); 在 PHP 中，有三种数组类型： 索引数组 - 带有数字索引的数组 有两种创建索引数组的方法： 索引是自动分配的（索引从 0 开始）： 1$cars=array(\"Volvo\",\"BMW\",\"SAAB\"); 手动分配索引 123$cars[0]=\"Volvo\";$cars[1]=\"BMW\";$cars[2]=\"SAAB\"; 关联数组 - 带有指定键的数组 关联数组是使用您分配给数组的指定键的数组。 有两种创建关联数组的方法： 1$age=array(\"Peter\"=&gt;\"35\",\"Ben\"=&gt;\"37\",\"Joe\"=&gt;\"43\"); 123$age['Peter']=\"35\";$age['Ben']=\"37\";$age['Joe']=\"43\"; 多维数组 - 包含一个或多个数组的数组 数组的方法 获得数组的长度 - count() 函数 1234&lt;?php$cars=array(\"Volvo\",\"BMW\",\"SAAB\");echo count($cars);?&gt; PHP - 数组的排序函数 sort() - 以升序对数组排序rsort() - 以降序对数组排序asort() - 根据值，以升序对关联数组进行排序ksort() - 根据键，以升序对关联数组进行排序arsort() - 根据值，以降序对关联数组进行排序krsort() - 根据键，以降序对关联数组进行排序 遍历一般数组 12345678&gt;&lt;?php$cars = array('volvo' ,'bmw','saab' );$arraylenth=count($cars);for ($i=0; $i &lt;$arraylenth ; $i++) &#123; echo $cars[$i]; echo \"&lt;br&gt;\";&#125;?&gt; 遍历关联数组 12345678&gt;&lt;?php$age=array(\"Bill\"=&gt;\"35\",\"Steve\"=&gt;\"37\",\"Peter\"=&gt;\"43\");foreach($age as $x=&gt;$x_value) &#123;echo \"Key=\" . $x . \", Value=\" . $x_value;echo \"&lt;br&gt;\";&#125;?&gt; 对象是存储数据和有关如何处理数据的信息的数据类型。 在 PHP 中，必须明确地声明对象。 首先我们必须声明对象的类。对此，我们使用 class 关键词。类是包含属性和方法的结构。 然后我们在对象类中定义数据类型，然后在该类的实例中使用此数据类型： 123456789101112&gt;&lt;?phpclass car&#123; var $color; function car($color=\"green\")&#123; $this-&gt;color=$color; &#125; function what_color()&#123; return $this-&gt;color; &#125;&#125;?&gt; 特殊的 NULL 值表示变量无值。NULL 是数据类型 NULL 唯一可能的值。 NULL 值标示变量是否为空。也用于区分空字符串与空值数据库。 可以通过把值设置为 NULL，将变量清空： PHP的输出方法 echo 和 print 之间的差异： echo - 能够输出一个以上的字符串print - 只能输出一个字符串，并始终返回 1 提示：echo 比 print 稍快，因为它不返回任何值。 echo 是一个语言结构，有无括号均可使用：echo 或 echo()。 print 也是语言结构，有无括号均可使用：print 或 print()。 显示字符串 123456&lt;?phpecho \"&lt;h2&gt;PHP is fun!&lt;/h2&gt;\";echo \"Hello world!&lt;br&gt;\";echo \"I'm about to learn PHP!&lt;br&gt;\";echo \"This\", \" string\", \" was\", \" made\", \" with multiple parameters.\";?&gt; 12345&lt;?phpprint &quot;&lt;h2&gt;PHP is fun!&lt;&#x2F;h2&gt;&quot;;print &quot;Hello world!&lt;br&gt;&quot;;print &quot;I&#39;m about to learn PHP!&quot;;?&gt; 显示变量 1234567891011&lt;?php$txt1=\"learn php\";$txt2=\"w3school.com.cn\";$cars=array(\"volvo\",\"bwm\",\"saab\");echo $txt1;echo \"&lt;br&gt;\";echo \"study php at $txt2\";echo \"&lt;br&gt;\";echo \"my car is a &#123;$cars[0]&#125;\";?&gt; PHP常用函数字符串函数 strlen()字符串长度 123&lt;?phpecho strlen(\"hello world\");?&gt; strpos() 函数用于检索字符串内指定的字符或文本。 如果找到匹配，则会返回首个匹配的字符位置。如果未找到匹配，则将返回 FALSE。 1234&lt;?phpecho strpos(\"hello world\", \"world\");?&gt;结果：6 PHP 常量 常量是单个值的标识符（名称）。在脚本中无法改变该值。 有效的常量名以字符或下划线开头（常量名称前面没有 $ 符号）。 注释：与变量不同，常量贯穿整个脚本是自动全局的。 设置 PHP 常量如需设置常量，请使用 define() 函数 - 它使用三个参数： 首个参数定义常量的名称 第二个参数定义常量的值 可选的第三个参数规定常量名是否对大小写敏感。默认是 false。 1234&lt;?phpdefine('greeting', 'welcome to w3cschool.com.cn');echo(greeting);?&gt; 1234&lt;?phpdefine('greeting', 'welcome to w3cschool.com.cn',true);echo(GREETING);?&gt; PHP运算符 PHP 算数运算符——+-*/% PHP 赋值运算符——略 PHP 字符串运算符 . 串接 .= 串接赋值 1234567&lt;?php$a=\"hello\";$b=$a.\" world!\";echo($b.\"&lt;br&gt;\");$a.=\"world!!!\";echo($a);?&gt; PHP 递增/递减运算符 ++$x 前递增 $x 加一递增，然后返回 $x$x++ 后递增 返回 $x，然后 $x 加一递增–$x 前递减 $x 减一递减，然后返回 $x$x– 后递减 返回 $x，然后 $x 减一递减 1234567891011121314&lt;?php$x=10; echo ++$x; // 输出 11$y=10; echo $y++; // 输出 10$z=5;echo --$z; // 输出 4$i=5;echo $i--; // 输出 5?&gt; PHP 比较运算符 12345678910&lt;?php$x&#x3D;10; $y&#x3D;&#39;10&#39;; echo(&quot;&#x3D;&#x3D;&quot;);var_dump($x&#x3D;&#x3D;$y);echo(&quot;&lt;br&gt;&quot;.&quot;&#x3D;&#x3D;&#x3D;&quot;);var_dump($x&#x3D;&#x3D;&#x3D;$y);?&gt; PHP 逻辑运算符 PHP 数组运算符 123456789101112131415161718192021222324252627282930313233&lt;?php$x = array('a' =&gt;\"red\" ,\"b\"=&gt;\"green\");$y = array('c' =&gt;\"blue\" ,\"d\"=&gt;\"yellow\");$a = array('a' =&gt; \"orange\", \"f\"=&gt;\"pink\");$b = array('e' =&gt; \"red\", \"f\"=&gt;\"pink\");$z=$x+$y;$c=$x+$a;$d=$x+$b;var_dump($z);echo(\"&lt;br&gt;\");var_dump($c);echo(\"&lt;br&gt;\");var_dump($d);echo(\"&lt;br&gt;\");var_dump($x==$y);echo(\"&lt;br&gt;\");var_dump($x===$y);echo(\"&lt;br&gt;\");var_dump($x!=$y);echo(\"&lt;br&gt;\");var_dump($x&lt;&gt;$y);echo(\"&lt;br&gt;\");var_dump($x!==$y);?&gt; 结果：array(4) &#123; [\"a\"]=&gt; string(3) \"red\" [\"b\"]=&gt; string(5) \"green\" [\"c\"]=&gt; string(4) \"blue\" [\"d\"]=&gt; string(6) \"yellow\" &#125;array(3) &#123; [\"a\"]=&gt; string(3) \"red\" [\"b\"]=&gt; string(5) \"green\" [\"f\"]=&gt; string(4) \"pink\" &#125;array(4) &#123; [\"a\"]=&gt; string(3) \"red\" [\"b\"]=&gt; string(5) \"green\" [\"e\"]=&gt; string(3) \"red\" [\"f\"]=&gt; string(4) \"pink\" &#125;bool(false)bool(false)bool(true)bool(true)bool(true) PHP 条件语句 PHP if else 语句 PHP Switch 语句 语法 12345678910111213switch (expression)&#123;case label1: code to be executed if expression = label1; break; case label2: code to be executed if expression = label2; break;default: code to be executed if expression is different from both label1 and label2;&#125; 工作原理 对表达式（通常是变量）进行一次计算 把表达式的值与结构中 case 的值进行比较 如果存在匹配，则执行与 case 关联的代码 代码执行后，break 语句阻止代码跳入下一个 case 中继续执行 如果没有 case 为真，则使用 default 语句 PHP while 循环 while - 只要指定条件为真，则循环代码块do…while - 先执行一次代码块，然后只要指定条件为真则重复循环for - 循环代码块指定次数foreach - 遍历数组中的每个元素并循环代码块 注： 语法 123foreach ($array as $value) &#123; code to be executed;&#125; 每进行一次循环迭代，当前数组元素的值就会被赋值给 $value 变量，并且数组指针会逐一地移动，直到到达最后一个数组元素。 123456&lt;?php$colors = array('red','green','blue','yellow' );foreach ($colors as $value) &#123; echo \"$value&lt;br&gt;\";&#125;?&gt; PHP函数 注: PHP 默认参数值 下面的例子展示了如何使用默认参数。如果我们调用没有参数的 setHeight() 函数，它的参数会取默认值： 12345678&lt;?phpfunction setHeight($mineheight=50)&#123; echo \"the height is:$mineheight&lt;br&gt;\";&#125; setHeight(350);setHeight();?&gt;","categories":[{"name":"Geek","slug":"Geek","permalink":"https://casuor.top/categories/Geek/"}],"tags":[]},{"title":"Node.js Usages-01","slug":"geek_Nodejsuse01","date":"2019-04-19T16:00:00.000Z","updated":"2020-10-28T09:58:54.880Z","comments":true,"path":"2019/04/20/geek_Nodejsuse01/","link":"","permalink":"https://casuor.top/2019/04/20/geek_Nodejsuse01/","excerpt":"","text":"安装NVM Node管理Nvm-windos 常用命令 nvm install node problem: The process cannot access the file because it is being used by another process. 方案1： 淘宝镜像 nvm node_mirror https://npm.taobao.org/mirrors/node/ nvm npm_mirror https://npm.taobao.org/mirrors/npm/ 方案2： 直接下载个exe安装到nvm所指定的路径名称改为(LTS版本：’v12.13.1’) 预览: 配置npm配置#查看配置信息 npm config ls #修改全局Node moudle位置 初始位置： prefix = &quot;C:\\\\Users\\\\16877\\\\AppData\\\\Roaming\\\\npm&quot; cache = &quot;C:\\\\Users\\\\16877\\\\AppData\\\\Roaming\\\\npm-cache&quot; 修改： npm config set prefix &quot;F:\\Develop_Node.js\\Gobal_Npm_Module&quot; npm config set cache &quot;F:\\Develop_Node.js\\Gobal_Npm_Cache&quot; #修改Npm cache位置PS:其他也可以设置 使用cnpmnpm install -g cnpm --registry=https://registry.npm.taobao.org #此外需添加环境变量 cnpm -vPS:诸多网速问题，使用cnpm比较好 类似问题解决方案： cnpm install or npm install #使用npm卡住需在.npmrc文件添加（使用 npm config ls可以找到这一项） registry=https://registry.npm.taobao.org #install.js 卡住也是此类问题，同样设置依赖镜像地址 #如install electron: electron_mirror=&quot;https://npm.taobao.org/mirrors/electron/&quot;PS:install.js文件中有electron_mirror这一项，使用cnpm没问题 nrm—切换npm源 nrm 是一个 NPM 源管理器，允许你快速地在如下 NPM 源间切换： 1.安装 npm install -g nrm2.使用 #列出可选的源 nrm ls #查看所有或指定测试源响应时间 nrm test [name] #切换指定源 nrm use &lt;name&gt;","categories":[{"name":"Geek","slug":"Geek","permalink":"https://casuor.top/categories/Geek/"}],"tags":[]},{"title":"数据结构 Notes","slug":"geek数据结构","date":"2019-03-24T16:00:00.000Z","updated":"2020-10-28T09:58:54.887Z","comments":true,"path":"2019/03/25/geek数据结构/","link":"","permalink":"https://casuor.top/2019/03/25/geek%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/","excerpt":"","text":"1、按值得不同类型数据类型分为： 1.非结构的原子类型：不可分解 原子类型： 2.结构类型：可分解，如数组 固定聚合类型：确定数目的数据由某种结构组成 可变聚合类型：数目不确定 2、从硬件角度： 数据类型实现了某种信息的屏蔽 抽象数据类型： abstract data type:一种数学模型以及定义在该模型上的一组操作 抽象数据类型的定义仅仅取决于他的一组逻辑特性，而与其在计算机内如何表示和实现无关，即不论其内部结构如何变化，只要他的数学特性不变，都不影响其外部使用。 抽象数据类型和数据类型实质上是一个概念","categories":[{"name":"Geek","slug":"Geek","permalink":"https://casuor.top/categories/Geek/"}],"tags":[]},{"title":"Redis笔记","slug":"geek_redis使用笔记","date":"2019-02-28T16:00:00.000Z","updated":"2021-03-16T10:37:58.025Z","comments":true,"path":"2019/03/01/geek_redis使用笔记/","link":"","permalink":"https://casuor.top/2019/03/01/geek_redis%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/","excerpt":"","text":"简介Redis 是完全开源的，遵守 BSD 协议，是一个NOSQL(not only sql)非关系型高性能的 key-value 数据库。 Redis 与其他 key - value 缓存产品有以下三个特点： Redis支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。 Redis不仅仅支持简单的key-value类型的数据，同时还提供list，set，zset，hash等数据结构的存储。 Redis支持数据的备份，即master-slave模式的数据备份。 1.1.什么是NOSQL NoSQL(NoSQL = Not Only SQL)，意即“不仅仅是SQL”，是一项全新的数据库理念，泛指非关系型的数据库。 随着互联网web2.0网站的兴起，传统的关系数据库在应付web2.0网站，特别是超大规模和高并发的SNS类型的web2.0纯动态网站已经显得力不从心，暴露了很多难以克服的问题，而非关系型的数据库则由于其本身的特点得到了非常迅速的发展。NoSQL数据库的产生就是为了解决大规模数据集合多重数据种类带来的挑战，尤其是大数据应用难题。 1.1.1. NOSQL和关系型数据库比较 优点： 1）成本：nosql数据库简单易部署，基本都是开源软件，不需要像使用oracle那样花费大量成本购买使用，相比关系型数据库价格便宜。 2）查询速度：nosql数据库将数据存储于缓存之中，关系型数据库将数据存储在硬盘中，自然查询速度远不及nosql数据库。 3）存储数据的格式：nosql的存储格式是key,value形式、文档形式、图片形式等等，所以可以存储基础类型以及对象或者是集合等各种格式，而数据库则只支持基础类型。 4）扩展性：关系型数据库有类似join这样的多表查询机制的限制导致扩展很艰难。 缺点： 1）维护的工具和资料有限，因为nosql是属于新的技术，不能和关系型数据库10几年的技术同日而语。 2）不提供对sql的支持，如果不支持sql这样的工业标准，将产生一定用户的学习和使用成本。 3）不提供关系型数据库对事务的处理。 1.1.2. 非关系型数据库的优势： 1）性能NOSQL是基于键值对的，可以想象成表中的主键和值的对应关系，而且不需要经过SQL层的解析，所以性能非常高。 2）可扩展性同样也是因为基于键值对，数据之间没有耦合性，所以非常容易水平扩展。 1.1.3. 关系型数据库的优势： 1）复杂查询可以用SQL语句方便的在一个表以及多个表之间做非常复杂的数据查询。 2）事务支持使得对于安全性能很高的数据访问要求得以实现。对于这两类数据库，对方的优势就是自己的弱势，反之亦然。 1.1.4. 总结 关系型数据库与NoSQL数据库并非对立而是互补的关系，即通常情况下使用关系型数据库，在适合使用NoSQL的时候使用NoSQL数据库， 让NoSQL数据库对关系型数据库的不足进行弥补。 一般会将数据存储在关系型数据库中，在nosql数据库中备份存储关系型数据库的数据 1.2.主流的NOSQL产品 • 键值(Key-Value)存储数据库 相关产品： Tokyo Cabinet/Tyrant、Redis、Voldemort、Berkeley DB 典型应用： 内容缓存，主要用于处理大量数据的高访问负载。 数据模型： 一系列键值对 优势： 快速查询 劣势： 存储的数据缺少结构化 • 列存储数据库 相关产品：Cassandra, HBase, Riak 典型应用：分布式的文件系统 数据模型：以列簇式存储，将同一列数据存在一起 优势：查找速度快，可扩展性强，更容易进行分布式扩展 劣势：功能相对局限 • 文档型数据库 相关产品：CouchDB、MongoDB 典型应用：Web应用（与Key-Value类似，Value是结构化的） 数据模型： 一系列键值对 优势：数据结构要求不严格 劣势： 查询性能不高，而且缺乏统一的查询语法 • 图形(Graph)数据库 相关数据库：Neo4J、InfoGrid、Infinite Graph 典型应用：社交网络 数据模型：图结构 优势：利用图结构相关算法。 劣势：需要对整个图做计算才能得出结果，不容易做分布式的集群方案。 Redis 优势 性能极高 – Redis能读的速度是110000次/s,写的速度是81000次/s 。 丰富的数据类型 – Redis支持二进制案例的 Strings, Lists, Hashes, Sets 及 Ordered Sets 数据类型操作。 原子 – Redis的所有操作都是原子性的，意思就是要么成功执行要么失败完全不执行。单个操作是原子性的。多个操作也支持事务，即原子性，通过MULTI和EXEC指令包起来。 丰富的特性 – Redis还支持 publish/subscribe, 通知, key 过期等等特性。 Redis与其他key-value存储有什么不同？ Redis有着更为复杂的数据结构并且提供对他们的原子性操作，这是一个不同于其他数据库的进化路径。Redis的数据类型都是基于基本数据结构的同时对程序员透明，无需进行额外的抽象。 Redis运行在内存中但是可以持久化到磁盘，所以在对不同数据集进行高速读写时需要权衡内存，因为数据量不能大于硬件内存。在内存数据库方面的另一个优点是，相比在磁盘上相同的复杂的数据结构，在内存中操作起来非常简单，这样Redis可以做很多内部复杂性很强的事情。同时，在磁盘格式方面他们是紧凑的以追加的方式产生的，因为他们并不需要进行随机访问。 应用场景• 缓存（数据查询、短连接、新闻内容、商品内容等等） • 聊天室的在线好友列表 • 任务队列。（秒杀、抢购、12306等等） • 应用排行榜 • 网站访问统计 • 数据过期处理（可以精确到毫秒 • 分布式集群架构中的session分离Reference1. 官网：https://redis.io 2. 中文网：http://www.redis.net.cn/ 3. 解压直接可以使用： * redis.windows.conf：配置文件 * redis-cli.exe：redis的客户端 * redis-server.exe：redis服务器端数据类型各个数据类型应用场景： 类型 简介 特性 场景 String(字符串) 二进制安全 可以包含任何数据,比如jpg图片或者序列化的对象,一个键最大能存储512M — Hash(字典) 键值对集合,即编程语言中的Map类型 适合存储对象,并且可以像数据库中update一个属性一样只修改某一项属性值(Memcached中需要取出整个字符串反序列化成对象修改完再序列化存回去) 存储、读取、修改用户属性 List(列表) 链表(双向链表) 增删快,提供了操作某一段元素的API 1,最新消息排行等功能(比如朋友圈的时间线) 2,消息队列 Set(集合) 哈希表实现,元素不重复 1、添加、删除,查找的复杂度都是O(1) 2、为集合提供了求交集、并集、差集等操作 1、共同好友 2、利用唯一性,统计访问网站的所有独立ip 3、好友推荐时,根据tag求交集,大于某个阈值就可以推荐 Sorted Set(有序集合) 将Set中的元素增加一个权重参数score,元素按score有序排列 数据插入集合时,已经进行天然排序 1、排行榜 2、带权重的消息队列 redis 命令常用命令Redis 客户端的基本语法为： 12$ redis-cli$ redis-cli -h host -p port -a password 有时候会有中文乱码。要在 redis-cli 后面加上 –rawredis-cli –raw就可以避免中文乱码了 123456789101112131415161718192021222324252627#字符串set key valueget ketdel key#哈希hset key field valuehget key fieldhgetall key #获取所有的键值hdel key field #列表 lpush key value #左添加rpush key value #右添加lrange key value #范围获取lpop key #左删rpop key #右删#集合sadd key value smembers key #获取所有srem key value #删除指定#有序集合zadd key score valuezrange key start end[0 -1] withscoreszren key value 通用命令123keys * #获取所有键type key #获取键对应值的类型del key # 持久化RDB redis是一个内存数据库，当redis服务器重启，获取电脑重启，数据会丢失，我们可以将redis内存中的数据持久化保存到硬盘的文件中。 redis持久化机制： RDB：默认方式，不需要进行配置，默认就使用这种机制 在一定的间隔时间中，检测key的变化情况，然后持久化数据 编辑redis.windwos.conf文件123456#after 900 sec (15 min) if at least 1 key changedsave 900 1#after 300 sec (5 min) if at least 10 keys changedsave 300 10#after 60 sec if at least 10000 keys changedsave 60 10000 重新启动redis服务器，并指定配置文件名称 D:\\JavaWeb2018\\day23_redis\\资料\\redis\\windows-64\\redis-2.8.9&gt;redis-server.exe redis.windows.conf AOF12345672. AOF：日志记录的方式，可以记录每一条命令的操作。可以每一次命令操作后，持久化数据 1. 编辑redis.windwos.conf文件 appendonly no（关闭aof） --&gt; appendonly yes （开启aof） # appendfsync always ： 每一次操作都进行持久化 appendfsync everysec ： 每隔一秒进行一次持久化 # appendfsync no ： 不进行持久化","categories":[{"name":"Geek","slug":"Geek","permalink":"https://casuor.top/categories/Geek/"}],"tags":[]},{"title":"算法导论札记","slug":"geek_算法导论","date":"2019-02-24T16:00:00.000Z","updated":"2020-10-28T09:58:54.887Z","comments":true,"path":"2019/02/25/geek_算法导论/","link":"","permalink":"https://casuor.top/2019/02/25/geek_%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/","excerpt":"","text":"1)插入排序c1nn2）归并排序c2nlgn 算法分析：–运行时间来说，c1&lt;c2插入排序有一个因子n的地方，归并排序有一个因子lgn,后者小于前者，对于小的输入规模，插入排序比归并排序要快，但是一旦输入规模n变得足够大，归并排序lgn对n的优点将足以补偿常数因子的差别不管c1比c2小多少，总会存在一个交叉点，超出这个点，归并排序更快。 结论：问题规模的增大，归并排序的优势也会增大 ————习题——————–1、给出应用曾需要算法内容的的应用的一个例子。2、相同机器上实现插入排序和归并排序，对于规模为n的输入，插入排序运行8n平方步而归并排序运行64nlgn步，那么对于那些n值插入排序优于归并排序？3、n的最小值为多少时，运行时间为100n平方的一个算法算法在相同机器上快于运行时间为2的n次方的另有一个算法？ ———-归并排序之分治策略———-分解:解决:合并： ——-求解递归式的方法————代入法：猜测一个界，然后用数学归纳法证明这个界是正确的。 递归树法：将递归式转换为一颗树，其节点表示不同层次的递归调用产生的代价。然后采用边界和技术来求解递归式。主方法：解T(n)=aT(n/b)+f(n) ———-最大子数组问题—————- P24股票低价买入，高价出。即达到最大收益。1）暴力求解法简单的尝试每对可能买进和卖出日期组合，只要卖出日期在买入日期之前即可。N天中有N/2种日期组合。因为N/2=O(n^2),而处理每对日期所花费的时间至少也是常量，因此，这种方法的运行时间为C(n^2).2)问题转换：目的：寻找一段时间，使得从第一天到最后一天的股票价格净变值最大。因此，我们不再从每日价格的角度去看待数据而是考虑每日价格变化，第i天的价格变化定义为第i天和第i-1天的价格差，那么得到一个关于价格变化的数组A，那么问题就转化为寻找A的和最大的非空连续子数组。这样的连续子数组称为最大子数组。","categories":[{"name":"Geek","slug":"Geek","permalink":"https://casuor.top/categories/Geek/"}],"tags":[]},{"title":"Linux Notes","slug":"linux_Notes","date":"2019-01-21T16:00:00.000Z","updated":"2021-03-16T10:34:35.050Z","comments":true,"path":"2019/01/22/linux_Notes/","link":"","permalink":"https://casuor.top/2019/01/22/linux_Notes/","excerpt":"","text":"linux command基础命令查看目录12345ls #查看当前目录信息ls -l #以列表的方式显示ls -h #文件大小单位显示，默认是字节ls -a #显示隐藏文件或隐藏目录tree #以树状方式显示目录信息 查看当前目录路径1pwd #查看当前目录路径 清除终端1clear 切换目录命令12345cd 目录 #切换到指定目录cd ~ #切换到当前用户的主目录cd .. #切换到上一级目录cd . #切换到当前目录cd - #切换到上一次目录 绝对路径和相对路径相对路径 从当前目录算起绝对路径 从根目录算起 创建删除文件及目录123456789touch 文件名 #创建指定文件mkdir 文件名 #创建指定目录mkdir 文件名 -p #创建所依赖的文件夹rm 文件名或目录名(-r) #删除指定文件或目录rm -i #交互式提示rm -r #递归删除目录及内容rm -f #强制删除rm -d #删除空目录rmdir 目录名 #删除指定目录 复制移动文件及目录12345678cp #拷贝文件，目录(-r)cp -i #交互式提示cp -r #递归拷贝cp -v #显示拷贝后的路径描述cp -a #保留文件的原有权限mv #移动文件，目录，重命名mv -i #交互式提示mv -v #显示移动后的路径描述 终端命令的组成command [-options] [parameter] 每项信息的说明: command：命令名, 比如: ls、pwd [-options]：选项，可以有零个、一个或者多个选项，多个选项可以合并，比如使用的 -r 就是选项。 [parameter]：参数，可以有零个、一个 或者 多个参数， 比如: touch 文件名、mkdir 目录名、cd 目标目录(路径)，这些文件名和目录名都是参数。 []：代表可选 ## 查看命令帮助–help 使用说明: 命令 –help man 使用说明: man 命令 man命令的使用说明 空格 显示下一屏信息 回车 显示下一行 b 显示上一屏信息 f 显示下一屏信息 q 退出 高级命令重定向命令 命令 说明 &gt; 如果文件存在会覆盖原有文件内容，相当于文件操作中的‘w’模式 &gt;&gt; 如果文件存在会追加写入文件末尾，相当于文件操作中的‘a’ 模式 &gt; 表示每次只写入最新的数据，原有数据不保留。 &gt;&gt; 表示每次在原有数据的基础上进行追加，原有数据会保留。 查看文件内容命令 命令 说明 cat 查看小型文件 more 分屏查看大型文件 操作键说明: 操作键 说明 空格 显示下一屏信息 回车 显示下一行信息 b 显示上一屏信息 f 显示下一屏信息 q 退出 管道(|)命令的使用管道(|)：一个命令的输出可以通过管道做为另一个命令的输入，可以理解成是一个容器，存放在终端显示的内容。 说明: 管道(|)一般结合 more 命令使用，主要是分配查看终端显示内容。 链接命令1. 链接命令的介绍链接命令是创建链接文件，链接文件分为: 软链接 硬链接 命令 说明 ln -s 创建软链接 ln 创建硬链接 2. 软链接类似于Windows下的快捷方式，当一个源文件的目录层级比较深，我们想要方便使用它可以给源文件创建一个软链接。 注意点: 如果软链接和源文件不在同一个目录，源文件要使用绝对路径，不能使用相对路径。 删除源文件则软链接失效 可以给目录创建软链接 1ln -s /home/...x.txt /home/desktop/x-s.txt 3. 硬链接类似于源文件的一个别名，也就是说这两个名字指向的是同一个文件数据。 注意点: 创建硬链接使用相对路径和绝对路径都可以 删除源文件，硬链接还可以访问到数据。 创建硬链接，硬链接数会加1，删除源文件或者硬链接，硬链接数会减1。 创建软链接，硬链接数不会加1 不能给目录创建硬链接 硬链接数: 硬链接数就是文件数据被文件名使用的次数, 好比引用计数 文本搜索命令1. grep命令的使用 命令 说明 grep 文本搜索 命令选项 说明 -i 忽略大小写 -n 显示匹配行号 -v 显示不包含匹配文本的所有行 正则表达式 说明 ^ 以指定字符串开头 $ 以指定字符串结尾 . 匹配一个非换行符的字符 查找文件命令1. find命令及选项的使用 命令 说明 find 在指定目录下查找文件(包括目录) find命令选项: 选项 说明 -name 根据文件名(包括目录名)字查找 2. find命令结合通配符的使用通配符: 是一种特殊语句，主要有星号(*)和问号(?)，用来模糊搜索文件 通配符 说明 * 代表0个或多个任意字符 ? 代表任意一个字符 扩展: 通配符不仅能结合 find 命令使用，还可以结合其它命令使用, 比如: ls、mv、cp 等，这里需要注意只有 find 命令使用通配符需要加上引号。 压缩和解压缩命令1. 压缩格式的介绍Linux默认支持的压缩格式: .gz .bz2 .zip 说明: .gz和.bz2的压缩包需要使用tar命令来压缩和解压缩 .zip的压缩包需要使用zip命令来压缩，使用unzip命令来解压缩 压缩目的: 节省磁盘空间 2. tar命令及选项的使用 命令 说明 tar 压缩和解压缩命令 tar命令选项: 选项 说明 -c 创建打包文件 -v 显示打包或者解包的详细信息 -f 指定文件名称, 必须放到所有选项后面 -z 压缩或解压缩(.gz) -j 压缩或解压缩(.bz2) -x 解包 -C 解压缩到指定目录 1234#压缩tar -zcvf bin.tar.gz bin.txt#解压缩tar -zxvf bin.tar.gz -C ../desltop 3. zip和unzip命令及选项的使用 命令 说明 zip 压缩成.zip格式文件 unzip 解压缩.zip格式文件 unzip命令选项: 选项 说明 -d 解压缩到指定目录 说明: 压缩文件尽量使用.gz格式，因为占用空间较少 使用zip命令压缩的文件占用空间比较多, 当时比较通用，操作更加简单。 文件权限命令1. chmod命令的介绍 命令 说明 chmod 修改文件权限 chmod修改文件权限有两种方式: 字母法 数字法 2. chmod 字母法的使用角色说明: 角色 说明 u user, 表示该文件的所有者 g group, 表示用户组 o other, 表示其他用户 a all, 表示所有用户 权限设置说明: 操作符 说明 + 增加权限 - 撤销权限 = 设置权限 权限说明: 权限 说明 r 可读 w 可写 x 可执行 - 无任何权限 chmod命令同时设置多个角色的效果图: 3. chmod 数字法的使用数字法就是“rwx” 这些权限也可以用数字来代替 权限说明: 权限 说明 r 可读，权限值是4 w 可写，权限值是2 x 可执行，权限值是1 - 无任何权限，权限值是0 获取管理员权限的相关命令1. sudo命令的使用 命令 说明 sudo -s 切换到root用户，获取管理员权限 sudo 某个命令的执行需要获取管理员权限可以在执行命令前面加上sudo 2. whoami命令的使用 命令 说明 whoami 查看当前用户限 3. exit命令的使用 命令 说明 exit 退出登录用户 4. who命令的使用 命令 说明 who 查看所有的登录用户 5. passwd命令的使用 命令 说明 passwd 修改用户密码，不指定用户默认修改当前登录用户密码 6. which命令的使用 命令 说明 which 查看命令位置 7. 关机和重启命令的使用 命令 说明 shutdown –h now 立刻关机 reboot 重启 用户相关操作1. 创建用户 命令 说明 useradd 创建(添加)用户 useradd命令选项: 选项 说明 -m 自动创建用户主目录,主目录的名字就是用户名 -g 指定用户所属的用户组，默认不指定会自动创建一个同名的用户组 说明: useradd 命令的使用需要使用管理员权限，前面需要加上 sudo 创建用户如果不指定用户组，默认会自动创建一个同名的用户组 查看用户是否创建成功，可以查看/etc/passwd这个文件 查看用户组是否创建成功，可以查看/etc/group这个文件 passwd文件中的每项信息说明,以root:x:0:0:root:/root:/bin/bash为例: 第一个：用户名 第二个：密码占位符 第三个：uid, 用户id 第四个：gid, 用户所在组id 第五个：用户描述, 可选， 第六个：用户的主目录所在位置 第七个：用户所用 shell 的类型，一般由bash或者sh，默认不设置是sh类型 group文件中的每项信息说明, 以laowang:x:1001:为例: 第一个：用户组名 第二个：用户组密码占位符，一般Linux系统的用户组都没有密码的 第三个：组id id命令查看用户信息: 命令 说明 id 查看用户信息 每项信息说明: uid=1001(laowang) gid=1001(laowang) 组=1001(laowang) 第一个: uid 表示用户id 第二个: gid 表示用户组id 第三个: 组 表示用户所在的用户组 2. 设置密码给其它用户设置密码，需要使用: sudo passwd 用户名 3. 切换用户 命令 说明 su 切换用户 语法格式: su - 用户名 在laowang用户使用sudo -s效果图: 解决办法: 给laowang用户设置一个sudo附加组， 需要使用usermod修改用户信息 4. 修改用户信息 命令 说明 usermod 修改用户信息 usermod选项: 命令 说明 -G 设置一个附加组 -g 修改用户组 设置附加组sudo以后，在sudo -s切换到管理员用户效果图: 5. 扩展: 删除附加组 命令 说明 gpasswd 添加和删除附加组信息 gpasswd命令选项: 选项 说明 -a 用户名 给用户添加附加组 -d 用户名 给用户删除附加组 删除附加组效果图: 删除附加组再次使用 sudo -s 效果图: 5. 删除用户 命令 说明 userdel 删除用户 userdel命令选项: 选项 说明 -r 用户名 删除用户主目录，必须要设置，否则用户主目录不会删除 删除用户效果图: id查看用户信息效果图: 查看group文件信息效果图: 说明: 删除用户，默认同名的用户组也会被删除 用户组相关操作1. 创建用户组 命令 说明 groupadd 创建(添加)用户组 2. 创建用户并指定用户组 3. 修改用户组 4. 删除用户组 命令 说明 groupdel 删除用户组 说明: 如果用户组下面有用户先删除用户在删除用户组 远程登录、远程拷贝命令的介绍1. 远程登录、远程拷贝命令的介绍 命令 说明 ssh 远程登录 scp 远程拷贝 2. ssh命令的使用ssh是专门为远程登录提供的一个安全性协议，常用于远程登录，想要使用ssh服务，需要安装相应的服务端和客户端软件，当软件安装成功以后就可以使用ssh命令了，以后可以通过远程登录之间操作远程的服务器。 软件安装步骤: 假如Ubuntu作为服务端,需要安装ssh服务端软件. 执行命令: sudo apt-get install openssh-server 客户端电脑如果是 macOS 系统则不需要安装 ssh 客户端软件，默认已经安装过了，直接可以使用 ssh 命令 客户端电脑如果是Windows系统则需要安装OpenSSH for Windows这个软件 ssh命令格式: ssh 用户名@ip地址 ssh命令效果图: 说明: 在一台电脑上可以安装安装ssh客户端和ssh服务端软件 在Ubuntu安装ssh客户端命令: sudo apt-get install openssh-client 3. scp命令的使用scp是基于ssh进行远程文件拷贝的命令，也就是说需要保证服务端和客户端电脑安装了相应的ssh软件，以后可以把我们写代码远程拷贝到服务器。 scp命令格式: 远程拷贝文件 scp 本地文件 远程服务器用户名@远程服务器ip地址:指定拷贝到远程服务器的路径 scp 远程服务器用户名@远程服务器ip地址:远程服务器文件 指定拷贝到本地电脑的路径 远程拷贝目标 scp -r 本地目录 远程服务器用户名@远程服务器ip地址:指定拷贝到远程服务器的路径 scp -r 远程服务器用户名@远程服务器ip地址:远程服务器目录 指定拷贝到本地电脑的路径 -r 表示递归拷贝整个目录 本地文件远程拷贝到服务器效果图: 服务器文件远程拷贝到本地效果图: 本地目录远程拷贝到服务器效果图: 服务器目录远程拷贝到本地效果图: 4. FileZilla软件的使用FileZilla 是一个免费开源的FTP软件, 使用可视化方式进行上传和下载文件。以后可以通过 FileZilla 来代替 scp 命令 编辑器 vimvim 是一款功能强大的文本编辑器，也是早年 Vi 编辑器的加强版，它的最大特色就是使用命令进行编辑，完全脱离了鼠标的操作。 1. vim 的介绍vim 是一款功能强大的文本编辑器，也是早年 Vi 编辑器的加强版，它的最大特色就是使用命令进行编辑，完全脱离了鼠标的操作。 2. vim 的工作模式 命令模式 编辑模式 末行模式 说明: vim 打开文件进入的是命令模式 工作模式效果图: 注意点: 编辑模式和末行模式之间不能直接进行切换，都需要通过命令模式来完成。 3. vim 的末行模式命令 :w 保存 :wq 保存退出 :x 保存退出 :q! 强制退出 4. vim 的常用命令 命令 说明 yy 复制光标所在行 p 粘贴 dd 删除/剪切当前行 V 按行选中 u 撤销 ctr+r 反撤销 &gt;&gt; 往右缩进 &lt;&lt; 往左缩进 :/搜索的内容 搜索指定内容 :%s/要替换的内容/替换后的内容/g 全局替换 :开始行数,结束行数s/要替换的内容/替换后的内容 局部替换 . 重复上一次命令操作 G 回到最后一行 gg 回到第一行 数字+G 回到指定行 shift+6 回到当前行的行首 shift+4 回到当前行的行末 ctr+f 下一屏 ctr+b 上一屏 软件安装1. 软件安装的介绍Ubuntu软件安装有两种方式: 离线安装(deb文件格式安装） 在线安装(apt-get方式安装) 2. deb文件格式安装是 Ubuntu 的安装包格式，可以使用 dpkg 命令进行软件的安装和卸载。 命令 说明 dpkg 安装和卸载deb安装包 dpkg命令选项: 选项 说明 -i 离线安装deb安装包 3. apt-get方式安装是在线安装deb软件包的命令，主要用于在线从互联网的软件仓库中搜索、安装、升级、卸载软件。 在线安装软件命令格式: sudo apt–get install 安装包 , 表示在线安装deb安装包 4. 更改镜像源因为使用 apt-get 命令默认是从国外的服务器下载安装软件的，会导致下载安装速度很慢，所以需要更改成国内的镜像源服务器。 镜像源说明: 镜像源就是下载软件来源的服务器。 镜像源效果图: 更改镜像源的方式: 可视化方式更改镜像源 手动方式更改镜像源 可视化方式更改镜像源: 手动方式更改镜像源: 说明: 手动修改镜像源，配置完成以后需要执行 sudo apt-get update 这个命令，更新镜像源保证可以下载最新的软件。 使用apt-get方式安装软件一定要联网 5. 小结 Ubuntu 操作系统安装软件有两种方式: sudo dpkg -i 安装包 命令 sudo apt-get install 安装包 命令卸载 使用 apt-get 命令也就是在线安装需要更改镜像源，提高下载和安装速度。 软件卸载1. 软件卸载的介绍Ubuntu软件卸载有两种方式: 离线安装包的卸载(deb 文件格式卸载） 在线安装包的卸载(apt-get 方式卸载) 2. deb 文件格式卸载命令格式: sudo dpkg –r 安装包名 -r 选项表示安装的卸载 dpkg 卸载效果图: 3. apt-get 方式卸载命令格式: sudo apt-get remove 安装包名 apt-get 卸载效果图: 4. 小结 Ubuntu 操作系统卸载软件有两种方式: dpkg -r 安装包 命令 apt-get remove 安装包 命令卸载 j;y7jhg6=h","categories":[{"name":"Geek","slug":"Geek","permalink":"https://casuor.top/categories/Geek/"}],"tags":[]},{"title":"python Notes","slug":"geek_pythonNotes","date":"2019-01-10T16:00:00.000Z","updated":"2021-03-16T10:28:51.208Z","comments":true,"path":"2019/01/11/geek_pythonNotes/","link":"","permalink":"https://casuor.top/2019/01/11/geek_pythonNotes/","excerpt":"","text":"注释分为两类：==单行注释== 和 ==多行注释==。 单行注释 只能注释一行内容，语法如下： 1# 注释内容 多行注释 可以注释多行内容，一般用在注释一段代码的情况， 语法如下： 1234567891011\"\"\" 第一行注释 第二行注释 第三行注释\"\"\"''' 注释1 注释2 注释3''' 标识符 由数字、字母、下划线组成 不能数字开头 不能使用内置关键字 严格区分大小写 123456789101112131415161718192021222324FalseNoneTrue and as assertbreakclass continuedef del elifelse except finally for fromglobalif import in is lambda nonlocalnot orpassraisereturntry while withyield 数据类型 1234567891011121314151617181920212223a = 1print(type(a)) # &lt;class 'int'&gt; -- 整型b = 1.1print(type(b)) # &lt;class 'float'&gt; -- 浮点型c = Trueprint(type(c)) # &lt;class 'bool'&gt; -- 布尔型d = '12345'print(type(d)) # &lt;class 'str'&gt; -- 字符串e = [10, 20, 30]print(type(e)) # &lt;class 'list'&gt; -- 列表f = (10, 20, 30)print(type(f)) # &lt;class 'tuple'&gt; -- 元组h = &#123;10, 20, 30&#125;print(type(h)) # &lt;class 'set'&gt; -- 集合g = &#123;'name': 'TOM', 'age': 20&#125;print(type(g)) # &lt;class 'dict'&gt; -- 字典 格式化输出格式化符号 格式符号 转换 %s 字符串 %d 有符号的十进制整数 %f 浮点数 %c 字符 %u 无符号十进制整数 %o 八进制整数 %x 十六进制整数（小写ox） %X 十六进制整数（大写OX） %e 科学计数法（小写’e’） %E 科学计数法（大写’E’） %g %f和%e的简写 %G %f和%E的简写 技巧 %06d，表示输出的整数显示位数，不足以0补全，超出当前位数则原样输出 %.2f，表示小数点后显示的小数位数。 格式化字符串除了%s，还可以写为f&#39;{表达式}&#39; 12345678910111213141516171819202122age = 18name = 'TOM'weight = 75.5student_id = 1# 我的名字是TOMprint('我的名字是%s' % name)# 我的学号是0001print('我的学号是%4d' % student_id)# 我的体重是75.50公斤print('我的体重是%.2f公斤' % weight)# 我的名字是TOM，今年18岁了print('我的名字是%s，今年%d岁了' % (name, age))# 我的名字是TOM，明年19岁了print('我的名字是%s，明年%d岁了' % (name, age + 1))# 我的名字是TOM，明年19岁了print(f'我的名字是&#123;name&#125;, 明年&#123;age + 1&#125;岁了') f-格式化字符串是Python3.6中新增的格式化方法，该方法更简单易读。 转义字符 \\n：换行。 \\t：制表符，一个tab键（4个空格）的距离。 结束符1print('输出的内容', end=\"\\n\") 在Python中，print()， 默认自带end=&quot;\\n&quot;这个换行结束符，所以导致每两个print直接会换行展示，用户可以按需求更改结束符。 输入1input(\"提示信息\") 当程序执行到input，等待用户输入，输入完成之后才继续向下执行。 在Python中，input接收用户输入后，一般存储到变量，方便使用。 在Python中，input会把接收到的任意用户输入的数据都当做字符串处理。 123456password = input(\"请输入密码\")print(f'你输入的密码是&#123;password&#125;')print(type(password))# 请输入密码123456# 你输入的密码是123456# &lt;class 'str'&gt; 数据类型转换 函数 说明 int(x [,base ]) 将x转换为一个整数 float(x ) 将x转换为一个浮点数 complex(real [,imag ]) 创建一个复数，real为实部，imag为虚部 str(x ) 将对象 x 转换为字符串 repr(x ) 将对象 x 转换为表达式字符串 eval(str ) 用来计算在字符串中的有效Python表达式,并返回一个对象 tuple(s ) 将序列 s 转换为一个元组 list(s ) 将序列 s 转换为一个列表 chr(x ) 将一个整数转换为一个Unicode字符 ord(x ) 将一个字符转换为它的ASCII整数值 hex(x ) 将一个整数转换为一个十六进制字符串 oct(x ) 将一个整数转换为一个八进制字符串 bin(x ) 将一个整数转换为一个二进制字符串 运算符算术运算符 运算符 描述 实例 + 加 1 + 1 输出结果为 2 - 减 1-1 输出结果为 0 * 乘 2 * 2 输出结果为 4 / 除 10 / 2 输出结果为 5 // 整除 9 // 4 输出结果为2 % 取余 9 % 4 输出结果为 1 ** 指数 2 ** 4 输出结果为 16，即 2 * 2 * 2 * 2 () 小括号 小括号用来提高运算优先级，即 (1 + 2) * 3 输出结果为 9 注意： 混合运算优先级顺序：()高于 ** 高于 * / // % 高于 + - 赋值运算符 运算符 描述 实例 = 赋值 将=右侧的结果赋值给等号左侧的变量 单个变量赋值 12num = 1print(num) 多个变量赋值 1234num1, float1, str1 = 10, 0.5, 'hello world'print(num1)print(float1)print(str1) 复合赋值运算符 运算符 描述 实例 += 加法赋值运算符 c += a 等价于 c = c + a -= 减法赋值运算符 c -= a 等价于 c = c- a *= 乘法赋值运算符 c *= a 等价于 c = c * a /= 除法赋值运算符 c /= a 等价于 c = c / a //= 整除赋值运算符 c //= a 等价于 c = c // a %= 取余赋值运算符 c %= a 等价于 c = c % a **= 幂赋值运算符 c ** = a 等价于 c = c ** a 比较运算符比较运算符也叫关系运算符， 通常用来判断。 运算符 描述 实例 == 判断相等。如果两个操作数的结果相等，则条件结果为真(True)，否则条件结果为假(False) 如a=3,b=3，则（a == b) 为 True != 不等于 。如果两个操作数的结果不相等，则条件为真(True)，否则条件结果为假(False) 如a=3,b=3，则（a == b) 为 True如a=1,b=3，则(a != b) 为 True &gt; 运算符左侧操作数结果是否大于右侧操作数结果，如果大于，则条件为真，否则为假 如a=7,b=3，则(a &gt; b) 为 True &lt; 运算符左侧操作数结果是否小于右侧操作数结果，如果小于，则条件为真，否则为假 如a=7,b=3，则(a &lt; b) 为 False &gt; = 运算符左侧操作数结果是否大于等于右侧操作数结果，如果大于，则条件为真，否则为假 如a=7,b=3，则(a &lt; b) 为 False如a=3,b=3，则(a &gt;= b) 为 True &lt;= 运算符左侧操作数结果是否小于等于右侧操作数结果，如果小于，则条件为真，否则为假 如a=3,b=3，则(a &lt;= b) 为 True 逻辑运算符 运算符 逻辑表达式 描述 实例 and x and y 布尔”与”：如果 x 为 False，x and y 返回 False，否则它返回 y 的值。 True and False， 返回 False。 or x or y 布尔”或”：如果 x 是 True，它返回 True，否则它返回 y 的值。 False or True， 返回 True。 not not x 布尔”非”：如果 x 为 True，返回 False 。如果 x 为 False，它返回 True。 not True 返回 False, not False 返回 True 条件语句if语句语法 1234if 条件: 条件成立执行的代码1 条件成立执行的代码2 ...... if…else… 12345678if 条件: 条件成立执行的代码1 条件成立执行的代码2 ......else: 条件不成立执行的代码1 条件不成立执行的代码2 ...... 多重判断 1234567891011if 条件1: 条件1成立执行的代码1 条件1成立执行的代码2 ......elif 条件2：条件2成立执行的代码1条件2成立执行的代码2............else:以上条件都不成立执行执行的代码 if嵌套 1234567if 条件1：条件1成立执行的代码条件1成立执行的代码if 条件2：条件2成立执行的代码条件2成立执行的代码 三目运算符 1值1 if 条件 else 值2 循环while 1234while 条件: 条件成立重复执行的代码1 条件成立重复执行的代码2 ...... 123456789# 计数器控制增量为2i = 0result = 0while i &lt;= 100: result += i i += 2# 输出2550print(result) break和continue break和continue是循环中满足一定条件退出循环的两种不同方式。 1234567i = 1while i &lt;= 5: if i == 4: print(f'吃饱了不吃了') break print(f'吃了第&#123;i&#125;个苹果') i += 1 123456789i = 1while i &lt;= 5: if i == 3: print(f'大虫子，第&#123;i&#125;个不吃了') # 在continue之前一定要修改计数器，否则会陷入死循环 i += 1 continue print(f'吃了第&#123;i&#125;个苹果') i += 1 while循环嵌套 123456while 条件1: 条件1成立执行的代码 ...... while 条件2: 条件2成立执行的代码 ...... 12345678910# 重复打印9行表达式j = 1while j &lt;= 9: # 打印一行里面的表达式 a * b = a*b i = 1 while i &lt;= j: print(f'&#123;i&#125;*&#123;j&#125;=&#123;j * i&#125;', end='\\t') i += 1 print() j += 1 for 1234for 临时变量 in 序列: 重复执行的代码1 重复执行的代码2 ...... 123456str1 = 'itheima'for i in str1: if i == 'e': print('遇到e不打印') break print(i) 123456str1 = 'itheima'for i in str1: if i == 'e': print('遇到e不打印') continue print(i) while…else 1234while 条件: 条件成立重复执行的代码else: 循环正常结束之后要执行的代码 for…else 12345for 临时变量 in 序列: 重复执行的代码 ...else: 循环正常结束之后要执行的代码 字符串表示 一对引号字符串 12name1 = 'Tom'name2 = \"Rose\" 三引号字符串 1234567name3 = ''' Tom '''name4 = \"\"\" Rose \"\"\"a = ''' i am Tom, nice to meet you! '''b = \"\"\" i am Rose, nice to meet you! \"\"\" 注意：三引号形式的字符串支持换行。 思考：如果创建一个字符串I&#39;m Tom? 12c = \"I'm Tom\"d = 'I\\'m Tom' 下标12345name = \"abcdef\"print(name[1])print(name[0])print(name[2]) 切片切片是指对操作的对象截取其中一部分的操作。字符串、列表、元组都支持切片操作。 语法 1序列[开始位置下标:结束位置下标:步长] 注意 不包含结束位置下标对应的数据， 正负整数均可； 步长是选取间隔，正负整数均可，默认步长为1。 1234567891011name = \"abcdefg\"print(name[2:5:1]) # cdeprint(name[2:5]) # cdeprint(name[:5]) # abcdeprint(name[1:]) # bcdefgprint(name[:]) # abcdefgprint(name[::2]) # acegprint(name[:-1]) # abcdef, 负1表示倒数第一个数据print(name[-4:-1]) # defprint(name[::-1]) # gfedcba 常用操作方法查找所谓字符串查找方法即是查找子串在字符串中的位置或出现的次数。 find()：检测某个子串是否包含在这个字符串中，如果在返回这个子串开始的位置下标，否则则返回-1。 语法 1字符串序列.find(子串, 开始位置下标, 结束位置下标) 注意：开始和结束位置下标可以省略，表示在整个字符串序列中查找。 快速体验 12345mystr = \"hello world and itcast and itheima and Python\"print(mystr.find('and')) # 12print(mystr.find('and', 15, 30)) # 23print(mystr.find('ands')) # -1 index()：检测某个子串是否包含在这个字符串中，如果在返回这个子串开始的位置下标，否则则报异常。 语法 1字符串序列.index(子串, 开始位置下标, 结束位置下标) 注意：开始和结束位置下标可以省略，表示在整个字符串序列中查找。 快速体验 12345mystr = \"hello world and itcast and itheima and Python\"print(mystr.index('and')) # 12print(mystr.index('and', 15, 30)) # 23print(mystr.index('ands')) # 报错 rfind()： 和find()功能相同，但查找方向为==右侧==开始。 rindex()：和index()功能相同，但查找方向为==右侧==开始。 count()：返回某个子串在字符串中出现的次数 语法 1字符串序列.count(子串, 开始位置下标, 结束位置下标) 注意：开始和结束位置下标可以省略，表示在整个字符串序列中查找。 快速体验 12345mystr = \"hello world and itcast and itheima and Python\"print(mystr.count('and')) # 3print(mystr.count('ands')) # 0print(mystr.count('and', 0, 20)) # 1 修改所谓修改字符串，指的就是通过函数的形式修改字符串中的数据。 replace()：替换 语法 1字符串序列.replace(旧子串, 新子串, 替换次数) 注意：替换次数如果查出子串出现次数，则替换次数为该子串出现次数。 快速体验 12345678mystr = \"hello world and itcast and itheima and Python\"# 结果：hello world he itcast he itheima he Pythonprint(mystr.replace('and', 'he'))# 结果：hello world he itcast he itheima he Pythonprint(mystr.replace('and', 'he', 10))# 结果：hello world and itcast and itheima and Pythonprint(mystr) 注意：数据按照是否能直接修改分为==可变类型==和==不可变类型==两种。字符串类型的数据修改的时候不能改变原有字符串，属于不能直接修改数据的类型即是不可变类型。 split()：按照指定字符分割字符串。 语法 1字符串序列.split(分割字符, num) 注意：num表示的是分割字符出现的次数，即将来返回数据个数为num+1个。 快速体验 12345678910mystr = \"hello world and itcast and itheima and Python\"# 结果：['hello world ', ' itcast ', ' itheima ', ' Python']print(mystr.split('and'))# 结果：['hello world ', ' itcast ', ' itheima and Python']print(mystr.split('and', 2))# 结果：['hello', 'world', 'and', 'itcast', 'and', 'itheima', 'and', 'Python']print(mystr.split(' '))# 结果：['hello', 'world', 'and itcast and itheima and Python']print(mystr.split(' ', 2)) 注意：如果分割字符是原有字符串中的子串，分割后则丢失该子串。 join()：用一个字符或子串合并字符串，即是将多个字符串合并为一个新的字符串。 语法 1字符或子串.join(多字符串组成的序列) 快速体验 123456list1 = ['chuan', 'zhi', 'bo', 'ke']t1 = ('aa', 'b', 'cc', 'ddd')# 结果：chuan_zhi_bo_keprint('_'.join(list1))# 结果：aa...b...cc...dddprint('...'.join(t1)) capitalize()：将字符串第一个字符转换成大写。 1234mystr = \"hello world and itcast and itheima and Python\"# 结果：Hello world and itcast and itheima and pythonprint(mystr.capitalize()) 注意：capitalize()函数转换后，只字符串第一个字符大写，其他的字符全都小写。 title()：将字符串每个单词首字母转换成大写。 1234mystr = \"hello world and itcast and itheima and Python\"# 结果：Hello World And Itcast And Itheima And Pythonprint(mystr.title()) lower()：将字符串中大写转小写。 1234mystr = \"hello world and itcast and itheima and Python\"# 结果：hello world and itcast and itheima and pythonprint(mystr.lower()) upper()：将字符串中小写转大写。 1234mystr = \"hello world and itcast and itheima and Python\"# 结果：HELLO WORLD AND ITCAST AND ITHEIMA AND PYTHONprint(mystr.upper()) lstrip()：删除字符串左侧空白字符。 rstrip()：删除字符串右侧空白字符。 strip()：删除字符串两侧空白字符。 ljust()：返回一个原字符串左对齐,并使用指定字符(默认空格)填充至对应长度 的新字符串。 语法 1字符串序列.ljust(长度, 填充字符) rjust()：返回一个原字符串右对齐,并使用指定字符(默认空格)填充至对应长度 的新字符串，语法和ljust()相同。 center()：返回一个原字符串居中对齐,并使用指定字符(默认空格)填充至对应长度 的新字符串，语法和ljust()相同。 判断所谓判断即是判断真假，返回的结果是布尔型数据类型：True 或 False。 startswith()：检查字符串是否是以指定子串开头，是则返回 True，否则返回 False。如果设置开始和结束位置下标，则在指定范围内检查。 语法 1字符串序列.startswith(子串, 开始位置下标, 结束位置下标) 快速体验 1234567mystr = \"hello world and itcast and itheima and Python \"# 结果：Trueprint(mystr.startswith('hello'))# 结果Falseprint(mystr.startswith('hello', 5, 20)) endswith()：：检查字符串是否是以指定子串结尾，是则返回 True，否则返回 False。如果设置开始和结束位置下标，则在指定范围内检查。 语法 1字符串序列.endswith(子串, 开始位置下标, 结束位置下标) 快速体验 12345678910mystr = \"hello world and itcast and itheima and Python\"# 结果：Trueprint(mystr.endswith('Python'))# 结果：Falseprint(mystr.endswith('python'))# 结果：Falseprint(mystr.endswith('Python', 2, 20)) isalpha()：如果字符串至少有一个字符并且所有字符都是字母则返回 True, 否则返回 False。 12345678mystr1 = 'hello'mystr2 = 'hello12345'# 结果：Trueprint(mystr1.isalpha())# 结果：Falseprint(mystr2.isalpha()) isdigit()：如果字符串只包含数字则返回 True 否则返回 False。 12345678mystr1 = 'aaa12345'mystr2 = '12345'# 结果： Falseprint(mystr1.isdigit())# 结果：Falseprint(mystr2.isdigit()) isalnum()：如果字符串至少有一个字符并且所有字符都是字母或数字则返 回 True,否则返回 False。 12345678mystr1 = 'aaa12345'mystr2 = '12345-'# 结果：Trueprint(mystr1.isalnum())# 结果：Falseprint(mystr2.isalnum()) isspace()：如果字符串中只包含空白，则返回 True，否则返回 False。 12345678mystr1 = '1 2 3 4 5'mystr2 = ' '# 结果：Falseprint(mystr1.isspace())# 结果：Trueprint(mystr2.isspace()) 列表应用场景列表可以一次性存储多个数据，且可以为不同数据类型。 列表的格式1[数据1, 数据2, 数据3, 数据4......] 列表的常用操作查找 下标 12345name_list = ['Tom', 'Lily', 'Rose']print(name_list[0]) # Tomprint(name_list[1]) # Lilyprint(name_list[2]) # Rose 函数 index()：返回指定数据所在位置的下标 。 语法 1列表序列.index(数据, 开始位置下标, 结束位置下标) 快速体验 123name_list = ['Tom', 'Lily', 'Rose']print(name_list.index('Lily', 0, 2)) # 1 注意：如果查找的数据不存在则报错。 count()：统计指定数据在当前列表中出现的次数。 123name_list = ['Tom', 'Lily', 'Rose']print(name_list.count('Lily')) # 1 len()：访问列表长度，即列表中数据的个数。 123name_list = ['Tom', 'Lily', 'Rose']print(len(name_list)) # 3 判断是否存在 in：判断指定数据在某个列表序列，如果在返回True，否则返回False 1234567name_list = ['Tom', 'Lily', 'Rose']# 结果：Trueprint('Lily' in name_list)# 结果：Falseprint('Lilys' in name_list) not in：判断指定数据不在某个列表序列，如果不在返回True，否则返回False 1234567name_list = ['Tom', 'Lily', 'Rose']# 结果：Falseprint('Lily' not in name_list)# 结果：Trueprint('Lilys' not in name_list) 体验案例 需求：查找用户输入的名字是否已经存在。 12345678name_list = ['Tom', 'Lily', 'Rose']name = input('请输入您要搜索的名字：')if name in name_list: print(f'您输入的名字是&#123;name&#125;, 名字已经存在')else: print(f'您输入的名字是&#123;name&#125;, 名字不存在') 增加增加指定数据到列表中 append()：列表结尾追加数据。 语法 1列表序列.append(数据) 体验 123456name_list = ['Tom', 'Lily', 'Rose']name_list.append('xiaoming')# 结果：['Tom', 'Lily', 'Rose', 'xiaoming']print(name_list) 列表追加数据的时候，直接在原列表里面追加了指定数据，即修改了原列表，故列表为可变类型数据。 注意点 如果append()追加的数据是一个序列，则追加整个序列到列表 123456name_list = ['Tom', 'Lily', 'Rose']name_list.append(['xiaoming', 'xiaohong'])# 结果：['Tom', 'Lily', 'Rose', ['xiaoming', 'xiaohong']]print(name_list) extend()：列表结尾追加数据，如果数据是一个序列，则将这个序列的数据逐一添加到列表。 语法 1列表序列.extend(数据) 快速体验 2.1 单个数据 123456name_list = ['Tom', 'Lily', 'Rose']name_list.extend('xiaoming')# 结果：['Tom', 'Lily', 'Rose', 'x', 'i', 'a', 'o', 'm', 'i', 'n', 'g']print(name_list) 2.2 序列数据 123456name_list = ['Tom', 'Lily', 'Rose']name_list.extend(['xiaoming', 'xiaohong'])# 结果：['Tom', 'Lily', 'Rose', 'xiaoming', 'xiaohong']print(name_list) insert()：指定位置新增数据。 语法 1列表序列.insert(位置下标, 数据) 快速体验 123456name_list = ['Tom', 'Lily', 'Rose']name_list.insert(1, 'xiaoming')# 结果：['Tom', 'xiaoming', 'Lily', 'Rose']print(name_list) 删除 del 语法 1del 目标 快速体验 2.1 删除列表 12345name_list = ['Tom', 'Lily', 'Rose']# 结果：报错提示：name 'name_list' is not defineddel name_listprint(name_list) 2.2 删除指定数据 123456name_list = ['Tom', 'Lily', 'Rose']del name_list[0]# 结果：['Lily', 'Rose']print(name_list) pop()：删除指定下标的数据(默认为最后一个)，并返回该数据。 语法 1列表序列.pop(下标) 快速体验 123456789name_list = ['Tom', 'Lily', 'Rose']del_name = name_list.pop(1)# 结果：Lilyprint(del_name)# 结果：['Tom', 'Rose']print(name_list) remove()：移除列表中某个数据的第一个匹配项。 语法 1列表序列.remove(数据) 快速体验 123456name_list = ['Tom', 'Lily', 'Rose']name_list.remove('Rose')# 结果：['Tom', 'Lily']print(name_list) clear()：清空列表 1234name_list = ['Tom', 'Lily', 'Rose']name_list.clear()print(name_list) # 结果： [] 修改 修改指定下标数据 123456name_list = ['Tom', 'Lily', 'Rose']name_list[0] = 'aaa'# 结果：['aaa', 'Lily', 'Rose']print(name_list) 逆置：reverse() 123456num_list = [1, 5, 2, 3, 6, 8]num_list.reverse()# 结果：[8, 6, 3, 2, 5, 1]print(num_list) 排序：sort() 语法 1列表序列.sort( key=None, reverse=False) 注意：reverse表示排序规则，reverse = True 降序， reverse = False 升序（默认） 快速体验 123456num_list = [1, 5, 2, 3, 6, 8]num_list.sort()# 结果：[1, 2, 3, 5, 6, 8]print(num_list) 复制函数：copy() 123456name_list = ['Tom', 'Lily', 'Rose']name_li2 = name_list.copy()# 结果：['Tom', 'Lily', 'Rose']print(name_li2) 列表的循环遍历需求：依次打印列表中的各个数据。 while 123456name_list = ['Tom', 'Lily', 'Rose']i = 0while i &lt; len(name_list): print(name_list[i]) i += 1 for 1234name_list = ['Tom', 'Lily', 'Rose']for i in name_list: print(i) 列表嵌套所谓列表嵌套指的就是一个列表里面包含了其他的子列表。 应用场景：要存储班级一、二、三三个班级学生姓名，且每个班级的学生姓名在一个列表。 1name_list = [['小明', '小红', '小绿'], ['Tom', 'Lily', 'Rose'], ['张三', '李四', '王五']] 思考： 如何查找到数据”李四”？ 12345# 第一步：按下标查找到李四所在的列表print(name_list[2])# 第二步：从李四所在的列表里面，再按下标找到数据李四print(name_list[2][1]) 元组应用场景存储多个数据但不允许修改 定义特点： 使用小括号，且使用逗号分隔各个数据，数据可以是不同类型的。 12345# 多个数据元组t1 = (10, 20, 30)# 单个数据元组t2 = (10,) 注意：如果定义的元组只有一个数据，那么这个数据后面也好添加逗号，否则数据类型为唯一的这个数据的数据类型 12345678t2 = (10,)print(type(t2)) # tuplet3 = (20)print(type(t3)) # intt4 = ('hello')print(type(t4)) # str 元组的常见操作元组数据不支持修改，只支持查找，具体如下： 按下标查找数据 12tuple1 = ('aa', 'bb', 'cc', 'bb')print(tuple1[0]) # aa index()：查找某个数据，如果数据存在返回对应的下标，否则报错，语法和列表、字符串的index方法相同。 12tuple1 = ('aa', 'bb', 'cc', 'bb')print(tuple1.index('aa')) # 0 count()：统计某个数据在当前元组出现的次数。 12tuple1 = ('aa', 'bb', 'cc', 'bb')print(tuple1.count('bb')) # 2 len()：统计元组中数据的个数。 12tuple1 = ('aa', 'bb', 'cc', 'bb')print(len(tuple1)) # 4 注意：元组内的直接数据如果修改则立即报错 12tuple1 = ('aa', 'bb', 'cc', 'bb')tuple1[0] = 'aaa' 但是如果元组里面有列表，修改列表里面的数据则是支持的，故自觉很重要。 123456tuple2 = (10, 20, ['aa', 'bb', 'cc'], 50, 30)print(tuple2[2]) # 访问到列表# 结果：(10, 20, ['aaaaa', 'bb', 'cc'], 50, 30)tuple2[2][0] = 'aaaaa'print(tuple2) 字典字典的应用场景 数据顺序发生变化，每个数据的下标也会随之变化，如何保证数据顺序变化前后能使用同一的标准查找数据呢？ 答：字典，字典里面的数据是以键值对形式出现，字典数据和数据顺序没有关系，即字典不支持下标，后期无论数据如何变化，只需要按照对应的键的名字查找数据即可。 创建字典字典的特点： 符号为大括号 数据为键值对形式出现 各个键值对之间用逗号隔开 注意：一般称冒号前面的为键(key)，简称k；冒号后面的为值(value)，简称v。 字典的操作增加写法：字典序列[key] = 值 注意：如果key存在则修改这个key对应的值；如果key不存在则新增此键值对。 12345678910dict1 = &#123;'name': 'Tom', 'age': 20, 'gender': '男'&#125;dict1['name'] = 'Rose'# 结果：&#123;'name': 'Rose', 'age': 20, 'gender': '男'&#125;print(dict1)dict1['id'] = 110# &#123;'name': 'Rose', 'age': 20, 'gender': '男', 'id': 110&#125;print(dict1) 注意：字典为可变类型。 删除 del() / del：删除字典或删除字典中指定键值对。 12345dict1 = &#123;'name': 'Tom', 'age': 20, 'gender': '男'&#125;del dict1['gender']# 结果：&#123;'name': 'Tom', 'age': 20&#125;print(dict1) clear()：清空字典 1234dict1 = &#123;'name': 'Tom', 'age': 20, 'gender': '男'&#125;dict1.clear()print(dict1) # &#123;&#125; 修改写法：字典序列[key] = 值 注意：如果key存在则修改这个key对应的值；如果key不存在则新增此键值对。 查找 key值查找 123dict1 = &#123;'name': 'Tom', 'age': 20, 'gender': '男'&#125;print(dict1['name']) # Tomprint(dict1['id']) # 报错 如果当前查找的key存在，则返回对应的值；否则则报错。 get() 语法 1字典序列.get(key, 默认值) 注意：如果当前查找的key不存在则返回第二个参数(默认值)，如果省略第二个参数，则返回None。 快速体验 1234dict1 = &#123;'name': 'Tom', 'age': 20, 'gender': '男'&#125;print(dict1.get('name')) # Tomprint(dict1.get('id', 110)) # 110print(dict1.get('id')) # None keys() 12dict1 = &#123;'name': 'Tom', 'age': 20, 'gender': '男'&#125;print(dict1.keys()) # dict_keys(['name', 'age', 'gender']) values() 12dict1 = &#123;'name': 'Tom', 'age': 20, 'gender': '男'&#125;print(dict1.values()) # dict_values(['Tom', 20, '男']) items() 12dict1 = &#123;'name': 'Tom', 'age': 20, 'gender': '男'&#125;print(dict1.items()) # dict_items([('name', 'Tom'), ('age', 20), ('gender', '男')]) 字典的循环遍历 遍历key 123dict1 = &#123;'name': 'Tom', 'age': 20, 'gender': '男'&#125;for key in dict1.keys(): print(key) 遍历value 123dict1 = &#123;'name': 'Tom', 'age': 20, 'gender': '男'&#125;for value in dict1.values(): print(value) 遍历字典的元素 123dict1 = &#123;'name': 'Tom', 'age': 20, 'gender': '男'&#125;for item in dict1.items(): print(item) 遍历字典的键值对 123dict1 = &#123;'name': 'Tom', 'age': 20, 'gender': '男'&#125;for key, value in dict1.items(): print(f'&#123;key&#125; = &#123;value&#125;') 集合创建集合创建集合使用{}或set()， 但是如果要创建空集合只能使用set()，因为{}用来创建空字典。 1234567891011121314s1 = &#123;10, 20, 30, 40, 50&#125;print(s1)s2 = &#123;10, 30, 20, 10, 30, 40, 30, 50&#125;print(s2)s3 = set('abcdefg')print(s3)s4 = set()print(type(s4)) # sets5 = &#123;&#125;print(type(s5)) # dict 特点： 集合可以去掉重复数据； 集合数据是无序的，故不支持下标 集合的操作增加数据 add() 1234s1 = &#123;10, 20&#125;s1.add(100)s1.add(10)print(s1) # &#123;100, 10, 20&#125; 因为集合有去重功能，所以，当向集合内追加的数据是当前集合已有数据的话，则不进行任何操作。 update(), 追加的数据是序列。 12345s1 = &#123;10, 20&#125;# s1.update(100) # 报错s1.update([100, 200])s1.update('abc')print(s1) 删除数据 remove()，删除集合中的指定数据，如果数据不存在则报错。 1234567s1 = &#123;10, 20&#125;s1.remove(10)print(s1)s1.remove(10) # 报错print(s1) discard()，删除集合中的指定数据，如果数据不存在也不会报错。 1234567s1 = &#123;10, 20&#125;s1.discard(10)print(s1)s1.discard(10)print(s1) pop()，随机删除集合中的某个数据，并返回这个数据。 12345s1 = &#123;10, 20, 30, 40, 50&#125;del_num = s1.pop()print(del_num)print(s1) 查找数据 in：判断数据在集合序列 not in：判断数据不在集合序列 1234s1 = &#123;10, 20, 30, 40, 50&#125;print(10 in s1)print(10 not in s1) 公共操作运算符 运算符 描述 支持的容器类型 + 合并 字符串、列表、元组 * 复制 字符串、列表、元组 in 元素是否存在 字符串、列表、元组、字典 not in 元素是否不存在 字符串、列表、元组、字典 + 1234567891011121314151617# 1. 字符串 str1 = 'aa'str2 = 'bb'str3 = str1 + str2print(str3) # aabb# 2. 列表 list1 = [1, 2]list2 = [10, 20]list3 = list1 + list2print(list3) # [1, 2, 10, 20]# 3. 元组 t1 = (1, 2)t2 = (10, 20)t3 = t1 + t2print(t3) # (10, 20, 100, 200) * 12345678910# 1. 字符串print('-' * 10) # ----------# 2. 列表list1 = ['hello']print(list1 * 4) # ['hello', 'hello', 'hello', 'hello']# 3. 元组t1 = ('world',)print(t1 * 4) # ('world', 'world', 'world', 'world') in或not in 12345678910111213# 1. 字符串print('a' in 'abcd') # Trueprint('a' not in 'abcd') # False# 2. 列表list1 = ['a', 'b', 'c', 'd']print('a' in list1) # Trueprint('a' not in list1) # False# 3. 元组t1 = ('a', 'b', 'c', 'd')print('aa' in t1) # Falseprint('aa' not in t1) # True 公共方法 函数 描述 len() 计算容器中元素个数 del 或 del() 删除 max() 返回容器中元素最大值 min() 返回容器中元素最小值 range(start, end, step) 生成从start到end的数字，步长为 step，供for循环使用 enumerate() 函数用于将一个可遍历的数据对象(如列表、元组或字符串)组合为一个索引序列，同时列出数据和数据下标，一般用在 for 循环当中。 len() 12345678910111213141516171819# 1. 字符串str1 = 'abcdefg'print(len(str1)) # 7# 2. 列表list1 = [10, 20, 30, 40]print(len(list1)) # 4# 3. 元组t1 = (10, 20, 30, 40, 50)print(len(t1)) # 5# 4. 集合s1 = &#123;10, 20, 30&#125;print(len(s1)) # 3# 5. 字典dict1 = &#123;'name': 'Rose', 'age': 18&#125;print(len(dict1)) # 2 del() 123456789# 1. 字符串str1 = 'abcdefg'del str1print(str1)# 2. 列表list1 = [10, 20, 30, 40]del(list1[0])print(list1) # [20, 30, 40] max() 1234567# 1. 字符串str1 = 'abcdefg'print(max(str1)) # g# 2. 列表list1 = [10, 20, 30, 40]print(max(list1)) # 40 min() 1234567# 1. 字符串str1 = 'abcdefg'print(min(str1)) # a# 2. 列表list1 = [10, 20, 30, 40]print(min(list1)) # 10 range() 1234567891011# 1 2 3 4 5 6 7 8 9for i in range(1, 10, 1): print(i)# 1 3 5 7 9for i in range(1, 10, 2): print(i)# 0 1 2 3 4 5 6 7 8 9for i in range(10): print(i) 注意：range()生成的序列不包含end数字。 enumerate() 语法 1enumerate(可遍历对象, start=0) 注意：start参数用来设置遍历数据的下标的起始值，默认为0。 快速体验 1234567list1 = ['a', 'b', 'c', 'd', 'e']for i in enumerate(list1): print(i)for index, char in enumerate(list1, start=1): print(f'下标是&#123;index&#125;, 对应的字符是&#123;char&#125;') 容器类型转换 tuple() 作用：将某个序列转换成元组 12345list1 = [10, 20, 30, 40, 50, 20]s1 = &#123;100, 200, 300, 400, 500&#125;print(tuple(list1))print(tuple(s1)) list() 作用：将某个序列转换成列表 12345t1 = ('a', 'b', 'c', 'd', 'e')s1 = &#123;100, 200, 300, 400, 500&#125;print(list(t1))print(list(s1)) set() 作用：将某个序列转换成集合 12345list1 = [10, 20, 30, 40, 50, 20]t1 = ('a', 'b', 'c', 'd', 'e')print(set(list1))print(set(t1)) 注意： 集合可以快速完成列表去重 集合不支持下标 推导式列表推导式作用： 用一个表达式创建一个有规律的列表或控制一个有规律列表。 列表推导式又叫列表生成式。 需求：创建一个0-10的列表。 while循环实现 12345678910# 1. 准备一个空列表list1 = []# 2. 书写循环，依次追加数字到空列表list1中i = 0while i &lt; 10: list1.append(i) i += 1print(list1) for循环实现 12345list1 = []for i in range(10): list1.append(i)print(list1) 列表推导式实现 12list1 = [i for i in range(10)]print(list1) 带if的列表推导式 需求：创建0-10的偶数列表 方法一：range()步长实现 12list1 = [i for i in range(0, 10, 2)]print(list1) 方法二：if实现 12list1 = [i for i in range(10) if i % 2 == 0]print(list1) 多个for循环实现列表推导式 需求：创建列表如下： [(1, 0), (1, 1), (1, 2), (2, 0), (2, 1), (2, 2)] 12list1 = [(i, j) for i in range(1, 3) for j in range(3)]print(list1) 字典推导式思考：如果有如下两个列表： 12list1 = ['name', 'age', 'gender']list2 = ['Tom', 20, 'man'] 如何快速合并为一个字典？ 答：字典推导式 字典推导式作用：快速合并列表为字典或提取字典中目标数据。 1.创建一个字典：字典key是1-5数字，value是这个数字的2次方。 12dict1 = &#123;i: i ** 2 for i in range(1, 5)&#125;print(dict1) # &#123;1: 1, 2: 4, 3: 9, 4: 16&#125; 2.将两个列表合并为一个字典 12345list1 = ['name', 'age', 'gender']list2 = ['Tom', 20, 'man']dict1 = &#123;list1[i]: list2[i] for i in range(len(list1))&#125;print(dict1) 3.提取字典中目标数据 12345counts = &#123;'MBP': 268, 'HP': 125, 'DELL': 201, 'Lenovo': 199, 'acer': 99&#125;# 需求：提取上述电脑数量大于等于200的字典数据count1 = &#123;key: value for key, value in counts.items() if value &gt;= 200&#125;print(count1) # &#123;'MBP': 268, 'DELL': 201&#125; 集合推导式需求：创建一个集合，数据为下方列表的2次方。 1list1 = [1, 1, 2] 123list1 = [1, 1, 2]set1 = &#123;i ** 2 for i in list1&#125;print(set1) # &#123;1, 4&#125; 注意：集合有数据去重功能。 函数函数的作用函数就是将一段具有独立功能的代码块整合到一个整体并命名，在需要的位置调用这个名称即可完成对应的需求。 封装代码，高效的代码重用 函数的使用步骤定义函数1234def 函数名(参数): 代码1 代码2 ...... 调用函数1函数名(参数列表) 函数的参数作用函数调用的时候可以传入真实数据，增大函数的使用的灵活性 形参：函数定义时书写的参数(非真实数据) 实参：函数调用时书写的参数(真实数据) 函数的返回值作用作用：函数调用后，返回需要的计算结果 1return 表达式 函数的说明文档保存函数解释说明的信息 1234def 函数名(参数): \"\"\" 说明文档的位置 \"\"\" 代码 ...... 函数嵌套 所谓函数嵌套调用指的是一个函数里面又调用了另外一个函数。 变量作用域变量作用域指的是变量生效的范围，主要分为两类：局部变量和全局变量。 局部变量 所谓局部变量是定义在函数体内部的变量，即只在函数体内部生效。 局部变量的作用：在函数体内部，临时保存数据，即当函数调用完成后，则销毁局部变量。 全局变量 所谓全局变量，指的是在函数体内、外都能生效的变量。 多函数程序执行流程 共享全局变量 12345678910111213141516171819# 1. 定义全局变量glo_num = 0def test1(): global glo_num # 修改全局变量 glo_num = 100def test2(): # 调用test1函数中修改后的全局变量 print(glo_num)# 2. 调用test1函数，执行函数内部代码：声明和修改全局变量test1()# 3. 调用test2函数，执行函数内部代码：打印test2() # 100 返回值作为参数传递 12345678910111213def test1(): return 50def test2(num): print(num)# 1. 保存函数test1的返回值result = test1()# 2.将函数返回值所在变量作为参数传递到test2函数test2(result) # 50 函数的返回值123456def return_num(): return 1, 2result = return_num()print(result) # (1, 2) 注意： return a, b写法，返回多个数据的时候，默认是元组类型。 return后面可以连接列表、元组或字典，以返回多个值。 函数的参数位置参数位置参数：调用函数时根据函数定义的参数位置来传递参数。 12345def user_info(name, age, gender): print(f'您的名字是&#123;name&#125;, 年龄是&#123;age&#125;, 性别是&#123;gender&#125;')user_info('TOM', 20, '男') 注意：传递和定义参数的顺序及个数必须一致。 关键字参数函数调用，通过“键=值”形式加以指定。可以让函数更加清晰、容易使用，同时也清除了参数的顺序需求。 123456def user_info(name, age, gender): print(f'您的名字是&#123;name&#125;, 年龄是&#123;age&#125;, 性别是&#123;gender&#125;')user_info('Rose', age=20, gender='女')user_info('小明', gender='男', age=16) 注意：函数调用时，如果有位置参数时，位置参数必须在关键字参数的前面，但关键字参数之间不存在先后顺序。 缺省参数缺省参数也叫默认参数，用于定义函数，为参数提供默认值，调用函数时可不传该默认参数的值（注意：所有位置参数必须出现在默认参数前，包括函数定义和调用）。 123456def user_info(name, age, gender='男'): print(f'您的名字是&#123;name&#125;, 年龄是&#123;age&#125;, 性别是&#123;gender&#125;')user_info('TOM', 20)user_info('Rose', 18, '女') 注意：函数调用时，如果为缺省参数传值则修改默认参数值；否则使用这个默认值。 不定长参数不定长参数也叫可变参数。用于不确定调用的时候会传递多少个参数(不传参也可以)的场景。此时，可用包裹(packing)位置参数，或者包裹关键字参数，来进行参数传递，会显得非常方便。 包裹传递位置 12345678def user_info(*args): print(args)# ('TOM',)user_info('TOM')# ('TOM', 18)user_info('TOM', 18) 注意：传进的所有参数都会被args变量收集，它会根据传进参数的位置合并为一个元组(tuple)，args是元组类型，这就是包裹位置传递。 包裹关键字传递 123456def user_info(**kwargs): print(kwargs)# &#123;'name': 'TOM', 'age': 18, 'id': 110&#125;user_info(name='TOM', age=18, id=110) 综上：无论是包裹位置传递还是包裹关键字传递，都是一个组包的过程。 拆包和交换两个变量的值拆包 拆包：元组 1234567def return_num(): return 100, 200num1, num2 = return_num()print(num1) # 100print(num2) # 200 拆包：字典 123456789dict1 = &#123;'name': 'TOM', 'age': 18&#125;a, b = dict1# 对字典进行拆包，取出来的是字典的keyprint(a) # nameprint(b) # ageprint(dict1[a]) # TOMprint(dict1[b]) # 18 交换变量值需求：有变量a = 10和b = 20，交换两个变量的值。 方法一 借助第三变量存储数据。 1234567891011121314# 1. 定义中间变量c = 0# 2. 将a的数据存储到cc = a# 3. 将b的数据20赋值到a，此时a = 20a = b# 4. 将之前c的数据10赋值到b，此时b = 10b = cprint(a) # 20print(b) # 10 方法二 1234a, b = 1, 2a, b = b, aprint(a) # 2print(b) # 1 引用在python中，值是靠引用来传递来的。 我们可以用id()来判断两个变量是否为同一个值的引用。 我们可以将id值理解为那块内存的地址标识。 1234567891011121314151617181920212223242526272829# 1. int类型a = 1b = aprint(b) # 1print(id(a)) # 140708464157520print(id(b)) # 140708464157520a = 2print(b) # 1,说明int类型为不可变类型 print(id(a)) # 140708464157552，此时得到是的数据2的内存地址print(id(b)) # 140708464157520# 2. 列表aa = [10, 20]bb = aaprint(id(aa)) # 2325297783432print(id(bb)) # 2325297783432aa.append(30)print(bb) # [10, 20, 30], 列表为可变类型print(id(aa)) # 2325297783432print(id(bb)) # 2325297783432 引用当做实参 代码如下： 1234567891011121314151617def test1(a): print(a) print(id(a)) a += a print(a) print(id(a))# int：计算前后id值不同b = 100test1(b)# 列表：计算前后id值相同c = [11, 22]test1(c) 可变和不可变类型所谓可变类型与不可变类型是指：数据能够直接进行修改，如果能直接修改那么就是可变，否则是不可变. 可变类型 列表 字典 集合 不可变类型 整型 浮点型 字符串 元组 函数之递归递归的特点 函数内部自己调用自己 必须有出口 3以内数字累加和 123456789101112# 3 + 2 + 1def sum_numbers(num): # 1.如果是1，直接返回1 -- 出口 if num == 1: return 1 # 2.如果不是1，重复执行累加并返回结果 return num + sum_numbers(num - 1)sum_result = sum_numbers(3)# 输出结果为6print(sum_result) 函数之lambda 表达式lambda的应用场景如果一个函数有一个返回值，并且只有一句代码，可以使用 lambda简化。 lambda语法1lambda 参数列表 ： 表达式 注意 lambda表达式的参数可有可无，函数的参数在lambda表达式中完全适用。 lambda表达式能接收任何数量的参数但只能返回一个表达式的值。 123456789101112# 函数def fn1(): return 200print(fn1)print(fn1())# lambda表达式fn2 = lambda: 100print(fn2)print(fn2()) 注意：直接打印lambda表达式，输出的是此lambda的内存地址 计算a + b 123456def add(a, b): return a + bresult = add(1, 2)print(result) lambda实现 12fn1 = lambda a, b: a + bprint(fn1(1, 2)) lambda的参数形式无参数 12fn1 = lambda: 100print(fn1()) 一个参数 12fn1 = lambda a: aprint(fn1('hello world')) 默认参数 12fn1 = lambda a, b, c=100: a + b + cprint(fn1(10, 20)) 可变参数：*args 12fn1 = lambda *args: argsprint(fn1(10, 20, 30)) 注意：这里的可变参数传入到lambda之后，返回值为元组。 可变参数：**kwargs 12fn1 = lambda **kwargs: kwargsprint(fn1(name='python', age=20)) lambda的应用带判断的lambda 12fn1 = lambda a, b: a if a &gt; b else bprint(fn1(1000, 500)) 列表数据按字典key的值排序 1234567891011121314151617students = [ &#123;'name': 'TOM', 'age': 20&#125;, &#123;'name': 'ROSE', 'age': 19&#125;, &#123;'name': 'Jack', 'age': 22&#125;]# 按name值升序排列students.sort(key=lambda x: x['name'])print(students)# 按name值降序排列students.sort(key=lambda x: x['name'], reverse=True)print(students)# 按age值升序排列students.sort(key=lambda x: x['age'])print(students) 高阶函数 把函数作为参数传入,这样的函数称为高阶函数，高阶函数是函数式编程的体现。函数式编程就是指这种高度抽象的编程范式。 在Python中，abs()函数可以完成对数字求绝对值计算。 1abs(-10) # 10 round()函数可以完成对数字的四舍五入计算。 12round(1.2) # 1round(1.9) # 2 需求：任意两个数字，按照指定要求整理数字后再进行求和计算。 方法1 123456def add_num(a, b): return abs(a) + abs(b)result = add_num(-1, 2)print(result) # 3 方法2 123456def sum_num(a, b, f): return f(a) + f(b)result = sum_num(-1, 2, abs)print(result) # 3 注意：两种方法对比之后，发现，方法2的代码会更加简洁，函数灵活性更高。 函数式编程大量使用函数，减少了代码的重复，因此程序比较短，开发速度较快。 内置高阶函数 map() map(func, lst)，将传入的函数变量func作用到lst变量的每个元素中，并将结果组成新的列表(Python2)/迭代器(Python3)返回。 需求：计算list1序列中各个数字的2次方。 1234567891011list1 = [1, 2, 3, 4, 5]def func(x): return x ** 2result = map(func, list1)print(result) # &lt;map object at 0x0000013769653198&gt;print(list(result)) # [1, 4, 9, 16, 25] reduce() reduce(func，lst)，其中func必须有两个参数。每次func计算的结果继续和序列的下一个元素做累积计算。 注意：reduce()传入的参数func必须接收2个参数。 需求：计算list1序列中各个数字的累加和。 123456789101112import functoolslist1 = [1, 2, 3, 4, 5]def func(a, b): return a + bresult = functools.reduce(func, list1)print(result) # 15 filter() filter(func, lst)函数用于过滤序列, 过滤掉不符合条件的元素, 返回一个 filter 对象。如果要转换为列表, 可以使用 list() 来转换。 1234567891011list1 = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]def func(x): return x % 2 == 0result = filter(func, list1)print(result) # &lt;filter object at 0x0000017AF9DC3198&gt;print(list(result)) # [2, 4, 6, 8, 10] 文件操作文件操作步骤打开在python，使用open函数，可以打开一个已经存在的文件，或者创建一个新文件，语法如下： 1234open(name, mode)# name：是要打开的目标文件名的字符串(可以包含文件所在的具体路径)。# mode：设置打开文件的模式(访问模式)：只读、写入、追加等。 打开文件模式| 模式 | 描述 | | :–: | ———————————————————— | | r |以只读方式打开文件。文件的指针将会放在文件的开头。这是默认模式。 | | rb | 以二进制格式打开一个文件用于只读。文件指针将会放在文件的开头。这是默认模式。 | | r+ | 打开一个文件用于读写。文件指针将会放在文件的开头。 | |rb+ | 以二进制格式打开一个文件用于读写。文件指针将会放在文件的开头。 | | w | 打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。 | | wb |以二进制格式打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。 | | w+ |打开一个文件用于读写。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。 | | wb+ |以二进制格式打开一个文件用于读写。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。 | | a |打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。 | | ab |以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。 | | a+ |打开一个文件用于读写。如果该文件已存在，文件指针将会放在文件的结尾。文件打开时会是追加模式。如果该文件不存在，创建新文件用于读写。 | | ab+ |以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。如果该文件不存在，创建新文件用于读写。 | 文件对象方法写 语法 1对象对象.write('内容') 体验 12345678# 1. 打开文件f = open('test.txt', 'w')# 2.文件写入f.write('hello world')# 3. 关闭文件f.close() 注意： w和a模式：如果文件不存在则创建该文件；如果文件存在，w模式先清空再写入，a模式直接末尾追加。 r模式：如果文件不存在则报错。 读 read() 1文件对象.read(num) num表示要从文件中读取的数据的长度（单位是字节），如果没有传入num，那么就表示读取文件中所有的数据。 readlines() readlines可以按照行的方式把整个文件中的内容进行一次性读取，并且返回的是一个列表，其中每一行的数据为一个元素。 12345678f = open('test.txt')content = f.readlines()# ['hello world\\n', 'abcdefg\\n', 'aaa\\n', 'bbb\\n', 'ccc']print(content)# 关闭文件f.close() readline() readline()一次读取一行内容。 12345678910f = open('test.txt')content = f.readline()print(f'第一行：&#123;content&#125;')content = f.readline()print(f'第二行：&#123;content&#125;')# 关闭文件f.close() seek()作用：用来移动文件指针。 语法如下： 1文件对象.seek(偏移量, 起始位置) 起始位置： 0：文件开头 1：当前位置 2：文件结尾 关闭1文件对象.close() 文件备份接收用户输入目标文件名 1old_name = input('请输入您要备份的文件名：') 规划备份文件名 提取目标文件后缀 组织备份的文件名，xx[备份]后缀 123456789101112# 2.1 提取文件后缀点的下标index = old_name.rfind('.')# print(index) # 后缀中.的下标# print(old_name[:index]) # 源文件名（无后缀）# 2.2 组织新文件名 旧文件名 + [备份] + 后缀new_name = old_name[:index] + '[备份]' + old_name[index:]# 打印新文件名（带后缀）# print(new_name) 备份文件写入数据 打开源文件 和 备份文件 将源文件数据写入备份文件 关闭文件 1234567891011121314# 3.1 打开文件old_f = open(old_name, 'rb')new_f = open(new_name, 'wb')# 3.2 将源文件数据写入备份文件while True: con = old_f.read(1024) if len(con) == 0: break new_f.write(con)# 3.3 关闭文件old_f.close()new_f.close() 思考如果用户输入.txt，这是一个无效文件，程序如何更改才能限制只有有效的文件名才能备份？ 答：添加条件判断即可。 1234567891011121314151617181920old_name = input('请输入您要备份的文件名：')index = old_name.rfind('.')if index &gt; 0: postfix = old_name[index:]new_name = old_name[:index] + '[备份]' + postfixold_f = open(old_name, 'rb')new_f = open(new_name, 'wb')while True: con = old_f.read(1024) if len(con) == 0: break new_f.write(con)old_f.close()new_f.close() 文件和文件夹的操作在Python中文件和文件夹的操作要借助os模块里面的相关功能，具体步骤如下： 导入os模块 1import os 使用os模块相关功能 1os.函数名() 文件重命名 1os.rename(目标文件名，新文件名) 删除文件 1os.remove(目标文件名) 创建文件夹 12345678910111213141516171819202122232425os.mkdir(文件夹名字)``` - 删除文件夹```pythonos.rmdir(文件夹名字)``` - 获取当前目录```pythonos.getcwd()``` - 改变默认目录```pythonos.chdir(目录)``` - 获取目录列表```pythonos.listdir(目录) 应用案例需求：批量修改文件名，既可添加指定字符串，又能删除指定字符串。 步骤 设置添加删除字符串的的标识 获取指定目录的所有文件 将原有文件名添加/删除指定字符串，构造新名字 os.rename()重命名 12345678910111213141516171819import os# 设置重命名标识# 值为1添加指定字符，值为2删除指定字符flag = 1# 获取指定目录dir_name = './'# 获取指定目录的文件列表file_list = os.listdir(dir_name)print(file_list)for name in file_list: if flag == 1: new_name = 'python-' + name elif flag == 2: num = len('python-') new_name = name[num:] print(new_name) os.rename(dir_name + name, dir_name + new_name) 面向对象定义类Python2中类分为：经典类 和 新式类 语法 123class 类名(): 代码 ...... 注意：类名要满足标识符命名规则，同时遵循大驼峰命名习惯。 拓展：经典类 不由任意内置类型派生出的类，称之为经典类 123class 类名: 代码 ...... 创建对象对象又名实例。 语法 1对象名 = 类名() 注意：创建对象的过程也叫实例化对象。 selfself指的是调用该函数的对象。 注意：打印对象和self得到的结果是一致的，都是当前对象的内存中存储地址。 类外面添加对象属性 语法 1对象名.属性名 = 值 类外面获取对象属性 语法 1对象名.属性名 类里面获取对象属性 语法 1self.属性名 魔法方法在Python中，__xx__()的函数叫做魔法方法，指的是具有特殊功能的函数。 __init__() 作用：初始化对象 注意： __init__()方法，在创建一个对象时默认被调用，不需要手动调用 __init__(self)中的self参数，不需要开发者传递，python解释器会自动把当前的对象引用传递过去。 __str__() 当使用print输出对象的时候，默认打印对象的内存地址。如果类定义了__str__方法，那么就会打印从在这个方法中 return 的数据。 __del__() 当删除对象时，python解释器也会默认调用__del__()方法。 继承 拓展1：经典类或旧式类 不由任意内置类型派生出的类，称之为经典类。 123class 类名: 代码 ...... 拓展2：新式类 12class 类名(object): 代码 Python面向对象的继承指的是多个类之间的所属关系，即子类默认继承父类的所有属性和方法，具体如下： 12345678910111213141516# 父类Aclass A(object): def __init__(self): self.num = 1 def info_print(self): print(self.num)# 子类Bclass B(A): passresult = B()result.info_print() # 1 在Python中，所有类默认继承object类，object类是顶级类或基类；其他子类叫做派生类。 单继承1234567891011121314151617181920# 1. 师父类class Master(object): def __init__(self): self.kongfu = '[古法煎饼果子配方]' def make_cake(self): print(f'运用&#123;self.kongfu&#125;制作煎饼果子')# 2. 徒弟类class Prentice(Master): pass# 3. 创建对象daqiudaqiu = Prentice()# 4. 对象访问实例属性print(daqiu.kongfu)# 5. 对象调用实例方法daqiu.make_cake() 多继承所谓多继承意思就是一个类同时继承了多个父类。 123456789101112131415161718192021222324class Master(object): def __init__(self): self.kongfu = '[古法煎饼果子配方]' def make_cake(self): print(f'运用&#123;self.kongfu&#125;制作煎饼果子')# 创建学校类class School(object): def __init__(self): self.kongfu = '[黑马煎饼果子配方]' def make_cake(self): print(f'运用&#123;self.kongfu&#125;制作煎饼果子')class Prentice(School, Master): passdaqiu = Prentice()print(daqiu.kongfu)daqiu.make_cake() 注意：当一个类有多个父类的时候，默认使用第一个父类的同名属性和方法。 子类重写父类同名方法和属性123456789101112131415161718192021222324252627282930class Master(object): def __init__(self): self.kongfu = '[古法煎饼果子配方]' def make_cake(self): print(f'运用&#123;self.kongfu&#125;制作煎饼果子')class School(object): def __init__(self): self.kongfu = '[黑马煎饼果子配方]' def make_cake(self): print(f'运用&#123;self.kongfu&#125;制作煎饼果子')# 独创配方class Prentice(School, Master): def __init__(self): self.kongfu = '[独创煎饼果子配方]' def make_cake(self): print(f'运用&#123;self.kongfu&#125;制作煎饼果子')daqiu = Prentice()print(daqiu.kongfu)daqiu.make_cake()print(Prentice.__mro__) 子类和父类具有同名属性和方法，默认使用子类的同名属性和方法。 子类调用父类的同名方法和属性1234567891011121314151617181920212223242526272829303132333435363738394041424344class Master(object): def __init__(self): self.kongfu = '[古法煎饼果子配方]' def make_cake(self): print(f'运用&#123;self.kongfu&#125;制作煎饼果子')class School(object): def __init__(self): self.kongfu = '[黑马煎饼果子配方]' def make_cake(self): print(f'运用&#123;self.kongfu&#125;制作煎饼果子')class Prentice(School, Master): def __init__(self): self.kongfu = '[独创煎饼果子配方]' def make_cake(self): # 如果是先调用了父类的属性和方法，父类属性会覆盖子类属性，故在调用属性前，先调用自己子类的初始化 self.__init__() print(f'运用&#123;self.kongfu&#125;制作煎饼果子') # 调用父类方法，但是为保证调用到的也是父类的属性，必须在调用方法前调用父类的初始化 def make_master_cake(self): Master.__init__(self) Master.make_cake(self) def make_school_cake(self): School.__init__(self) School.make_cake(self)daqiu = Prentice()daqiu.make_cake()daqiu.make_master_cake()daqiu.make_school_cake()daqiu.make_cake() 多层继承123456789101112131415161718192021222324252627282930313233343536373839404142434445class Master(object): def __init__(self): self.kongfu = '[古法煎饼果子配方]' def make_cake(self): print(f'运用&#123;self.kongfu&#125;制作煎饼果子')class School(object): def __init__(self): self.kongfu = '[黑马煎饼果子配方]' def make_cake(self): print(f'运用&#123;self.kongfu&#125;制作煎饼果子')class Prentice(School, Master): def __init__(self): self.kongfu = '[独创煎饼果子配方]' def make_cake(self): self.__init__() print(f'运用&#123;self.kongfu&#125;制作煎饼果子') def make_master_cake(self): Master.__init__(self) Master.make_cake(self) def make_school_cake(self): School.__init__(self) School.make_cake(self)# 徒孙类class Tusun(Prentice): passxiaoqiu = Tusun()xiaoqiu.make_cake()xiaoqiu.make_school_cake()xiaoqiu.make_master_cake() super()调用父类方法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162class Master(object): def __init__(self): self.kongfu = '[古法煎饼果子配方]' def make_cake(self): print(f'运用&#123;self.kongfu&#125;制作煎饼果子')class School(Master): def __init__(self): self.kongfu = '[黑马煎饼果子配方]' def make_cake(self): print(f'运用&#123;self.kongfu&#125;制作煎饼果子') # 方法2.1 # super(School, self).__init__() # super(School, self).make_cake() # 方法2.2 super().__init__() super().make_cake()class Prentice(School): def __init__(self): self.kongfu = '[独创煎饼果子技术]' def make_cake(self): self.__init__() print(f'运用&#123;self.kongfu&#125;制作煎饼果子') # 子类调用父类的同名方法和属性：把父类的同名属性和方法再次封装 def make_master_cake(self): Master.__init__(self) Master.make_cake(self) def make_school_cake(self): School.__init__(self) School.make_cake(self) # 一次性调用父类的同名属性和方法 def make_old_cake(self): # 方法一：代码冗余；父类类名如果变化，这里代码需要频繁修改 # Master.__init__(self) # Master.make_cake(self) # School.__init__(self) # School.make_cake(self) # 方法二: super() # 方法2.1 super(当前类名, self).函数() # super(Prentice, self).__init__() # super(Prentice, self).make_cake() # 方法2.2 super().函数() super().__init__() super().make_cake()daqiu = Prentice()daqiu.make_old_cake() 注意：使用super() 可以自动查找父类。调用顺序遵循 __mro__ 类属性的顺序。比较适合单继承使用。 私有权限 定义私有属性和方法在Python中，可以为实例属性和方法设置私有权限，即设置某个实例属性或实例方法不继承给子类。 设置私有权限的方法：在属性名和方法名 前面 加上两个下划线 __。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354class Master(object): def __init__(self): self.kongfu = '[古法煎饼果子配方]' def make_cake(self): print(f'运用&#123;self.kongfu&#125;制作煎饼果子')class School(object): def __init__(self): self.kongfu = '[黑马煎饼果子配方]' def make_cake(self): print(f'运用&#123;self.kongfu&#125;制作煎饼果子')class Prentice(School, Master): def __init__(self): self.kongfu = '[独创煎饼果子配方]' # 定义私有属性 self.__money = 2000000 # 定义私有方法 def __info_print(self): print(self.kongfu) print(self.__money) def make_cake(self): self.__init__() print(f'运用&#123;self.kongfu&#125;制作煎饼果子') def make_master_cake(self): Master.__init__(self) Master.make_cake(self) def make_school_cake(self): School.__init__(self) School.make_cake(self)# 徒孙类class Tusun(Prentice): passdaqiu = Prentice()# 对象不能访问私有属性和私有方法# print(daqiu.__money)# daqiu.__info_print()xiaoqiu = Tusun()# 子类无法继承父类的私有属性和私有方法# print(xiaoqiu.__money) # 无法访问实例属性__money# xiaoqiu.__info_print() 注意：私有属性和私有方法只能在类里面访问和修改。 获取和修改私有属性值在Python中，一般定义函数名get_xx用来获取私有属性，定义set_xx用来修改私有属性值。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859class Master(object): def __init__(self): self.kongfu = '[古法煎饼果子配方]' def make_cake(self): print(f'运用&#123;self.kongfu&#125;制作煎饼果子')class School(object): def __init__(self): self.kongfu = '[黑马煎饼果子配方]' def make_cake(self): print(f'运用&#123;self.kongfu&#125;制作煎饼果子')class Prentice(School, Master): def __init__(self): self.kongfu = '[独创煎饼果子配方]' self.__money = 2000000 # 获取私有属性 def get_money(self): return self.__money # 修改私有属性 def set_money(self): self.__money = 500 def __info_print(self): print(self.kongfu) print(self.__money) def make_cake(self): self.__init__() print(f'运用&#123;self.kongfu&#125;制作煎饼果子') def make_master_cake(self): Master.__init__(self) Master.make_cake(self) def make_school_cake(self): School.__init__(self) School.make_cake(self)# 徒孙类class Tusun(Prentice): passdaqiu = Prentice()xiaoqiu = Tusun()# 调用get_money函数获取私有属性money的值print(xiaoqiu.get_money())# 调用set_money函数修改私有属性money的值xiaoqiu.set_money()print(xiaoqiu.get_money()) ### 面向对象三大特性 封装 将属性和方法书写到类的里面的操作即为封装 封装可以为属性和方法添加私有权限 继承 子类默认继承父类的所有属性和方法 子类可以重写父类属性和方法 多态 传入不同的对象，产生不同的结果 多态多态指的是一类事物有多种形态，（一个抽象类有多个子类，因而多态的概念依赖于继承）。 定义：多态是一种使用对象的方式，子类重写父类方法，调用不同子类对象的相同父类方法，可以产生不同的执行结果 好处：调用灵活，有了多态，更容易编写出通用的代码，做出通用的编程，以适应需求的不断变化！ 实现步骤： 定义父类，并提供公共方法 定义子类，并重写父类方法 传递子类对象给调用者，可以看到不同子类执行效果不同 1234567891011121314151617181920212223242526class Dog(object): def work(self): # 父类提供统一的方法，哪怕是空方法 print('指哪打哪...')class ArmyDog(Dog): # 继承Dog类 def work(self): # 子类重写父类同名方法 print('追击敌人...')class DrugDog(Dog): def work(self): print('追查毒品...')class Person(object): def work_with_dog(self, dog): # 传入不同的对象，执行不同的代码，即不同的work函数 dog.work()ad = ArmyDog()dd = DrugDog()daqiu = Person()daqiu.work_with_dog(ad)daqiu.work_with_dog(dd) 类属性和实例属性类属性 设置和访问类属性 类属性就是 类对象 所拥有的属性，它被 该类的所有实例对象 所共有。 类属性可以使用 类对象 或 实例对象 访问。 12345678910class Dog(object): tooth = 10wangcai = Dog()xiaohei = Dog()print(Dog.tooth) # 10print(wangcai.tooth) # 10print(xiaohei.tooth) # 10 类属性的优点 记录的某项数据 始终保持一致时，则定义类属性。 实例属性 要求 每个对象 为其 单独开辟一份内存空间 来记录数据，而 类属性 为全类所共有 ，仅占用一份内存，更加节省内存空间。 修改类属性 类属性只能通过类对象修改，不能通过实例对象修改，如果通过实例对象修改类属性，表示的是创建了一个实例属性。 123456789101112131415161718class Dog(object): tooth = 10wangcai = Dog()xiaohei = Dog()# 修改类属性Dog.tooth = 12print(Dog.tooth) # 12print(wangcai.tooth) # 12print(xiaohei.tooth) # 12# 不能通过对象修改属性，如果这样操作，实则是创建了一个实例属性wangcai.tooth = 20print(Dog.tooth) # 12print(wangcai.tooth) # 20print(xiaohei.tooth) # 12 实例属性123456789101112class Dog(object): def __init__(self): self.age = 5 def info_print(self): print(self.age)wangcai = Dog()print(wangcai.age) # 5# print(Dog.age) # 报错：实例属性不能通过类访问wangcai.info_print() # 5 类方法和静态方法 类方法 类方法特点 需要用装饰器@classmethod来标识其为类方法，对于类方法，第一个参数必须是类对象，一般以cls作为第一个参数。 类方法使用场景 当方法中 需要使用类对象 (如访问私有类属性等)时，定义类方法类方法一般和类属性配合使用 1234567891011class Dog(object): __tooth = 10 @classmethod def get_tooth(cls): return cls.__toothwangcai = Dog()result = wangcai.get_tooth()print(result) # 10 静态方法静态方法特点 需要通过装饰器@staticmethod来进行修饰，静态方法既不需要传递类对象也不需要传递实例对象（形参没有self/cls）。 静态方法 也能够通过 实例对象 和 类对象 去访问。 静态方法使用场景 当方法中 既不需要使用实例对象(如实例对象，实例属性)，也不需要使用类对象 (如类属性、类方法、创建实例等)时，定义静态方法 取消不需要的参数传递，有利于 减少不必要的内存占用和性能消耗12345678910class Dog(object): @staticmethod def info_print(): print('这是一个狗类，用于创建狗实例....')wangcai = Dog()# 静态方法既可以使用对象访问又可以使用类访问wangcai.info_print()Dog.info_print() 异常1234try: 可能发生错误的代码except: 如果出现异常执行的代码 需求：尝试以r模式打开文件，如果文件不存在，则以w方式打开。 1234try: f = open('test.txt', 'r')except: f = open('test.txt', 'w') 注意： 如果尝试执行的代码的异常类型和要捕获的异常类型不一致，则无法捕获异常。 一般try下方只放一行尝试执行的代码。 捕获多个指定异常当捕获多个异常时，可以把要捕获的异常类型的名字，放到except 后，并使用元组的方式进行书写。 12345try: print(1/0)except (NameError, ZeroDivisionError): print('有错误') 捕获异常描述信息1234try: print(num)except (NameError, ZeroDivisionError) as result: print(result) 捕获所有异常Exception是所有程序异常类的父类。 1234try: print(num)except Exception as result: print(result) 异常的elseelse表示的是如果没有异常要执行的代码。 123456try: print(1)except Exception as result: print(result)else: print('我是else，是没有异常的时候执行的代码') 异常的finallyfinally表示的是无论是否异常都要执行的代码，例如关闭文件。 12345678try: f = open('test.txt', 'r')except Exception as result: f = open('test.txt', 'w')else: print('没有异常，真开心')finally: f.close() 异常的传递需求： 尝试只读方式打开test.txt文件，如果文件存在则读取文件内容，文件不存在则提示用户即可。 读取内容要求：尝试循环读取内容，读取过程中如果检测到用户意外终止程序，则except捕获异常并提示用户。 12345678910111213141516171819import timetry: f = open('test.txt') try: while True: content = f.readline() if len(content) == 0: break time.sleep(2) print(content) except: # 如果在读取文件的过程中，产生了异常，那么就会捕获到 # 比如 按下了 ctrl+c print('意外终止了读取数据') finally: f.close() print('关闭文件')except: print(\"没有这个文件\") 自定义异常在Python中，抛出自定义异常的语法为raise 异常类对象。 需求：密码长度不足，则报异常（用户输入密码，如果输入的长度不足3位，则报错，即抛出自定义异常，并捕获该异常）。 1234567891011121314151617181920212223# 自定义异常类，继承Exceptionclass ShortInputError(Exception): def __init__(self, length, min_len): self.length = length self.min_len = min_len # 设置抛出异常的描述信息 def __str__(self): return f'你输入的长度是&#123;self.length&#125;, 不能少于&#123;self.min_len&#125;个字符'def main(): try: con = input('请输入密码：') if len(con) &lt; 3: raise ShortInputError(len(con), 3) except Exception as result: print(result) else: print('密码已经输入完成')main() 模块和包模块Python 模块(Module)，是一个 Python 文件，以 .py 结尾，包含了 Python 对象定义和Python语句。 模块能定义函数，类和变量，模块里也能包含可执行的代码。 导入模块导入模块的方式 import 模块名 from 模块名 import 功能名 from 模块名 import * import 模块名 as 别名 from 模块名 import 功能名 as 别名 导入方式详解 import123456# 1. 导入模块import 模块名import 模块名1, 模块名2...# 2. 调用功能模块名.功能名() from..import..1from 模块名 import 功能1, 功能2, 功能3... from .. import *1from 模块名 import * as定义别名12345# 模块定义别名import 模块名 as 别名# 功能定义别名from 模块名 import 功能 as 别名 制作模块在Python中，每个Python文件都可以作为一个模块，模块的名字就是文件的名字。也就是说自定义模块名必须要符合标识符命名规则。 定义模块新建一个Python文件，命名为my_module1.py，并定义testA函数。 12def testA(a, b): print(a + b) 测试模块12345678910111213# def testA(a, b):# print(a + b)# # # testA(1, 1)# 此时，无论是当前文件，还是其他已经导入了该模块的文件，在运行的时候都会自动执行`testA`函数的调用。def testA(a, b): print(a + b)# 只在当前文件中调用该函数，其他导入的文件内不符合该条件，则不执行testA函数调用if __name__ == '__main__': testA(1, 1) 调用模块12import my_module1my_module1.testA(1, 1) 注意事项 如果使用from .. import ..或from .. import *导入多个模块的时候，且模块内有同名功能。当调用这个同名功能的时候，调用到的是后面导入的模块的功能。 1234567891011121314# 模块1代码def my_test(a, b): print(a + b)# 模块2代码def my_test(a, b): print(a - b) # 导入模块和调用功能代码from my_module1 import my_testfrom my_module2 import my_test# my_test函数是模块2中的函数my_test(1, 1) 模块定位顺序当导入一个模块，Python解析器对模块位置的搜索顺序是： 当前目录 如果不在当前目录，Python则搜索在shell变量PYTHONPATH下的每个目录。 如果都找不到，Python会察看默认路径。UNIX下，默认路径一般为/usr/local/lib/python/ 模块搜索路径存储在system模块的sys.path变量中。变量里包含当前目录，PYTHONPATH和由安装过程决定的默认目录。 注意 自己的文件名不要和已有模块名重复，否则导致模块功能无法使用 使用from 模块名 import 功能的时候，如果功能名字重复，调用到的是最后定义或导入的功能。 __all__如果一个模块文件中有__all__变量，当使用from xxx import *导入时，只能导入这个列表中的元素。 包包将有联系的模块组织在一起，即放到同一个文件夹下，并且在这个文件夹创建一个名字为__init__.py 文件，那么这个文件夹就称之为包。 制作包[New] — [Python Package] — 输入包名 — [OK] — 新建功能模块(有联系的模块)。 注意：新建包后，包内部会自动创建__init__.py文件，这个文件控制着包的导入行为。 导入包123import 包名.模块名包名.模块名.目标 12from 包名 import *模块名.目标 注意：必须在__init__.py文件中添加__all__ = []，控制允许导入的模块列表。","categories":[{"name":"Geek","slug":"Geek","permalink":"https://casuor.top/categories/Geek/"}],"tags":[]},{"title":"MysqlNotes","slug":"geek_MysqlNotes","date":"2019-01-05T16:00:00.000Z","updated":"2021-03-16T10:32:52.800Z","comments":true,"path":"2019/01/06/geek_MysqlNotes/","link":"","permalink":"https://casuor.top/2019/01/06/geek_MysqlNotes/","excerpt":"","text":"## mysql服务及登陆数据库 123456789101112#启动net start mysqlnet stop mysql#关闭#登录mysql -u root -p pwdmysql -hip -u root -p pwdmysql --host=ip --user=root --password=pwd#退出exitquit mysql数据目录123#数据库：文件夹#表：文件#数据：文件内容 数据库的crud12345#sql分类-- DDL (data definition language)定义数据库对象：数据库，表，列。-- DML (data manipulation language)增删改表中数据-- DQL (data query language)查询表中数据-- DCL (data control language)数据库权限和安全级别，创建用户 DDL 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#操作数据库：#create #创建数据库 create database dbname; #判断是否有此数据库且创建 create database if not exists dbname; #指定创建的数据库字符集为gbk create database dbname charaacter set gbk;#retrieve #查询所有数据库的名称 show databases; #查看某个数据库的字符集 show create database mysql;#update #修改数据库的字符集 alter database dbname character set 字符集名称;#delete #删除数据库 drop databasse dbname; #判断数据库存在，存在再删除 drop database if exists dbname;#使用数据库 #查询正在使用的数据库 select database(); #使用数据库 use dbname;#操作表#create #创建表 create table tbname( 列名1，数据类型1， 列名2，数据类型2 ); #sql里的数据类型 int double data datatime timestamp #timestamp不赋值或赋值为null,则默认使用当前系统的时间 varchar #复制表 create table tbname2 like tbname1;#retrieve #查询数据库中所有表 show tables; #查询表结构 desc tbname;#update #修改表名 alter table tbname rename to ntbname; #修改表的字符集 alter table tbname character set utf8; #修改表的列 #添加alter table tbname add colname coltype; #删除 alter table tbname drop colname; #修改 alter table tbname change colname1 colname2 coltype; alter table tbname modify colname coltype;#delete #删除表 drop table tablename; drop table if exists tablename; DML 1234567891011#添加数据insert into tbname(col1,col2) values(v1,v2)#所有列都添加数据insert into tbname values(v1,v2,v3,v4)#删除数据delete from tbname [where] [条件]#删除所有数据delete from tbname; --一条条删，效率低truncate table tbname; --删除表，重新创建一张同样的表#修改数据update tbname set col1&#x3D;v1,col2&#x3D;v2 [where][条件]; DQL 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113#查询所有数据select * from tbname;#查询某数据select Field1,Field2 from tbname where [条件] grop by [分组字段] having [分组后条件] order by [排序] limit [分页限定]#基础查询 #多个字段的查询 select Field1,Field2 from tbname; #去除重复 select distinct field1 from tbname; #计算列 select field1+field2 from tbname; #如果为空替换为0 select field1 + ifnull(field2,0) from tbname; #起别名 select field1 alias1 + ifnull(field2,0) as alias2 from tbname;#条件查询 #where字句跟条件 #运算符 #&gt;,&gt;&#x3D;,&#x3D;,!&#x3D;,&lt;&gt;,and,between...and,or,in,is,like #null不能使用&#x3D;，！&#x3D;判断，可使用 is判断 #like模糊查询 # _ 一个字符 # % 任意个字符 #排序查询 #order by order by 排序字段1 排序方式1，排序字段2 排序方式2； select * from tbname order by field1 DESC; #ASC 升序 默认 #DESC 降序 #多个排序条件，则当前边的条件一样时，才会判断第二条件#聚合函数 #将一列数据作为一个整体，进行纵向计算,排除了null值 #count select count(field1) from tbname; #使用非空字段，如主键 #如果为空，默认设置为0 select count(ifnull(field1,0)) from tbname; #max #min #sum #avg#分组查询 #group by 分组字段 select field1,avg(field2) from tbname where field3 &gt; 60 group by field1 having count(field4)&gt;2; select field1,avg(field2),count(field4) alias from tbname where field3 &gt; 60 group by field1 having alias&gt;2; #分组之后查询的字段：分组字段，聚合函数 #where和having的区别？ #where作用位置，在分组之前进行限定，如果不满足条件，则不参与分组。having在分组之后进行条件限定，如不满足，则不会查询出来。 #where后不能跟聚合函数判断 #分页查询 #语法：limit 开始索引，每页查询的条数 #公式：开始索引&#x3D;（当前页码-1）*每页条数 select * from tbname limit 0,3;#约束 #概念：对表中数据进行限定，保证数据的正确性，有效性和完整性。 #分类：主键约束(primary key)，非空约束(not null)，唯一约束(unique)，外键约束(foreign key) #非空约束(not null) alter table tbname modify field1 varchar(20) not null; #唯一约束(unique) create table tbname( id int, phone varchar(11) unique ); #表创建完成后添加唯一约束 alter table tbname modify phone varchar(11) unique; #删除唯一约束 alter table tbname drop index phone; #主键约束(primary key) create table tbname( id int primary key, phone varchar(11) unique ); #表创建完成后添加主键 alter table tbname modify id int primary key; #删除主键 alter table tbname drop primary key; #自动增长 #概念：如果某一列是数值类型，使用auto_increment 可以完成自动增长 create table tbname( id int primary key auto_increment, phone varchar(11) unique ); #删除自动增长 alter table tbname modify id int; #添加自动增长 alter table tbname modify id int auto_increment; #外键约束 #在创建表时，添加外键 create table tbname( 外键列 constraint 外键名称 foreign key （子表外键列名称） references 主表名称（主表列名称） ); #删除外键 alter table tbname drop foreign key 外键名称; #创建表之后添加外键 alter table tbname add constraint 外键名称 foreign key （子表外键列名称） references 主表名称（主表列名称）; #级联操作 #添加级联操作 #级联更新 alter table tbname add constraint 外键名称 foreign key （子表外键列名称） references 主表名称（主表列名称） on update cascade; #级联删除 alter table tbname add constraint 外键名称 foreign key （子表外键列名称） references 主表名称（主表列名称） on delete cascade; 12345678910111213141516171819202122232425262728293031#多表之间的关系 #一对一 #一对一关系实现，可以在任意一方添加外键指向另一方的主键（外键唯一性） #一对多 #部门，员工 #实现方式：在多的一方建立外键，指向一的一方的主键。 #多对多 #多对多关系实现需要借助第三张中间表 #中间表至少包含两个字段，这两个字段作为第三张表的外键,这两个字段分别为这两张表的主键#数据库设计范式 #概念：设计数据库时，需要遵循的一些规范。要遵循后边的范式要求，必须遵循前边的所有范式要求 #设计关系数据库时，遵从不同的规范要求，设计出合理的关系型数据库，这些不同的规范要求被称为不同的范式，各种范式呈递次规范，越高的范式数据库孕育越小。 #目前关系型数据库有六种范式： #第一范式(1NF)每一列都是不可分割的原子数据项 #第二范式(2NF)在第一范式的基础上，非码属性必须完全依赖于候选码 #第三范式(3NF)在第二范式的基础上，任何非主属性不依赖于其他非主属性 #巴斯-科德范式(BCNF) #第四范式(4NF) #第五范式(SNF)#数据酷的备份及还原 #备份 mysqldump -u用户名 -p密码 数据库名 &gt; 保存的路径 #还原 #登录数据库 #创建数据库 #使用数据库 #执行文件 mysqld -u用户名 -p密码; create database db1； use db1; source 文件路径; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187#多表查询select * from tbname1,tbname2; #笛卡尔积 #消除无用数据 #内连接查询 #1.隐式 select * from tbname1,tbname2 where &#39;tbid1&#39;&#x3D;&#39;tbid2&#39;; #一般写法 select t1.name,t2.name from tbname1 t1,tbname2 t2 where t1.&#39;tbid1&#39;&#x3D; t2.&#39;tbid2&#39;; #2.显式 select * from tbname1 t1 inner join tbname2 t2 on t1.&#39;tbid1&#39;&#x3D; t2.&#39;tbid2&#39;; #外连接查询 #1.左外连接 #左表的所有记录及左表右表中的交集 select [field] from tbname1 left outer join tbname2 on 条件; #2.右外连接 select [field] from tbname1 right outer join tbname2 on 条件; #子查询 #概念：查询中嵌套的查询 select * from tbname where tbname.&#39;field&#39; &#x3D; (select Max(field) from tbname); #子查询的不同情况 #单行单列 -- 子查询可以作为条件，使用运算符去判断 -- 例：查询财务部和市场部的某员工的信息 #多行单列 -- 子查询可以作为条件使用运算符in来判断 -- 例：查询财务部和市场部的所有员工的信息 select id from deptarment where name &#x3D; &#39;财务部&#39; or name &#x3D; &#39;市场部&#39;； select * from tb1 where tb1_id in (select id from tb2 where name &#x3D; &#39;财务部&#39; or name &#x3D; &#39;市场部&#39;); #多行多列 #子查询可以作为一张虚拟表参与查询 #查询员工的入职日期是2011-11-11日之后的员工信息和部门信息 select * from tb2 ,(select * from tb1 where tb1.join_data &gt;&#39;2011-11-11&#39;) where t1.id &#x3D;t2.id; select * from tb1,tb2 where t1.id &#x3D; t2.id and tb1.join_data &gt;&#39;2011-11-11&#39;;#事务 #1. 事务的基本介绍 1. 概念： * 如果一个包含多个步骤的业务操作，被事务管理，那么这些操作要么同时成功，要么同时失败。 2. 操作： 1. 开启事务： start transaction; 2. 回滚：rollback; 3. 提交：commit; 3. 例子： CREATE TABLE account ( id INT PRIMARY KEY AUTO_INCREMENT, NAME VARCHAR(10), balance DOUBLE ); -- 添加数据 INSERT INTO account (NAME, balance) VALUES (&#39;zhangsan&#39;, 1000), (&#39;lisi&#39;, 1000);​ SELECT * FROM account; UPDATE account SET balance &#x3D; 1000; -- 张三给李四转账 500 元 -- 0. 开启事务 START TRANSACTION; -- 1. 张三账户 -500 UPDATE account SET balance &#x3D; balance - 500 WHERE NAME &#x3D; &#39;zhangsan&#39;; -- 2. 李四账户 +500 -- 出错了... UPDATE account SET balance &#x3D; balance + 500 WHERE NAME &#x3D; &#39;lisi&#39;; -- 发现执行没有问题，提交事务 COMMIT; -- 发现出问题了，回滚事务 ROLLBACK; 4. MySQL数据库中事务默认自动提交 * 事务提交的两种方式： * 自动提交： * mysql就是自动提交的 * 一条DML(增删改)语句会自动提交一次事务。 * 手动提交： * Oracle 数据库默认是手动提交事务 * 需要先开启事务，再提交 * 修改事务的默认提交方式： * 查看事务的默认提交方式：SELECT @@autocommit; -- 1 代表自动提交 0 代表手动提交 * 修改默认提交方式： set @@autocommit &#x3D; 0; 2. 事务的四大特征： 1. 原子性：是不可分割的最小操作单位，要么同时成功，要么同时失败。 2. 持久性：当事务提交或回滚后，数据库会持久化的保存数据。 3. 隔离性：多个事务之间。相互独立。 4. 一致性：事务操作前后，数据总量不变 3. 事务的隔离级别（了解） * 概念：多个事务之间隔离的，相互独立的。但是如果多个事务操作同一批数据，则会引发一些问题，设置不同的隔离级别就可以解决这些问题。 * 存在问题： 1. 脏读：一个事务，读取到另一个事务中没有提交的数据 2. 不可重复读(虚读)：在同一个事务中，两次读取到的数据不一样。 3. 幻读：一个事务操作(DML)数据表中所有记录，另一个事务添加了一条数据，则第一个事务查询不到自己的修改。 * 隔离级别： 1. read uncommitted：读未提交 * 产生的问题：脏读、不可重复读、幻读 2. read committed：读已提交 （Oracle） * 产生的问题：不可重复读、幻读 3. repeatable read：可重复读 （MySQL默认） * 产生的问题：幻读 4. serializable：串行化 * 可以解决所有的问题 * 注意：隔离级别从小到大安全性越来越高，但是效率越来越低 * 数据库查询隔离级别： * select @@tx_isolation; * 数据库设置隔离级别： * set global transaction isolation level 级别字符串; * 演示： set global transaction isolation level read uncommitted; start transaction; -- 转账操作 update account set balance &#x3D; balance - 500 where id &#x3D; 1; update account set balance &#x3D; balance + 500 where id &#x3D; 2;## DCL： * SQL分类： 1. DDL：操作数据库和表 2. DML：增删改表中数据 3. DQL：查询表中数据 4. DCL：管理用户，授权 * DBA：数据库管理员 * DCL：管理用户，授权 1. 管理用户 1. 添加用户： * 语法：CREATE USER &#39;用户名&#39;@&#39;主机名&#39; IDENTIFIED BY &#39;密码&#39;; 2. 删除用户： * 语法：DROP USER &#39;用户名&#39;@&#39;主机名&#39;; 3. 修改用户密码： UPDATE USER SET PASSWORD &#x3D; PASSWORD(&#39;新密码&#39;) WHERE USER &#x3D; &#39;用户名&#39;; UPDATE USER SET PASSWORD &#x3D; PASSWORD(&#39;abc&#39;) WHERE USER &#x3D; &#39;lisi&#39;; SET PASSWORD FOR &#39;用户名&#39;@&#39;主机名&#39; &#x3D; PASSWORD(&#39;新密码&#39;); SET PASSWORD FOR &#39;root&#39;@&#39;localhost&#39; &#x3D; PASSWORD(&#39;123&#39;); * mysql中忘记了root用户的密码？ 1. cmd -- &gt; net stop mysql 停止mysql服务 * 需要管理员运行该cmd 2. 使用无验证方式启动mysql服务： mysqld --skip-grant-tables 3. 打开新的cmd窗口,直接输入mysql命令，敲回车。就可以登录成功 4. use mysql; 5. update user set password &#x3D; password(&#39;你的新密码&#39;) where user &#x3D; &#39;root&#39;; 6. 关闭两个窗口 7. 打开任务管理器，手动结束mysqld.exe 的进程 8. 启动mysql服务 9. 使用新密码登录。 4. 查询用户： -- 1. 切换到mysql数据库 USE myql; -- 2. 查询user表 SELECT * FROM USER; * 通配符： % 表示可以在任意主机使用用户登录数据库 2. 权限管理： 1. 查询权限： -- 查询权限 SHOW GRANTS FOR &#39;用户名&#39;@&#39;主机名&#39;; SHOW GRANTS FOR &#39;lisi&#39;@&#39;%&#39;; 2. 授予权限： -- 授予权限 grant 权限列表 on 数据库名.表名 to &#39;用户名&#39;@&#39;主机名&#39;; -- 给张三用户授予所有权限，在任意数据库任意表上 GRANT ALL ON *.* TO &#39;zhangsan&#39;@&#39;localhost&#39;; 3. 撤销权限： -- 撤销权限： revoke 权限列表 on 数据库名.表名 from &#39;用户名&#39;@&#39;主机名&#39;; REVOKE UPDATE ON db3.&#96;account&#96; FROM &#39;lisi&#39;@&#39;%&#39;;","categories":[{"name":"Geek","slug":"Geek","permalink":"https://casuor.top/categories/Geek/"}],"tags":[]},{"title":"python小记(未完)","slug":"geek_python 小记","date":"2019-01-05T16:00:00.000Z","updated":"2020-10-28T09:58:54.885Z","comments":true,"path":"2019/01/06/geek_python 小记/","link":"","permalink":"https://casuor.top/2019/01/06/geek_python%20%E5%B0%8F%E8%AE%B0/","excerpt":"","text":"python 小记查看python路径12345Pythonimport sysprint(sys.path) 设置pip源C:\\Users\\16877\\pip\\pip.ini 12345[global]index-url = http://mirrors.aliyun.com/pypi/simple [install]trusted-host=mirrors.aliyun.com GithubRich is a Python library for rich text and beautiful formatting in the terminal. Anaconda configAnaconda Installer Anaconda修改国内镜像源 1234567conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/conda config --set show_channel_urls yescd ~lscode .\\.condarc 123channels: - https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;anaconda&#x2F;pkgs&#x2F;free&#x2F;show_channel_urls: true 1conda info Anaconda Usuages 12","categories":[{"name":"Geek","slug":"Geek","permalink":"https://casuor.top/categories/Geek/"}],"tags":[]},{"title":"BaiduCloud Picbed","slug":"geek_baiduPicbed","date":"2018-08-24T16:00:00.000Z","updated":"2020-10-28T09:58:54.881Z","comments":true,"path":"2018/08/25/geek_baiduPicbed/","link":"","permalink":"https://casuor.top/2018/08/25/geek_baiduPicbed/","excerpt":"","text":"百度下载图片链：https://image.baidu.com/search/down?tn=download&amp;url=巴拉巴拉.jpg 抓接口 首先我们打开百度识图的首页，按 F12 呼出浏览器开发者工具，切换到 Netnork 选项卡。因为百度识图在上传完图片后会立即进行跳转，因此还需勾选 Preserve log 用以保留跳转前的数据。 准备就绪后点击 识图一下 &gt; 本地上传，随意上传一张图片，这时浏览器 Netnork 里会列出在此期间产生的所有网络请求。我们可以点击工具栏里的 XHR，用以筛选出数据交互请求。(注：有时用 XHR也可能会过滤掉我们需要的数据，因此如果在 XHR 中找不到的时候，可以切回 ALL 里一个个找) 清空log,Ctrl+R刷新 通过缩略图发现 得到： Request URL: http://g.hiphotos.baidu.com/image/pic/item/37d12f2eb9389b5021eedd048b35e5dde7116e56.jpg 在筛选后的数据请求里，有个名称为 a_upload?fr=html5&amp;target=pcSearchImage&amp;needJson=true的请求很是可疑，因此点开查看请求详情。 可以看到，本地的图片果然是通过这个接口进行上传的。上传表单的文件 name 为 “file”。接口地址如下： http://image.baidu.com/pcdutu/a_upload?fr=html5&amp;target=pcSearchImage&amp;needJson=true 访问结果： 1&#123;\"errno\":-1,\"msg\":\"no file\",\"type\":\"img-upload\"&#125; 解析：错误； 错误问题：nofile; 类型：上传文件 至此，我们成功抓取到了百度识图的图片上传接口，接下来可以正式搞事情了 看来，接口没问题 写代码用代码实现很容易，就一个简单的 CURL 上传文件，这里直接给出完整版的代码了，收好！ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;?php/** * 上传图片到百度识图接口，获取图片外链 * * @param $file 图片文件 * @return 图片链接(上传成功) NULL(上传失败) * @copyright (c) mengkun(https://mkblog.cn/1619/) */function uploadToBaidu($file) &#123; // API 接口地址 $url = 'http://image.baidu.com/pcdutu/a_upload?fr=html5&amp;target=pcSearchImage&amp;needJson=true'; // 文件不存在 if(!file_exists($file)) return ''; // POST 文件 if (class_exists('CURLFile')) &#123; // php 5.5 $post['file'] = new CURLFile(realpath($file)); &#125; else &#123; $post['file'] = '@'.realpath($file); &#125; // CURL 模拟提交 $ch = curl_init(); curl_setopt($ch, CURLOPT_URL , $url); curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1); curl_setopt($ch, CURLOPT_POST, 1); curl_setopt($ch, CURLOPT_POSTFIELDS, $post); $output = curl_exec($ch); curl_close($ch); // 返回结果为空（上传失败） if($output == '') return ''; // 解析数据 $output = json_decode($output, true); if(isset($output['url']) &amp;&amp; $output['url'] != '') &#123; return $output['url']; &#125; return '';&#125;// 使用示例：$url = uploadToBaidu('1.jpg');echo $url;","categories":[{"name":"Geek","slug":"Geek","permalink":"https://casuor.top/categories/Geek/"}],"tags":[]},{"title":"数据结构与算法之美 Notes","slug":"geek_数据结构与算法之美-王争","date":"2018-08-22T16:00:00.000Z","updated":"2020-10-28T09:58:54.886Z","comments":true,"path":"2018/08/23/geek_数据结构与算法之美-王争/","link":"","permalink":"https://casuor.top/2018/08/23/geek_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E-%E7%8E%8B%E4%BA%89/","excerpt":"","text":"数据结构与算法之美-王争推动算法传播的是生活在美索不达米亚的AI Khwarizmi 于9世纪一本以阿拉姆语著述的教科书。 一、目标什么是数据结构？什么是算法？ 从广义上讲，数据结构就是指一组数据的存储结构。算法就是操作数据的一组方法。 从狭义上讲，也就是我们专栏要讲的，是指某些著名的数据结构和算法，比如队列、栈、堆、二分查找、动态规划等。这些都是前人智慧的结晶，我们可以直接拿来用。 数据结构与算法的关系？ 这是因为，数据结构和算法是相辅相成的。数据结构是为算法服务的，算法要作用在特定的数据结构之上。 因此，我们无法孤立数据结构来讲算法，也无法孤立算法来讲数据结构。 比如，因为数组具有随机访问的特点，常用的二分查找算法需要用数组来存储数据。但如果我们选择链表这种数据结构，二分查找算法就无法工作了，因为链表并不支持随机访问。 数据结构是静态的，它只是组织数据的一种方式。如果不在它的基础上操作、构建算法，孤立存在的数据结构就是没用的。 学习的重点？ 复杂度分析 数据结构和算法解决的是如何更省、更快地存储和处理数据的问题，因此，我们就需要一个考量效率和 资源消耗的方法，这就是复杂度分析方法。所以，只掌握了数据结构和算法的特点、用法，但是没有学 会复杂度分析，那就相当于只知道操作口诀，而没掌握心法。只有把心法了然于胸，才能做到无招胜有招！ 常用的，基础的数据结构与算法 10 个数据结构： 数组、链表、栈、队列、散列表、二叉树、堆、跳表、图、 Trie 树； 10个算法： 递归、排序、二分查找、搜索、哈希算法、贪心算法、分治算法、回溯算法、动态规划、字符串匹配算法。 二、算法复杂度分析如何分析、统计算法的执行效率和资源消耗？ 时间、空间复杂度分析。为什么需要复杂度分析？ 你可能会有些疑惑，我把代码跑一遍，通过统计、监控，就能得到算法执行的时间和占用的内存大小。为什么还要做时间、空间复杂度分析呢？这种分析方法能比我实实在在跑一遍得到的数据更准确吗？首先，我可以肯定地说，你这种评估算法执行效率的方法是正确的。很多数据结构和算法书籍还给这种方法起了一个名字，叫事后统计法。但是，这种统计方法有非常大的局限性。 1.测试结果非常依赖测试环境。 2.测试结果受数据规模影响很大 3.大O复杂度表示法 int cal(int n) { int sum = 0; int i = 1; for (; i &lt;= n; ++i) { sum = sum + i; } return sum; } 从 CPU 的角度来看，这段代码的每一行都执行着类似的操作：读数据 - 运算 - 写数据。尽管每行代码对应的 CPU 执行的个数、执行的时间都不一样，但是，我们这里只是粗略估计，所以可以假设每行代码执行的时间都一样，为 unit_time 。在这个假设的基础之上，这段代码的总执行时间是多少呢？第 2 、 3 行代码分别需要 1 个 unit_time 的执行时间，第 4 、 5 行都运行了 n 遍，所以需要2nunit_time 的执行时间，所以这段代码总的执行时间就是 (2n+2)*unit_time 。可以看出来，所有代码的执行时间 T(n) 与每行代码的执行次数成正比。 按照这个分析思路，我们再来看这段代码。 int cal(int n) { int sum = 0; int i = 1; int j = 1; for (; i &lt;= n; ++i) { j = 1; for (; j &lt;= n; ++j) { sum = sum + i * j; } } } 我们依旧假设每个语句的执行时间是 unit_time 。那这段代码的总执行时间 T(n) 是多少呢？第 2 、 3 、 4 行代码，每行都需要 1 个 unit_time 的执行时间，第 5 、 6 行代码循环执行了 n 遍，需要 2n * unit_time的执行时间，第7,8行执行了n^2遍，所以需要2n^2*unit_time的执行时间。所以整段代码执行时间 T(n)=(2n^2+2n+3)*unit_time. 尽管我们不知道 unit_time 的具体值，但是通过这两段代码执行时间的推导过程，我们可以得到一个非常重要的规律，那就是，所有代码的执行时间 T(n) 与每行代码的执行次数 n 成正比。我们可以把这个规律总结成一个公式。 大O记号 其中， T(n)表示代码执行的时间； n 表示数据规模的大小； f(n) 表示每行代码执行的次数总和。因为这是一个公式，所以用 f(n) 来表示。公式中的O ，表示代码的执行时间 T(n) 与 f(n) 表达式成正比。所以，第一个例子中的 T(n) = O(2n+2) ，第二个例子中的 T(n) = O(2n +2n+3) 。 这就是大 O 时间复杂度表示法。 大 O 时间复杂度实际上并不具体表示代码真正的执行时间，而是表示代码执行时间随数据规模增长的变化趋势，所以，也叫作渐进时间复杂度（ asymptotic time complexity ），简称时间复杂度。当 n 很大时，你可以把它想象成 10000 、 100000 。而公式中的低阶、常量、系数三部分并不左右增长趋势，所以都可以忽略。我们只需要记录一个最大量级就可以了，如果用大 O 表示法表示刚讲的那两段代码的时间复杂度，就可以记为： T(n) = O(n) ； T(n) = O(n ) 。 时间复杂度分析如何分析一段代码的时间复杂度？有三个比较实用的方法。 只关注循环执行次数最多的一段代码大 O 这种复杂度表示方法只是表示一种变化趋势。我们通常会忽略掉公式中的常量、低阶、系数，只需要记录一个最大阶的量级就可以了。所以，我们在分析一个算法、一段代码的时间复杂度的时候，也只关注循环执行次数最多的那一段代码就可以了。这段核心代码执行次数的 n的量级，就是整段要分析代码的时间复杂度。 那前面的第一个例子来说，其中第 2 、 3 行代码都是常量级的执行时间，与 n 的大小无关，所以对于复杂度并没有影响。循环执行次数最多的是第 4 、 5 行代码，所以这块代码要重点分析。前面我们也讲过，这两行代码被执行了 n 次，所以总的时间复杂度就是 O(n) 加法法则：总复杂度等于量级最大的那段代码的复杂度 //前100个数相加 int cal(int n) { int sum_1 = 0; int p = 1; for (; p &lt; 100; ++p) { sum_1 = sum_1 + p; } //前n个数 int sum_2 = 0; int q = 1; for (; q &lt; n; ++q) { sum_2 = sum_2 + q; } // int sum_3 = 0; int i = 1; int j = 1; for (; i &lt;= n; ++i) { j = 1; for (; j &lt;= n; ++j) { sum_3 = sum_3 + i * j; } } return sum_1 + sum_2 + sum_3; } 这个代码分为三部分，分别是求 sum_1 、 sum_2 、 sum_3 。我们可以分别分析每一部分的时间复杂度，然后把它们放到一块儿，再取一个量级最大的作为整段代码的复杂度。 第一段的时间复杂度是多少呢？这段代码循环执行了 100 次，所以是一个常量的执行时间，跟 n 的规模无关。这里我要再强调一下，即便这段代码循环 10000 次、 100000 次，只要是一个已知的数，跟 n 无关，照样也是常量级的执行时间。当 n 无限大的时候，就可以忽略。尽管对代码的执行时间会有很大影响，但是回到时间复杂度的概念来说，它表示的是一个算法执行效率与数据规模增长的变化趋势，所以不管常量的执行时间多大，我们都可以忽略掉。因为它本身对增长趋势并没有影响。那第二段代码和第三段代码的时间复杂度是多少呢？答案是 O(n) 和 O(n )。 综合三段代码的时间复杂度，我们取最大的量级，即总的复杂度为O(n^2) 也就是说：总的时间复杂度就等于量级最大的那段代码的时间复杂度。那我们将这个规律抽象成公式就是：如果 T1(n)=O(f(n)) ， T2(n)=O(g(n)) ；那么 T(n)=T1(n)+T2(n)=max(O(f(n)), O(g(n))) =O(max(f(n),g(n))). 3.乘法法则：嵌套代码的复杂度等于嵌套内外复杂度的乘积。 如果T1(n)=O(f(n)），T2(n)=O(g(n))； 那么T（n）=T1（n）xT2（n）=O(f(n))xO(g(n))=O(f(n)xg(n)).也就是说，假设T1（n）=O（n），T2（n）=O（n^2），则T1（n）xT2（n）=O（n^3）。 落实到具体的代码上 int cal(int n) { int ret = 0; int i = 1; for (; i &lt; n; ++i) { ret = ret + f(i); } } int f(int n) { int sum = 0; int i = 1; for (; i &lt; n; ++i) { sum = sum + i; } return sum; }我们单独看cal（）函数。假设f()只是一个普通的操作，那第4~6行的时间复杂度就是，T1(n)=O(n)。 但f()函数本身不是一个简单的操作，它的时间复杂度是T2(n)=O(n)，所以，整个cal）函数的时间复杂度就是，T(n)=T1(n)xT2(n)=O(nxn)=O（n2）。 常见的时间复杂度实例分析 分类： 多项式量级： 非多项式量级：O(2n)和O(n!)。 我们把复杂度为非多项式量级的算法问题叫做NP(Non-Deterministic Polynomial,非确定多项式)问题。 当数据规模n越来越大时，非多项式量级算法的执行时间会急剧增加，求解问题的执行时间会无限增长。所以，非多项式时间复杂度的算法其实是非常低效的算法。因此，关于NP时间复杂度问题略。 主要来看几种常见的多项式时间复杂度。 1.O(1) 常量级时间复杂度的一种表示方法，并不是指执行了一行代码。比如这段代码，即便有 3 行，它的时间复杂度也是 O(1 ），而不是 O(3) 。 int i = 8; int j = 6; int sum = i + j;由此，只要代码的执行时间不随 n 的增大而增长，这样代码的时间复杂度我们都记作O(1) 。或者说，一般情况下，只要算法中不存在循环语句、递归语句，即使有成千上万行的代码，其时间复杂度也是 Ο(1)。 2.O(logn),O(nlogn) i=1; while (i &lt;= n) { i = i * 2; }根据我们前面讲的复杂度分析方法，第三行代码是循环执行次数最多的。所以，我们只要能计算出这行代码被执行了多少次，就能知道整段代码的时间复杂度。从代码中可以看出，变量 i 的值从 1 开始取，每循环一次就乘以 2 。当大于 n 时，循环结束。还记得我们高中学过的等比数列吗？实际上，变量 i 的取值就是一个等比数列。如果我把它一个一个列出来，就应该是这个样子的： 所以，我们只要知道 x 值是多少，就知道这行代码执行的次数了。通过 2^x=n,则 x=log2n ，所以，这段代码的时间复杂度就是 O(log2n) 。现在，我把代码稍微改下，你再看看，这段代码的时间复杂度是多少？ i=1; while (i &lt;= n) { i = i * 3; }由上得出这段代码的复杂度为O(log3n) 。 实际上，不管是以 2 为底、以 3 为底，还是以 10 为底，我们可以把所有对数阶的时间复杂度都记为 O(logn)。 我们知道，对数之间是可以互相转换的，log3n就等于log32xlog2n，所以O(log3n)=O(Clog2n），其中C=log32是一个常量。基于我们前面的一个理论：*在采用大O标记复杂度的时候，可以忽略系数**，即O(Cf(n)=O(f(n))。所以，O（log2n）就等于O（log3n）。因此，在对数阶时间复杂度的表示方法里，我们忽略对数的“底”，统一表示为O（logn）。如果你理解了我前面讲的O（logn），那O（nlogn）就很容易理解了。还记得我们刚讲的乘法法则吗？如果一段代码的时间复杂度是O(logn)，我们循环执行n遍，时间复杂度就是O（nlogn）了。而且，O（nlogn）也是一种非常常见的算法时间复杂度。比如，归并排序、快速排序的时间复杂度都是O（nlogn）。 3.O(m+n),O(m*n) 这种情况代码的复杂度由两个数据的规模来决定。 int cal(int m, int n) { int sum_1 = 0; int i = 1; for (; i &lt; m; ++i) { sum_1 = sum_1 + i; } int sum_2 = 0; int j = 1; for (; j &lt; n; ++j) { sum_2 = sum_2 + j; } return sum_1 + sum_2; }从代码中可以看出， m 和 n 是表示两个数据规模。我们无法事先评估 m 和 n 谁的量级大，所以我们在表示复杂度的时候，就不能简单地利用加法法则，省略掉其中一个。所以，上面代码的时间复杂度就是 O(m+n) 。针对这种情况，原来的加法法则就不正确了，我们需要将加法规则改为： T1(m) + T2(n) = O(f(m) +g(n)) 。但是乘法法则继续有效： T1(m)*T2(n) = O(f(m) * f(n)) 。 空间复杂度分析 时间复杂度的全称是渐进时间复杂度，表示算法的执行时间与数据规模之间的增长关系。类比一下，空间复杂度全称就是渐进空间复杂度（ asymptotic space complexity ），表示算法的存储空间与数据规模之间的增长关系。 void print(int n) { int i = 0; int[] a = new int[n]; for (i; i &lt;n; ++i) { a[i] = i * i; } for (i = n-1; i &gt;= 0; --i) { print out a[i] } }跟时间复杂度分析一样，我们可以看到，第 2 行代码中，我们申请了一个空间存储变量 i ，但是它是常量阶的，跟数据规模 n 没有关系，所以我们可以忽略。第 3 行申请了一个大小为 n 的 int 类型数组，除此之外，剩下的代码都没有占用更多的空间，所以整段代码的空间复杂度就是 O(n)。 常见空间复杂度： O(1) 、 O(n)、 O(n^2) 小结： 复杂度也叫渐进复杂度，包括时间复杂度和空间复杂度，用来分析算法执行效率与数据规模之间的增长关系，可以粗略地表示，越高阶复杂度的算法，执行效率越低。 复杂度分析法则1 ）单段代码看高频：比如循环。2 ）多段代码取最大：比如一段代码中有单循环和多重循环，那么取多重循环的复杂度。3 ）嵌套代码求乘积：比如递归、多重循环等4 ）多个规模求加法：比如方法有两个参数控制两个循环的次数，那么这时就取二者复杂度相加。常用的复杂度级别？多项式阶：随着数据规模的增长，算法的执行时间和空间占用，按照多项式的比例增长。包括，O(1) （常数阶）、 O(logn) （对数阶）、 O(n) （线性阶）、 O(nlogn) （线性对数阶）、 O(n^2) （平方阶）、 O(n^3) （立方阶）非多项式阶：随着数据规模的增长，算法的执行时间和空间占用暴增，这类算法性能极差。包括，O(2^n) （指数阶）、 O(n!) 最好最坏及平均时间复杂度 // n 表示数组 array 的长度 int find(int[] array, int n, int x) { int i = 0; int pos = -1; for (; i &lt; n; ++i) { if (array[i] == x) pos = i; } return pos; }这段代码的功能是：长度为n的数组中，返回等于x的数组元素的下标，不等于则返回-1 缺点：全部元素遍历，不够高效 时间复杂度：O(n) // n 表示数组 array 的长度 int find(int[] array, int n, int x) { int i = 0; int pos = -1; for (; i &lt; n; ++i) { if (array[i] == x) { pos = i; break; } } return pos; }优化后时间复杂度则由x出现的位置决定。最好第一个元素，最差最后一个元素。 最好情况时间复杂度和最坏情况时间复杂度对应的都是极端情况下的代码复杂度，发生的概率其实并不大。为了更好地表示平均情况下的复杂度，需要引入另一个概念：平均情况时间复杂度，后面我简称为平均时间复杂度。 例： 要查找的变量 x 在数组中的位置，有 n+1 种情况：在数组的 0 ～ n-1 位置中和不在数组中。我们把每种情况下，查找需要遍历的元素个数累加起来，然后再除以 n+1 ，就可以得到需要遍历的元素个数的平均值， 即： 由大O记号表示可知，可以省略掉系数，低阶，常量，所以简化后的时间复杂度为O(n). 这个结论虽然是正确的，但是计算过程稍微有点儿问题。刚讲的这 n+1 种情况，出现的概率并不是一样的。我们知道，要查找的变量 x ，要么在数组里，要么就不在数组里。这两种情况对应的概率统计起来很麻烦，为了方便理解，我们假设在数组中与不在数组中的概率都为 1/2 。另外，要查找的数据出现在 0 ～ n-1 这 n 个位置的概率也是一样的，为 1/n 。所以，根据概率乘法法则，要查找的数据出现在 0 ～ n-1 中任意位置的概率就是 1/(2n). 因此，前面的推导过程中存在的最大问题就是，没有将各种情况发生的概率考虑进去。如果我们把每种情况发生的概率也考虑进去，那平均时间复杂度的计算过程就变成了这样： 这个值就是概率论中的加权平均值，也叫作期望值，所以平均时间复杂度的全称应该叫加权平均时间复杂度或者期望时间复杂度。引入概率之后，前面那段代码的加权平均值为 (3n+1)/4 。用大 O 表示法来表示，去掉系数和常量，这段代码的加权平均时间复杂度仍然是 O(n) 。 由上可得：不是所有情况都要进行最好，最糟或平均时间复杂度的分析，量级相差较大时才进行区别。 均摊时间复杂度 例子： // array 表示一个长度为 n 的数组 // 代码中的 array.length 就等于 n int[] array = new int[n]; int count = 0; void insert(int val) { if (count == array.length) { int sum = 0; for (int i = 0; i &lt; array.length; ++i) { sum = sum + array[i]; } array[0] = sum; count = 1; } array[count] = val; ++count; }代码功能： 往数组中插入数据的功能。 当数组满了之后，也就是代码中的 count == array.length 时，我们用 for 循环遍历数组求和，并清空数组，将求和之后的sum 值放到数组的第一个位置，然后再将新的数据插入。但如果数组一开始就有空闲空间，则直接将数据插入数组。最理想的情况下，数组中有空闲空间，我们只需要将数据插入到数组下标为 count 的位置就可以了，所以最好情况时间复杂度为 O(1) 。最坏的情况下，数组中没有空闲空间了，我们需要先做一次数组的遍历求和，然后再将数据插入，所以最坏情况时间复杂度为 O(n)。 平均复杂度分析： 假设数组的长度是 n ，根据数据插入的位置的不同，我们可以分为 n 种情况，每种情况的时间复杂度是 O(1) 。除此之外，还有一种 “ 额外 ” 的情况，就是在数组没有空闲空间时插入一个数据，这个时候的时间复杂度是 O(n) 。而且，这 n+1 种情况发生的概率一样，都是 1/(n+1) 。所以，根据加权平均的计算方法，我们求得的平均时间复杂度就是： 这个例子不需要引入概率论的知识。这是为什么呢？我们先来对比一下这个 insert() 的例子和前面那个 find() 的例子，你就会发现这两者有很大差别。首先， find() 函数在极端情况下，复杂度才为 O(1) 。但 insert() 在大部分情况下，时间复杂度都为O(1) 。只有个别情况下，复杂度才比较高，为 O(n) 。这是 insert() 第一个区别于 find() 的地方。第二个不同的地方，对于 insert() 函数来说， O(1) 时间复杂度的插入和 O(n) 时间复杂度的插入，出现的频率是非常有规律的，而且有一定的前后时序关系，一般都是一个 O(n) 插入之后，紧跟着 n-1 个 O(1) 的插入操作，循环往复。所以，针对这样一种特殊场景的复杂度分析，我们并不需要像之前讲平均复杂度分析方法那样，找出所有的输入情况及相应的发生概率，然后再计算加权平均值。 因此引入了摊还分析法，通过摊还分析得到的时间复杂度叫做均摊时间复杂度。 具体怎样使用摊还分析法分析算法的均摊时间复杂度？ 我们还是继续看在数组中插入数据的这个例子。每一次 O(n) 的插入操作，都会跟着 n-1 次 O(1) 的插入操作，所以把耗时多的那次操作均摊到接下来的 n-1 次耗时少的操作上，均摊下来，这一组连续的操作的均摊时间复杂度就是 O(1) 。这就是均摊分析的大致思路。均摊时间复杂度和摊还分析应用场景比较特殊，所以我们并不会经常用到。 应用场景 对一个数据结构进行一组连续操作中，大部分情况下时间复杂度都很低，只有个别情况下时间复杂度比较高，而且这些操作之间存在前后连贯的时序关系，这个时候，我们就可以将这一组操作放在一块儿分析，看是否能将较高时间复杂度那次操作的耗时，平摊到其他那些时间复杂度比较低的操作上。而且，在能够应用均摊时间复杂度分析的场合，一般均摊时间复杂度就等于最好情况时间复杂度。 一、复杂度分析的 4 个概念 最好情况时间复杂度：代码在最理想情况下执行的时间复杂度。 最坏情况时间复杂度：代码在最坏情况下执行的时间复杂度。 平均时间复杂度：用代码在所有情况下执行的次数的加权平均值表示。 均摊时间复杂度：在代码执行的所有复杂度情况中绝大部分是低级别的复杂度，个别情况是高级别复杂度且发生具有时序关系时，可以将个别高级别复杂度均摊到低级别复杂度上。基本上均摊结果就等于低级别复杂度。 二、为什么要引入这 4 个概念？ 同一段代码在不同情况下时间复杂度会出现量级差异，为了更全面，更准确的描述代码的时间复杂度，所以引入这 4 个概念。 代码复杂度在不同情况下出现量级差别时才需要区别这四种复杂度。大多数情况下，是不需要区别分析它们的。 三、 平均时间复杂度 代码在不同情况下复杂度出现量级差别，则用代码所有可能情况下执行次数的加权平均值表示。 均摊时间复杂度 两个条件满足时使用： 1 ）代码在绝大多数情况下是低级别复杂度，只有极少数情况是高级别复杂度； 2 ）低级别和高级别复杂度出现具有时序规律。均摊结果一般都等于低级别复杂度。 习题 // 全局变量，大小为 10 的数组 array ，长度 len ，下标 i 。 int array[] = new int[10]; int len = 10; int i = 0; // 往数组中添加一个元素 void add(int element) { if (i &gt;= len) { // 数组空间不够了 // 重新申请一个 2 倍大小的数组空间 int new_array[] = new int[len*2]; // 把原来 array 数组中的数据依次 copy 到 new_array for (int j = 0; j &lt; len; ++j) { new_array[j] = array[j]; } // new_array 复制给 array ， array 现在大小就是 2 倍 len 了 array = new_array; len = 2 * len; } // 将 element 放到下标为 i 的位置，下标 i 加一 array[i] = element; ++i; }线性表： 非线性表： 数组 1、存储结构：链式存储，前驱后继关联 2、操作： crud(前后索引关联，涉及最优最糟问题) 特点：非常低效 查询操作： 了解其存储方式，即查询就是通过数组下标进行。 插入操作： 假设数组的长度为n，现在，如果我们需要将一个数据插入到数组中的第k个位置。为了把第k个位置腾出来，给新来的数据，我们需要将第k~n这部分的元素都顺序地往后挪一位。那插入操作的时间复杂度是多少呢？ 如果在数组的末尾插入元素，那就不需要移动数据了，这时的(最优)时间复杂度为O（1）。但如果在数组的开头插入元素，那所有的数据都需要依次往后移动一位，所以最坏时间复杂度是O（n）。因为我们在每个位置插入元素的概率是一样的，所以平均情况时间复杂度为（1+2+.n）/n=O（n）。 如果数组中的数据是有序的，我们在某个位置插入一个新的元素时，就必须按照刚才的方法搬移k之后的数据。但是，如果数组中存储的数据并没有任何规律，数组只是被当作一个存储数据的集合。在这种情况下，如果要将某个数组插入到第k个位置，为了避免大规模的数据搬移，我们还有一个简单的办法就是，直接将第k位的数据搬移到数组元素的最后，把新的元素直接放入第k个位置。 例： 假设数组a[10]中存储了如下5个元素：a，b，c，d，e。我们现在需要将元素X插入到第3个位置。我们只需要将c放入到a[5]，将a[2]赋值为X即可。最后，数组中的元素如下：a，b，x，d，e，c。 删除操作： 跟插入数据类似，如果我们要删除第k个位置的数据，为了内存的连续性，也需要搬移数据，不然中间就会出现空洞，内存就不连续了。和插入类似，如果删除数组末尾的数据，则最好情况时间复杂度为O（1）；如果删除开头的数据，则最坏情况时间复杂度为O（n）；平均情况时间复杂度也为O（n）。 实际上，在某些特殊场景下，我们并不一定非得追求数组中数据的连续性。如果我们将多次删除操作集中在一起执行，删除的效率是不是会提高很多呢？例： 数组a[1]中存储了8个元素：a，b，c，d，e，f，g，h。现在，我们要依次删除a，b，c三个元素。 为了避免d，e，f，g，h这几个数据会被搬移三次，我们可以先记录下已经删除的数据。每次的删除操作并不是真正地搬移数据，只是记录数据已经被删除。当数组没有更多空间存储数据时，我们再触发执行一次真正的删除操作，这样就大大减少了删除操作导致的数据搬移。 访问数组越界问题： 即访问数组以外的资源； 容器能否完全替代数组？ 针对数组类型，很多语言都提供了容器类，比如Java中的Arraylist、C++STL中的ector。在项目开发中，什么时候适合用数组，什么时候适合用容器呢？ArrayList与数组相比，有哪些优势呢？ArrayList的优势就是可以将很多数组操作的细节封装起来。比如前面提到的数组插入、删除数据时需要搬移其他数据等。另外，它还有一个优势，就是支持动态扩容。数组本身在定义的时候需要预先指定大小，因为需要分配连续的内存空间。如果我们申请了大小为10的组，当第11个数据需要存储到数组中时，我们就需要重新分配一块更大的空间，将原来的数据复制过去，然后再将新的数据插入。 注意因为扩容操作涉及内存申请和数据搬移，是比较耗时的。所以，如果事先能确定需要存储的数据大小，最好在创建ArrayList的时候事先指定数据大小。 例： ArrayList&lt;User&gt; users = new ArrayList(10000); for (int i = 0; i &lt; 10000; ++i) { users.add(xxx); } 1.Java Arraylist无法存储基本类型，比如int、long，需要封装为Integer、Long类，而Autoboxing、Unboxing则有一定的性能消耗，所以如果特别关注性能，或者希望使用基本类型，就可以选用数组。2.如果数据大小事先已知，并且对数据的操作非常简单，用不到ArrayList提供的大部分方法，也可以直接使用数组。3.还有一个是我个人的喜好，当要表示多维数组时，用数组往往会更加直观。比如Object[][] array；而用容器的话则需要这样定义：ArrayListarray。 数组下标问题： 链表： 如何实现LRU缓存算法？ 缓存是一种提高数据读取性能的技术，在硬件设计、软件开发中都有着非常广泛的应用，比如常见的CPU缓存、数据库缓存、浏览器缓存等等。 缓存的大小有限，当缓存被用满时，哪些数据应该被清理出去，哪些数据应该被保留？这就需要缓存淘汰策略来决定。常见的策略有三种： 先进先出策略FIFO（First In，First Out） 最少使用策略LFU（Least Frequently Used） 最近最少使用策略LRU（Least Recently Used）。 数组与链表的存储结构： 单链表： 特点：索引串联存储，除了存储数据外，还需存储下一节点的索引，头尾相连，最后一个元素指向空 插入删除操作 查找操作 链表要想随机访问第k个元素，就没有数组那么高效了。因为链表中的数据并非连续存储的，所以无法像数组那样，根据首地址和下标，通过寻址公式就能直接计算出对应的内存地址，而是需要根据指针一个结点一个结点地依次遍历，直到找到相应的结点。需要O（n）的时间复杂度。 循环链表 特点：同单链表，不同在于尾节点指向起始头节点。 优点：任意节点出发的操作，而不用从头开始。 约瑟夫环问题 算法原理： 约瑟夫环运作如下： 1、一群人围在一起坐成 [2] 环状（如：N） 2、从某个编号开始报数（如：K） 3、数到某个数（如：M）的时候，此人出列，下一个人重新报数 4、一直循环，直到所有人出列 [3] ，约瑟夫环结束 自己写了一个：普通 看了下递归算法，还有待研究 优质推荐：应有尽有 双向链表 节点结构：前驱指针域 数据域 后继指针域 特点： 双向链表需要额外的两个空间来存储后继结点和前驱结点的地址。所以，如果存储同样多的数据，双向链表要比单链表占用更多的内存空间。虽然两个指针比较浪费存储空间，但可以支持双向遍历，这样也带来了双向链表操作的灵活性。 常见删除操作： 删除结点中“值等于某个给定值”的结点；删除给定指针指向的结点。 对于第一种情况，不管是单链表还是双向链表，为了查找到值等于给定值的结点，都需要从头结点开始一个一个依次遍历对比，直到找到值等于给定值的结点，然后再通过我前面讲的指针操作将其删除。尽管单纯的删除操作时间复杂度是O（1），但遍历查找的时间是主要的耗时点，对应的时间复杂度为O（n）。根据时间复杂度分析中的加法法则，删除值等于给定值的结点对应的链表操作的总时间复杂度为O（n）。对于第二种情况，我们已经找到了要删除的结点，但是删除某个结点q需要知道其前驱结点，而单链表并不支持直接获取前驱结点，所以，为了找到前驱结点，我们还是要从头结点开始遍历链表，直到p-&gt;next=q，说明p是q的前驱结点。但是对于双向链表来说，这种情况就比较有优势了。因为双向链表中的结点已经保存了前驱结点的指针，不需要像单链表那样遍历。所以，针对第二种情况，单链表删除操作需要O（n）的时间复杂度，而双向链表只需要在O（1）的时间复杂度内就搞定了！ 同理，如果我们希望在链表的某个指定结点前面插入一个结点，双向链表比单链表有很大的优势。双向链表可以在O（1）时间复杂度搞定，而单向链表需要O（n）的时间复杂度。除了插入、删除操作有优势之外，对于一个有序链表，双向链表的按值查询的效率也要比单链表高一些。因为，我们可以记录上次查找的位置p，每次查询时，根据要查找的值与p的大小关系，决定是往前还是往后查找，所以平均只需要查找一半的数据。现在，你有没有觉得双向链表要比单链表更加高效呢？这就是为什么在实际的软件开发中，双向链表尽管比较费内存，但还是比单链表的应用更加广泛的原因。如果你熟悉Java语言，你肯定用过LinkedHashMap这个容器。如果你深入研究LinkedHashMap的实现原理，就会发现其中就用到了双向链表这种数据结构。实际上，这里有一个更加重要的知识点需要你掌握，那就是用空间换时间的设计思想。当内存空间充足的时候，如果我们更加追求代码的执行速度，我们就可以选择空间复杂度相对较高、但时间复杂度相对很低的算法或者数据结构。相反，如果内存比较紧缺，比如代码跑在手机或者单片机上，这个时候，就要反过来用时间换空间的设计思路。 还是开篇缓存的例子。缓存实际上就是利用了空间换时间的设计思想。如果我们把数据存储在硬盘上，会比较节省内存，但每次查找数据都要询问一次硬盘，会比较慢。但如果我们通过缓存技术，事先将数据加载在内存中，虽然会比较耗费内存空间，但是每次数据查询的速度就大大提高了。所以我总结一下，对于执行较慢的程序，可以通过消耗更多的内存（空间换时间）来进行优化；而消耗过多内存的程序，可以通过消耗更多的时间（时间换空间）来降低内存的消耗。你还能想到其他时间换空间或者空间换时间的例子吗？了解了循环链表和双向链表，如果把这两种链表整合在一起就是一个新的版本：双向循环链表。我想不用我多讲，你应该知道双向循环链表长什么样子了吧？你可以自己试着在纸上画一画。 链表与数组性能比较 不过，数组和链表的对比，并不能局限于时间复杂度。而且，在实际的软件开发中，不能仅仅利用复杂度分析就决定使用哪个数据结构来存储数据。数组简单易用，在实现上使用的是连续的内存空间，可以借助CPU的缓存机制，预读数组中的数据，所以访问效率更高。而链表在内存中并不是连续存储，所以对CPU缓存不友好，没办法有效预读。数组的缺点是大小固定，一经声明就要占用整块连续内存空间。如果声明的数组过大，系统可能没有足够的连续内存空间分配给它，导致“内存不足（out of memory）”。如果声明的数组过小，则可能出现不够用的情况。这时只能再申请一个更大的内存空间，把原数组拷贝进去，非常费时。链表本身没有大小的限制，天然地支持动态扩容，我觉得这也是它与数组最大的区别。你可能会说，我们Java中的ArayList容器，也可以支持动态扩容啊？我们上一节课讲过，当我们往支持动态扩容的数组中插入一个数据时，如果数组中没有空闲空间了，就会申请一个更大的空间，将数据拷贝过去，而数据拷贝的操作是非常耗时的。我举一个稍微极端的例子。如果我们用ArrayList存储了了1GB大小的数据，这个时候已经没有空闲空间了，当我们再插入数据的时候，Arraylist会申请一个1.5GB大小的存储空间，并且把原来那1GB的数据拷贝到新申请的空间上。听起来是不是就很耗时？ 除此之外，如果你的代码对内存的使用非常苛刻，那数组就更适合你。因为链表中的每个结点都需要消耗额外的存储空间去存储一份指向下一个结点的指针，所以内存消耗会翻倍。而且，对链表进行频繁的插入、删除操作，还会导致频繁的内存申请和释放，容易造成内存碎片，如果是Java语言，就有可能会导致频繁的GC（Garbage Collection，垃圾回收）。所以，在我们实际的开发中，针对不同类型的项目，要根据具体情况，权衡究竟是选择数组还是链表。 解答开篇好了，关于链表的知识我们就讲完了。我们现在回过头来看下开篇留给你的思考题。如何基于链表实现LRU缓存淘汰算法？我的思路是这样的： 我们维护一个有序单链表，越靠近链表尾部的结点是越早之前访问的。当有一个新的数据被访问时，我们从链表头开始顺序遍历链表。1.如果此数据之前已经被缓存在链表中了，我们遍历得到这个数据对应的结点，并将其从原来的位置删除，然后再插入到链表的头部。2.如果此数据没有在缓存链表中，又可以分为两种情况：·如果此时缓存未满，则将此结点直接插入到链表的头部；·如果此时缓存已满，则链表尾结点删除，将新的数据结点插入链表的头部。这样我们就用链表实现了一个LRU缓存，是不是很简单？现在我们来看下m缓存访问的时间复杂度是多少。因为不管缓存有没有满，我们都需要遍历一遍链表，所以这种基于链表的实现思路，缓存访问的时间复杂度为O（n）。 实际上，我们可以继续优化这个实现思路，比如引入散列表（Hash table）来记录每个数据的位置，将缓存访问的时间复杂度降到O（1）。因为要涉及我们还没有讲到的数据结构，所以这个优化方案，我现在就不详细说了，等讲到散列表的时候，我会再拿出来讲。除了基于链表的实现思路，实际上还可以用数组来实现LRU缓存淘汰策略。如何利用数组实现LRU缓存淘汰策略呢？我把这个问题留给你思考。 课后思考如果字符串是通过单链表来存储的，那该如何来判断是一个回文串呢？相应的时间空间复杂度又是多少呢？","categories":[{"name":"Geek","slug":"Geek","permalink":"https://casuor.top/categories/Geek/"}],"tags":[]},{"title":"RPC架构简介与原理","slug":"geek_RPC架构简介与原理","date":"2018-07-24T16:00:00.000Z","updated":"2020-10-28T09:58:54.880Z","comments":true,"path":"2018/07/25/geek_RPC架构简介与原理/","link":"","permalink":"https://casuor.top/2018/07/25/geek_RPC%E6%9E%B6%E6%9E%84%E7%AE%80%E4%BB%8B%E4%B8%8E%E5%8E%9F%E7%90%86/","excerpt":"","text":"RPC架构简介与原理 RPC简介 RPC(Remote Procedure Call，即远程过程调用)是建立在Socket之上的，在一台机器上运行的主程序，可以调用另一台机器上准备好的子程序，就像LPC(本地过程调用)。也就是说两台服务器A，B，一个应用部署在A服务器上，想要调用B服务器上应用提供的函数/方法，由于不在一个内存空间，不能直接调用，需要通过网络来表达调用的语义和传达调用的数据。对于RPC架构来说，应用越底层，代码越复杂、灵活性越高、效率越高；应用越上层，抽象封装的越好、代码越简单、效率越差。 通过RPC，我们可以充分利用非共享内存的多处理器环境(例如通过局域网连接的多台应用服务器)，这样可以简便地将你的应用分布在多台应用服务器上，应用程序就像运行在一个多处理器的计算机上一样。我们可以方便的实现过程代码共享，提高系统资源的利用率，也可以将以大量数值处理的操作放在处理能力较强的系统上运行，从而减轻前端机的负担。 RPC作为普遍的C/S开发方法，开发效率高效、可靠。但RPC方法的基本原则是：以模块调用的简单性忽略通讯的具体细节，以便程序员不用关心C/S之间的通讯协议，集中精力实现应用过程。这就决定了 RPC生成的通讯包不可能对每种应用都有最恰当的处理办法，与Socket方法相比，传输相同的有效数据，RPC占用更多的网络带宽。RPC是在Socket的基础上实现的，它比socket需要更多的网络和系统资源。 RPC架构的作用 RPC 的主要目标是让构建分布式计算（应用）更容易、透明，在提供强大的远程调用能力时不损失本地调用的语义简洁性。为实现该目标，RPC 框架需提供一种透明调用机制让使用者不必显式的区分本地调用和远程调用。RPC框架负责屏蔽底层的传输方式（TCP或者UDP）、序列化方式（XML/JSON/二进制）和通信细节。开发人员在使用的时候只需要了解谁在什么位置提供了什么样的远程服务接口即可，并不需要关心底层通信细节和调用过程。 1、从通信协议的层面，大致可以分为： （1）基于HTTP协议的（例如基于文本的SOAP（XML）、REST（JSON）、基于二进制Hessian（Binary））； （2）基于TCP协议的（通常会借助Mina、Netty等高性能网络框架）。 2、只有二进制数据才能在网络中传输，序列化和反序列化的定义是： （1）将对象转换成二进制流的过程叫做序列化； （2）将二进制流转换成对象的过程叫做反序列化。 3、 RPC架构分为三部分： (1)、服务提供者（RPC Server），运行在服务器端，提供服务接口定义与服务实现类。 (2)、服务中心（Registry），运行在服务器端，负责将本地服务发布成远程服务，管理远程服务，提供给服务消费者使用。 (3)、服务消费者（RPC Client），运行在客户端，通过远程代理对象调用远程服务。 服务提供者启动后主动向服务（注册）中心注册机器ip、端口以及提供的服务列表； 服务消费者启动时向服务（注册）中心获取服务提供方地址列表，可实现软负载均衡和Failover。 RPC调用流程 简单来说一个RPC架构里包含如下4个组件: 1、 客户端(RPC Client)：服务调用方 2、 客户端存根(Client Stub)：存放服务端地址信息，将客户端的请求参数打包成网络消息，再通过网络发送给服务方 3、 服务端存根(Server Stub)：接受客户端发送过来的消息并解包，再调用本地服务 4、 服务端(RPC Server)：真正的服务提供者。 RPC采用C/S模式,请求程序就是一个客户端应用，而服务提供者就是一个服务器。首先，服务消费者（RPC客户端应用）调用进程发送一个有进程参数的调用信息到服务进程，然后等待应答信息。在服务提供方（RPC服务器端），进程保持睡眠状态直到调用信息到达为止。当一个调用信息到达，服务器获得进程参数，调用服务端方法对调用请求进行计算而得到计算结果，并发送答复信息，然后等待下一个调用信息；最后，客户端调用进程接收答复信息，获得进程结果，然后调用执行继续进行。 一次完整的RPC调用流程如下： 1)、服务消费方（Client）调用以本地调用方式调用服务； 2)、Client stub接收到调用后负责将方法、参数等组装成能够进行网络传输的消息体； 3)、Client stub找到服务地址，通过Socket将消息发送到服务端； 4)、Server stub收到消息后进行解码； 5)、Server stub根据解码结果调用服务端本地的服务； 6)、本地服务执行并将结果返回给Server stub； 7)、Server stub将返回结果打包成消息; 8)、Server stub通过Socket将消息发送至客户端； 9)、Client stub接收到消息，并进行解码； 10)、服务消费方（RPC Client）得到最终的服务调用结果。 RPC框架的目标就是要2~9这些步骤都封装起来，让用户对这些细节透明。 当我们在建立RPC服务以后，客户端的调用参数通过底层的RPC传输通道，可以是UDP，也可以是TCP，并根据传输前所提供的目的地址及RPC上层应用程序号转至相应的RPC应用程序服务端，且此时的客户端处于等待状态，直至收到应答或Time Out超时信号。当服务器端获得请求消息，则会根据注册RPC时告诉RPC系统的例程入口地址，执行相应的操作，并将结果返回至客户端。 当一次RPC调用结束后，相应线程发送相应的信号，客户端程序才会继续运行。在这个过程中，一个远程过程是有三个要素来唯一确定的：程序号、版本号和过程号。 程序号是用来区别一组相关的并且具有唯一过程好的远程过程。一个程序可以有一个或几个不同的版本，而每个版本的程序都包含一系列能被远程调用的过程，通过版本的引入，使得不同版本下的RPC能同时提供服务。每个版本都包含有许多可供远程调用的过程，每个过程则有其唯一标示的过程号。 RPC核心技术点和应用构架 1. 核心技术点 (1)、服务提供者需要以某种形式提供服务调用相关的信息，包括但不限于服务接口定义、数据结构、或者中间态的服务定义文件。例如Facebook的 Thrift的IDL文件，Web service的WSDL文件；服务的调用者需要通过一定的场景获取远程服务调用相关的信息。 (2)、远程代理对象：服务调用者用的服务实际是远程服务的本地代理。说白了就是通过动态代理来实现。 (3)、通信：RPC框架与具体的协议无关。 (4)、序列化：毕竟是远程通信，需要将对象转化成二进制流进行传输。不同的RPC框架应用的场景不同，在序列化上也会采取不同的技术。 2. 常见RPC技术和框架 (1)、应用级的服务框架：阿里的Dubbo/Dubbox、Google GRPC、Spring Boot/Spring Cloud。 (2)、远程通信协议：RMI、Socket、SOAP(HTTP XML)、REST(HTTP JSON)。 (3)、通信框架：MINA和Netty。","categories":[{"name":"Geek","slug":"Geek","permalink":"https://casuor.top/categories/Geek/"}],"tags":[]},{"title":"Mysql install for windows","slug":"geek_MysqlInstall","date":"2018-04-24T16:00:00.000Z","updated":"2020-10-28T09:58:54.879Z","comments":true,"path":"2018/04/25/geek_MysqlInstall/","link":"","permalink":"https://casuor.top/2018/04/25/geek_MysqlInstall/","excerpt":"","text":"Mysql离线安装教程（5.7.26）1.下载官网直达 2.解压并创建my.ini文件[mysql] # 设置mysql客户端默认字符集 default-character-set=utf8 [mysqld] # 设置3306端口 port = 3306 # 设置mysql的安装目录 basedir=F:\\Develop_MySQL\\mysql-5.7.26-winx64 #自己改 # 设置mysql数据库的数据的存放目录 datadir=F:\\Develop_MySQL\\mysql-5.7.26-winx64\\data #自己改 # 允许最大连接数 max_connections=200 # 设置mysql服务端默认字符集 character-set-server=utf83.配置环境变量（可省略）path中添加“F:\\Develop_MySQL\\mysql-5.7.26-winx64\\bin” 此步骤省略需进入“F:\\Develop_MySQL\\mysql-5.7.26-winx64\\bin”执行以下指令，反之。 4.初始化数据库管理员运行cmd mysqld --initialize --user=mysql --console 最后一行是随机生成的密码 初始化时出现问题: TIMESTAMP with implicit DEFAULT value is deprecated. Please use --explicit_defaults_for_timestamp server option (see documentation for more details)表明已经初始化过,建议删了重新弄 删除mysql HKEY_LOCAL_MACHINE\\SYSTEM\\ControlSet001\\services\\eventlog\\Application\\MySQL5.安装MySQL服务mysqld --install6.开启服务net start mysql7.进入操作（不解释操作）mysql -u root -p进入时密码一般为空或者生成的随机密码 ![](https://raw.githubusercontent.com/FenQingyang/Ey_PicBed/master/Images 8.修改初始密码方式一（命令行） 进入数据库，键入： ./mysqladmin -uroot -p password方式二（管理工具Navicat） 9.软件链接链接：https://pan.baidu.com/s/1vVOcs_Y2iW6HdM5m3irW0w提取码：h51w 其他版本自行百度","categories":[{"name":"Geek","slug":"Geek","permalink":"https://casuor.top/categories/Geek/"}],"tags":[]},{"title":"Mysql使用","slug":"geek_mysql","date":"2018-04-24T16:00:00.000Z","updated":"2020-12-23T07:43:42.878Z","comments":true,"path":"2018/04/25/geek_mysql/","link":"","permalink":"https://casuor.top/2018/04/25/geek_mysql/","excerpt":"","text":"mysql服务及登陆数据库#启动 net start mysql net stop mysql #关闭 #登录 mysql -u root -p pwd mysql -hip -u root -p pwd mysql --host=ip --user=root --password=pwd #退出 exit quitmysql数据目录#数据库：文件夹 #表：文件 #数据：文件内容数据库的crud#sql分类 -- DDL (data definition language)定义数据库对象：数据库，表，列。 -- DML (data manipulation language)增删改表中数据 -- DQL (data query language)查询表中数据 -- DCL (data control language)数据库权限和安全级别，创建用户 DDL #操作数据库： #create #创建数据库 create database dbname; #判断是否有此数据库且创建 create database if not exists dbname; #指定创建的数据库字符集为gbk create database dbname charaacter set gbk; #retrieve #查询所有数据库的名称 show databases; #查看某个数据库的字符集 show create database mysql; #update #修改数据库的字符集 alter database dbname character set 字符集名称; #delete #删除数据库 drop databasse dbname; #判断数据库存在，存在再删除 drop database if exists dbname; #使用数据库 #查询正在使用的数据库 select database(); #使用数据库 use dbname; #操作表 #create #创建表 create table tbname( 列名1，数据类型1， 列名2，数据类型2 ); #sql里的数据类型 int double data datatime timestamp #timestamp不赋值或赋值为null,则默认使用当前系统的时间 varchar #复制表 create table tbname2 like tbname1; #retrieve #查询数据库中所有表 show tables; #查询表结构 desc tbname; #update #修改表名 alter table tbname rename to ntbname; #修改表的字符集 alter table tbname character set utf8; #修改表的列 #添加 alter table tbname add colname coltype; #删除 alter table tbname drop colname; #修改 alter table tbname change colname1 colname2 coltype; alter table tbname modify colname coltype; #delete #删除表 drop table tablename; drop table if exists tablename; DML #添加数据 insert into tbname(col1,col2) values(v1,v2) #所有列都添加数据 insert into tbname values(v1,v2,v3,v4) #删除数据 delete from tbname [where] [条件] #删除所有数据 delete from tbname; --一条条删，效率低 truncate table tbname; --删除表，重新创建一张同样的表 #修改数据 update tbname set col1=v1,col2=v2 [where][条件]; DQL #查询所有数据 select * from tbname; #查询某数据 select Field1,Field2 from tbname where [条件] grop by [分组字段] having [分组后条件] order by [排序] limit [分页限定] #基础查询 #多个字段的查询 select Field1,Field2 from tbname; #去除重复 select distinct field1 from tbname; #计算列 select field1+field2 from tbname; #如果为空替换为0 select field1 + ifnull(field2,0) from tbname; #起别名 select field1 alias1 + ifnull(field2,0) as alias2 from tbname; #条件查询 #where字句跟条件 #运算符 #&gt;,&gt;=,=,!=,&lt;&gt;,and,between...and,or,in,is,like #null不能使用=，！=判断，可使用 is判断 #like模糊查询 # _ 一个字符 # % 任意个字符 #排序查询 #order by order by 排序字段1 排序方式1，排序字段2 排序方式2； select * from tbname order by field1 DESC; #ASC 升序 默认 #DESC 降序 #多个排序条件，则当前边的条件一样时，才会判断第二条件 #聚合函数 #将一列数据作为一个整体，进行纵向计算,排除了null值 #count select count(field1) from tbname; #使用非空字段，如主键 #如果为空，默认设置为0 select count(ifnull(field1,0)) from tbname; #max #min #sum #avg #分组查询 #group by 分组字段 select field1,avg(field2) from tbname where field3 &gt; 60 group by field1 having count(field4)&gt;2; select field1,avg(field2),count(field4) alias from tbname where field3 &gt; 60 group by field1 having alias&gt;2; #分组之后查询的字段：分组字段，聚合函数 #where和having的区别？ #where作用位置，在分组之前进行限定，如果不满足条件，则不参与分组。having在分组之后进行条件限定，如不满足，则不会查询出来。 #where后不能跟聚合函数判断 #分页查询 #语法：limit 开始索引，每页查询的条数 #公式：开始索引=（当前页码-1）*每页条数 select * from tbname limit 0,3; #约束 #概念：对表中数据进行限定，保证数据的正确性，有效性和完整性。 #分类：主键约束(primary key)，非空约束(not null)，唯一约束(unique)，外键约束(foreign key) #非空约束(not null) alter table tbname modify field1 varchar(20) not null; #唯一约束(unique) create table tbname( id int, phone varchar(11) unique ); #表创建完成后添加唯一约束 alter table tbname modify phone varchar(11) unique; #删除唯一约束 alter table tbname drop index phone; #主键约束(primary key) create table tbname( id int primary key, phone varchar(11) unique ); #表创建完成后添加主键 alter table tbname modify id int primary key; #删除主键 alter table tbname drop primary key; #自动增长 #概念：如果某一列是数值类型，使用auto_increment 可以完成自动增长 create table tbname( id int primary key auto_increment, phone varchar(11) unique ); #删除自动增长 alter table tbname modify id int; #添加自动增长 alter table tbname modify id int auto_increment; #外键约束 #在创建表时，添加外键 create table tbname( 外键列 constraint 外键名称 foreign key （子表外键列名称） references 主表名称（主表列名称） ); #删除外键 alter table tbname drop foreign key 外键名称; #创建表之后添加外键 alter table tbname add constraint 外键名称 foreign key （子表外键列名称） references 主表名称（主表列名称）; #级联操作 #添加级联操作 #级联更新 alter table tbname add constraint 外键名称 foreign key （子表外键列名称） references 主表名称（主表列名称） on update cascade; #级联删除 alter table tbname add constraint 外键名称 foreign key （子表外键列名称） references 主表名称（主表列名称） on delete cascade; #多表之间的关系 #一对一 #一对一关系实现，可以在任意一方添加外键指向另一方的主键（外键唯一性） #一对多 #部门，员工 #实现方式：在多的一方建立外键，指向一的一方的主键。 #多对多 #多对多关系实现需要借助第三张中间表 #中间表至少包含两个字段，这两个字段作为第三张表的外键,这两个字段分别为这两张表的主键 #数据库设计范式 #概念：设计数据库时，需要遵循的一些规范。要遵循后边的范式要求，必须遵循前边的所有范式要求 #设计关系数据库时，遵从不同的规范要求，设计出合理的关系型数据库，这些不同的规范要求被称为不同的范式，各种范式呈递次规范，越高的范式数据库孕育越小。 #目前关系型数据库有六种范式： #第一范式(1NF)每一列都是不可分割的原子数据项 #第二范式(2NF)在第一范式的基础上，非码属性必须完全依赖于候选码 #第三范式(3NF)在第二范式的基础上，任何非主属性不依赖于其他非主属性 #巴斯-科德范式(BCNF) #第四范式(4NF) #第五范式(SNF) #数据酷的备份及还原 #备份 mysqldump -u用户名 -p密码 数据库名 &gt; 保存的路径 #还原 #登录数据库 #创建数据库 #使用数据库 #执行文件 mysqld -u用户名 -p密码; create database db1； use db1; source 文件路径; #多表查询 select * from tbname1,tbname2; #笛卡尔积 #消除无用数据 #内连接查询 #1.隐式 select * from tbname1,tbname2 where &apos;tbid1&apos;=&apos;tbid2&apos;; #一般写法 select t1.name,t2.name from tbname1 t1,tbname2 t2 where t1.&apos;tbid1&apos;= t2.&apos;tbid2&apos;; #2.显式 select * from tbname1 t1 inner join tbname2 t2 on t1.&apos;tbid1&apos;= t2.&apos;tbid2&apos;; #外连接查询 #1.左外连接 #左表的所有记录及左表右表中的交集 select [field] from tbname1 left outer join tbname2 on 条件; #2.右外连接 select [field] from tbname1 right outer join tbname2 on 条件; #子查询 #概念：查询中嵌套的查询 select * from tbname where tbname.&apos;field&apos; = (select Max(field) from tbname); #子查询的不同情况 #单行单列 -- 子查询可以作为条件，使用运算符去判断 -- 例：查询财务部和市场部的某员工的信息 #多行单列 -- 子查询可以作为条件使用运算符in来判断 -- 例：查询财务部和市场部的所有员工的信息 select id from deptarment where name = &apos;财务部&apos; or name = &apos;市场部&apos;； select * from tb1 where tb1_id in (select id from tb2 where name = &apos;财务部&apos; or name = &apos;市场部&apos;); #多行多列 #子查询可以作为一张虚拟表参与查询 #查询员工的入职日期是2011-11-11日之后的员工信息和部门信息 select * from tb2 ,(select * from tb1 where tb1.join_data &gt;&apos;2011-11-11&apos;) where t1.id =t2.id; select * from tb1,tb2 where t1.id = t2.id and tb1.join_data &gt;&apos;2011-11-11&apos;; #事务 #1. 事务的基本介绍 1. 概念： * 如果一个包含多个步骤的业务操作，被事务管理，那么这些操作要么同时成功，要么同时失败。 2. 操作： 1. 开启事务： start transaction; 2. 回滚：rollback; 3. 提交：commit; 3. 例子： CREATE TABLE account ( id INT PRIMARY KEY AUTO_INCREMENT, NAME VARCHAR(10), balance DOUBLE ); -- 添加数据 INSERT INTO account (NAME, balance) VALUES (&apos;zhangsan&apos;, 1000), (&apos;lisi&apos;, 1000); ​ SELECT * FROM account; UPDATE account SET balance = 1000; -- 张三给李四转账 500 元 -- 0. 开启事务 START TRANSACTION; -- 1. 张三账户 -500 UPDATE account SET balance = balance - 500 WHERE NAME = &apos;zhangsan&apos;; -- 2. 李四账户 +500 -- 出错了... UPDATE account SET balance = balance + 500 WHERE NAME = &apos;lisi&apos;; -- 发现执行没有问题，提交事务 COMMIT; -- 发现出问题了，回滚事务 ROLLBACK; 4. MySQL数据库中事务默认自动提交 * 事务提交的两种方式： * 自动提交： * mysql就是自动提交的 * 一条DML(增删改)语句会自动提交一次事务。 * 手动提交： * Oracle 数据库默认是手动提交事务 * 需要先开启事务，再提交 * 修改事务的默认提交方式： * 查看事务的默认提交方式：SELECT @@autocommit; -- 1 代表自动提交 0 代表手动提交 * 修改默认提交方式： set @@autocommit = 0; 2. 事务的四大特征： 1. 原子性：是不可分割的最小操作单位，要么同时成功，要么同时失败。 2. 持久性：当事务提交或回滚后，数据库会持久化的保存数据。 3. 隔离性：多个事务之间。相互独立。 4. 一致性：事务操作前后，数据总量不变 3. 事务的隔离级别（了解） * 概念：多个事务之间隔离的，相互独立的。但是如果多个事务操作同一批数据，则会引发一些问题，设置不同的隔离级别就可以解决这些问题。 * 存在问题： 1. 脏读：一个事务，读取到另一个事务中没有提交的数据 2. 不可重复读(虚读)：在同一个事务中，两次读取到的数据不一样。 3. 幻读：一个事务操作(DML)数据表中所有记录，另一个事务添加了一条数据，则第一个事务查询不到自己的修改。 * 隔离级别： 1. read uncommitted：读未提交 * 产生的问题：脏读、不可重复读、幻读 2. read committed：读已提交 （Oracle） * 产生的问题：不可重复读、幻读 3. repeatable read：可重复读 （MySQL默认） * 产生的问题：幻读 4. serializable：串行化 * 可以解决所有的问题 * 注意：隔离级别从小到大安全性越来越高，但是效率越来越低 * 数据库查询隔离级别： * select @@tx_isolation; * 数据库设置隔离级别： * set global transaction isolation level 级别字符串; * 演示： set global transaction isolation level read uncommitted; start transaction; -- 转账操作 update account set balance = balance - 500 where id = 1; update account set balance = balance + 500 where id = 2; ## DCL： * SQL分类： 1. DDL：操作数据库和表 2. DML：增删改表中数据 3. DQL：查询表中数据 4. DCL：管理用户，授权 * DBA：数据库管理员 * DCL：管理用户，授权 1. 管理用户 1. 添加用户： * 语法：CREATE USER &apos;用户名&apos;@&apos;主机名&apos; IDENTIFIED BY &apos;密码&apos;; 2. 删除用户： * 语法：DROP USER &apos;用户名&apos;@&apos;主机名&apos;; 3. 修改用户密码： UPDATE USER SET PASSWORD = PASSWORD(&apos;新密码&apos;) WHERE USER = &apos;用户名&apos;; UPDATE USER SET PASSWORD = PASSWORD(&apos;abc&apos;) WHERE USER = &apos;lisi&apos;; SET PASSWORD FOR &apos;用户名&apos;@&apos;主机名&apos; = PASSWORD(&apos;新密码&apos;); SET PASSWORD FOR &apos;root&apos;@&apos;localhost&apos; = PASSWORD(&apos;123&apos;); * mysql中忘记了root用户的密码？ 1. cmd -- &gt; net stop mysql 停止mysql服务 * 需要管理员运行该cmd 2. 使用无验证方式启动mysql服务： mysqld --skip-grant-tables 3. 打开新的cmd窗口,直接输入mysql命令，敲回车。就可以登录成功 4. use mysql; 5. update user set password = password(&apos;你的新密码&apos;) where user = &apos;root&apos;; 6. 关闭两个窗口 7. 打开任务管理器，手动结束mysqld.exe 的进程 8. 启动mysql服务 9. 使用新密码登录。 4. 查询用户： -- 1. 切换到mysql数据库 USE myql; -- 2. 查询user表 SELECT * FROM USER; * 通配符： % 表示可以在任意主机使用用户登录数据库 2. 权限管理： 1. 查询权限： -- 查询权限 SHOW GRANTS FOR &apos;用户名&apos;@&apos;主机名&apos;; SHOW GRANTS FOR &apos;lisi&apos;@&apos;%&apos;; 2. 授予权限： -- 授予权限 grant 权限列表 on 数据库名.表名 to &apos;用户名&apos;@&apos;主机名&apos;; -- 给张三用户授予所有权限，在任意数据库任意表上 GRANT ALL ON *.* TO &apos;zhangsan&apos;@&apos;localhost&apos;; 3. 撤销权限： -- 撤销权限： revoke 权限列表 on 数据库名.表名 from &apos;用户名&apos;@&apos;主机名&apos;; REVOKE UPDATE ON db3.`account` FROM &apos;lisi&apos;@&apos;%&apos;;","categories":[{"name":"Geek","slug":"Geek","permalink":"https://casuor.top/categories/Geek/"}],"tags":[]},{"title":"commom-class-C#","slug":"geek_csharpcs","date":"2018-03-24T16:00:00.000Z","updated":"2020-10-28T09:58:54.882Z","comments":true,"path":"2018/03/25/geek_csharpcs/","link":"","permalink":"https://casuor.top/2018/03/25/geek_csharpcs/","excerpt":"","text":".Net常用类1.验证码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148using System;using System.Collections.Generic;using System.Drawing;using System.Drawing.Drawing2D;using System.Drawing.Imaging;using System.IO;using System.Linq;using System.Text;using System.Threading.Tasks;using System.Web;namespace CZBK.ItcastProject.Common&#123; public class ValidateCode &#123; public ValidateCode() &#123; &#125; &#x2F;&#x2F;&#x2F; &lt;summary&gt; &#x2F;&#x2F;&#x2F; 验证码的最大长度 &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt; public int MaxLength &#123; get &#123; return 10; &#125; &#125; &#x2F;&#x2F;&#x2F; &lt;summary&gt; &#x2F;&#x2F;&#x2F; 验证码的最小长度 &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt; public int MinLength &#123; get &#123; return 1; &#125; &#125; &#x2F;&#x2F;&#x2F; &lt;summary&gt; &#x2F;&#x2F;&#x2F; 生成验证码 &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt; &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;length&quot;&gt;指定验证码的长度&lt;&#x2F;param&gt; &#x2F;&#x2F;&#x2F; &lt;returns&gt;&lt;&#x2F;returns&gt; public string CreateValidateCode(int length) &#123; int[] randMembers &#x3D; new int[length]; int[] validateNums &#x3D; new int[length]; string validateNumberStr &#x3D; &quot;&quot;; &#x2F;&#x2F;生成起始序列值 int seekSeek &#x3D; unchecked((int)DateTime.Now.Ticks); Random seekRand &#x3D; new Random(seekSeek); int beginSeek &#x3D; (int)seekRand.Next(0, Int32.MaxValue - length * 10000); int[] seeks &#x3D; new int[length]; for (int i &#x3D; 0; i &lt; length; i++) &#123; beginSeek +&#x3D; 10000; seeks[i] &#x3D; beginSeek; &#125; &#x2F;&#x2F;生成随机数字 for (int i &#x3D; 0; i &lt; length; i++) &#123; Random rand &#x3D; new Random(seeks[i]); int pownum &#x3D; 1 * (int)Math.Pow(10, length); randMembers[i] &#x3D; rand.Next(pownum, Int32.MaxValue); &#125; &#x2F;&#x2F;抽取随机数字 for (int i &#x3D; 0; i &lt; length; i++) &#123; string numStr &#x3D; randMembers[i].ToString(); int numLength &#x3D; numStr.Length; Random rand &#x3D; new Random(); int numPosition &#x3D; rand.Next(0, numLength - 1); validateNums[i] &#x3D; Int32.Parse(numStr.Substring(numPosition, 1)); &#125; &#x2F;&#x2F;生成验证码 for (int i &#x3D; 0; i &lt; length; i++) &#123; validateNumberStr +&#x3D; validateNums[i].ToString(); &#125; return validateNumberStr; &#125; &#x2F;&#x2F;&#x2F; &lt;summary&gt; &#x2F;&#x2F;&#x2F; 创建验证码的图片 &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt; &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;containsPage&quot;&gt;要输出到的page对象&lt;&#x2F;param&gt; &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;validateNum&quot;&gt;验证码&lt;&#x2F;param&gt; public void CreateValidateGraphic(string validateCode, HttpContext context) &#123; Bitmap image &#x3D; new Bitmap((int)Math.Ceiling(validateCode.Length * 12.0), 22); Graphics g &#x3D; Graphics.FromImage(image); try &#123; &#x2F;&#x2F;生成随机生成器 Random random &#x3D; new Random(); &#x2F;&#x2F;清空图片背景色 g.Clear(Color.White); &#x2F;&#x2F;画图片的干扰线 for (int i &#x3D; 0; i &lt; 25; i++) &#123; int x1 &#x3D; random.Next(image.Width); int x2 &#x3D; random.Next(image.Width); int y1 &#x3D; random.Next(image.Height); int y2 &#x3D; random.Next(image.Height); g.DrawLine(new Pen(Color.Silver), x1, y1, x2, y2); &#125; Font font &#x3D; new Font(&quot;Arial&quot;, 12, (FontStyle.Bold | FontStyle.Italic)); &#x2F;&#x2F;渐变. LinearGradientBrush brush &#x3D; new LinearGradientBrush(new Rectangle(0, 0, image.Width, image.Height), Color.Blue, Color.DarkRed, 1.2f, true); g.DrawString(validateCode, font, brush, 3, 2); &#x2F;&#x2F;画图片的前景干扰点 for (int i &#x3D; 0; i &lt; 100; i++) &#123; int x &#x3D; random.Next(image.Width); int y &#x3D; random.Next(image.Height); image.SetPixel(x, y, Color.FromArgb(random.Next())); &#125; &#x2F;&#x2F;画图片的边框线 g.DrawRectangle(new Pen(Color.Silver), 0, 0, image.Width - 1, image.Height - 1); &#x2F;&#x2F;保存图片数据 MemoryStream stream &#x3D; new MemoryStream(); image.Save(stream, ImageFormat.Jpeg); &#x2F;&#x2F;输出图片流 context.Response.Clear(); context.Response.ContentType &#x3D; &quot;image&#x2F;jpeg&quot;; context.Response.BinaryWrite(stream.ToArray()); &#125; finally &#123; g.Dispose(); image.Dispose(); &#125; &#125; &#x2F;&#x2F;&#x2F; &lt;summary&gt; &#x2F;&#x2F;&#x2F; 得到验证码图片的长度 &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt; &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;validateNumLength&quot;&gt;验证码的长度&lt;&#x2F;param&gt; &#x2F;&#x2F;&#x2F; &lt;returns&gt;&lt;&#x2F;returns&gt; public static int GetImageWidth(int validateNumLength) &#123; return (int)(validateNumLength * 12.0); &#125; &#x2F;&#x2F;&#x2F; &lt;summary&gt; &#x2F;&#x2F;&#x2F; 得到验证码的高度 &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt; &#x2F;&#x2F;&#x2F; &lt;returns&gt;&lt;&#x2F;returns&gt; public static double GetImageHeight() &#123; return 22.5; &#125; &#125;&#125; 2.缩略图123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590using System;using System.Collections;using System.IO;using System.Drawing;using System.Drawing.Imaging;using System.Drawing.Drawing2D;namespace CZBK.ItcastProject.Common&#123; public class ImageClass &#123; public ImageClass() &#123; &#125; #region 缩略图 &#x2F;&#x2F;&#x2F; &lt;summary&gt; &#x2F;&#x2F;&#x2F; 生成缩略图 &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt; &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;originalImagePath&quot;&gt;源图路径（物理路径）&lt;&#x2F;param&gt; &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;thumbnailPath&quot;&gt;缩略图路径（物理路径）&lt;&#x2F;param&gt; &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;width&quot;&gt;缩略图宽度&lt;&#x2F;param&gt; &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;height&quot;&gt;缩略图高度&lt;&#x2F;param&gt; &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;mode&quot;&gt;生成缩略图的方式&lt;&#x2F;param&gt; public static void MakeThumbnail(string originalImagePath, string thumbnailPath, int width, int height, string mode) &#123; System.Drawing.Image originalImage &#x3D; System.Drawing.Image.FromFile(originalImagePath); int towidth &#x3D; width; int toheight &#x3D; height; int x &#x3D; 0; int y &#x3D; 0; int ow &#x3D; originalImage.Width; int oh &#x3D; originalImage.Height; switch (mode) &#123; case &quot;HW&quot;: &#x2F;&#x2F;指定高宽缩放（可能变形） break; case &quot;W&quot;: &#x2F;&#x2F;指定宽，高按比例 toheight &#x3D; originalImage.Height * width &#x2F; originalImage.Width; break; case &quot;H&quot;: &#x2F;&#x2F;指定高，宽按比例 towidth &#x3D; originalImage.Width * height &#x2F; originalImage.Height; break; case &quot;Cut&quot;: &#x2F;&#x2F;指定高宽裁减（不变形） if ((double)originalImage.Width &#x2F; (double)originalImage.Height &gt; (double)towidth &#x2F; (double)toheight) &#123; oh &#x3D; originalImage.Height; ow &#x3D; originalImage.Height * towidth &#x2F; toheight; y &#x3D; 0; x &#x3D; (originalImage.Width - ow) &#x2F; 2; &#125; else &#123; ow &#x3D; originalImage.Width; oh &#x3D; originalImage.Width * height &#x2F; towidth; x &#x3D; 0; y &#x3D; (originalImage.Height - oh) &#x2F; 2; &#125; break; default: break; &#125; &#x2F;&#x2F;新建一个bmp图片 System.Drawing.Image bitmap &#x3D; new System.Drawing.Bitmap(towidth, toheight); &#x2F;&#x2F;新建一个画板 System.Drawing.Graphics g &#x3D; System.Drawing.Graphics.FromImage(bitmap); &#x2F;&#x2F;设置高质量插值法 g.InterpolationMode &#x3D; System.Drawing.Drawing2D.InterpolationMode.High; &#x2F;&#x2F;设置高质量,低速度呈现平滑程度 g.SmoothingMode &#x3D; System.Drawing.Drawing2D.SmoothingMode.HighQuality; &#x2F;&#x2F;清空画布并以透明背景色填充 g.Clear(System.Drawing.Color.Transparent); &#x2F;&#x2F;在指定位置并且按指定大小绘制原图片的指定部分 &#x2F;&#x2F;第一个：对哪张图片进行操作。 &#x2F;&#x2F;二：画多么大。 &#x2F;&#x2F;三：画那块区域。 g.DrawImage(originalImage, new System.Drawing.Rectangle(0, 0, towidth, toheight), new System.Drawing.Rectangle(x, y, ow, oh), System.Drawing.GraphicsUnit.Pixel); try &#123; &#x2F;&#x2F;以jpg格式保存缩略图 bitmap.Save(thumbnailPath, System.Drawing.Imaging.ImageFormat.Jpeg); &#125; catch (System.Exception e) &#123; throw e; &#125; finally &#123; originalImage.Dispose(); bitmap.Dispose(); g.Dispose(); &#125; &#125; #endregion #region 图片水印 &#x2F;&#x2F;&#x2F; &lt;summary&gt; &#x2F;&#x2F;&#x2F; 图片水印处理方法 &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt; &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;path&quot;&gt;需要加载水印的图片路径（绝对路径）&lt;&#x2F;param&gt; &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;waterpath&quot;&gt;水印图片（绝对路径）&lt;&#x2F;param&gt; &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;location&quot;&gt;水印位置（传送正确的代码）&lt;&#x2F;param&gt; public static string ImageWatermark(string path, string waterpath, string location) &#123; string kz_name &#x3D; Path.GetExtension(path); if (kz_name &#x3D;&#x3D; &quot;.jpg&quot; || kz_name &#x3D;&#x3D; &quot;.bmp&quot; || kz_name &#x3D;&#x3D; &quot;.jpeg&quot;) &#123; DateTime time &#x3D; DateTime.Now; string filename &#x3D; &quot;&quot; + time.Year.ToString() + time.Month.ToString() + time.Day.ToString() + time.Hour.ToString() + time.Minute.ToString() + time.Second.ToString() + time.Millisecond.ToString(); Image img &#x3D; Bitmap.FromFile(path); Image waterimg &#x3D; Image.FromFile(waterpath); Graphics g &#x3D; Graphics.FromImage(img); ArrayList loca &#x3D; GetLocation(location, img, waterimg); g.DrawImage(waterimg, new Rectangle(int.Parse(loca[0].ToString()), int.Parse(loca[1].ToString()), waterimg.Width, waterimg.Height)); waterimg.Dispose(); g.Dispose(); string newpath &#x3D; Path.GetDirectoryName(path) + filename + kz_name; img.Save(newpath); img.Dispose(); File.Copy(newpath, path, true); if (File.Exists(newpath)) &#123; File.Delete(newpath); &#125; &#125; return path; &#125; &#x2F;&#x2F;&#x2F; &lt;summary&gt; &#x2F;&#x2F;&#x2F; 图片水印位置处理方法 &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt; &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;location&quot;&gt;水印位置&lt;&#x2F;param&gt; &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;img&quot;&gt;需要添加水印的图片&lt;&#x2F;param&gt; &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;waterimg&quot;&gt;水印图片&lt;&#x2F;param&gt; private static ArrayList GetLocation(string location, Image img, Image waterimg) &#123; ArrayList loca &#x3D; new ArrayList(); int x &#x3D; 0; int y &#x3D; 0; if (location &#x3D;&#x3D; &quot;LT&quot;) &#123; x &#x3D; 10; y &#x3D; 10; &#125; else if (location &#x3D;&#x3D; &quot;T&quot;) &#123; x &#x3D; img.Width &#x2F; 2 - waterimg.Width &#x2F; 2; y &#x3D; img.Height - waterimg.Height; &#125; else if (location &#x3D;&#x3D; &quot;RT&quot;) &#123; x &#x3D; img.Width - waterimg.Width; y &#x3D; 10; &#125; else if (location &#x3D;&#x3D; &quot;LC&quot;) &#123; x &#x3D; 10; y &#x3D; img.Height &#x2F; 2 - waterimg.Height &#x2F; 2; &#125; else if (location &#x3D;&#x3D; &quot;C&quot;) &#123; x &#x3D; img.Width &#x2F; 2 - waterimg.Width &#x2F; 2; y &#x3D; img.Height &#x2F; 2 - waterimg.Height &#x2F; 2; &#125; else if (location &#x3D;&#x3D; &quot;RC&quot;) &#123; x &#x3D; img.Width - waterimg.Width; y &#x3D; img.Height &#x2F; 2 - waterimg.Height &#x2F; 2; &#125; else if (location &#x3D;&#x3D; &quot;LB&quot;) &#123; x &#x3D; 10; y &#x3D; img.Height - waterimg.Height; &#125; else if (location &#x3D;&#x3D; &quot;B&quot;) &#123; x &#x3D; img.Width &#x2F; 2 - waterimg.Width &#x2F; 2; y &#x3D; img.Height - waterimg.Height; &#125; else &#123; x &#x3D; img.Width - waterimg.Width; y &#x3D; img.Height - waterimg.Height; &#125; loca.Add(x); loca.Add(y); return loca; &#125; #endregion #region 文字水印 &#x2F;&#x2F;&#x2F; &lt;summary&gt; &#x2F;&#x2F;&#x2F; 文字水印处理方法 &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt; &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;path&quot;&gt;图片路径（绝对路径）&lt;&#x2F;param&gt; &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;size&quot;&gt;字体大小&lt;&#x2F;param&gt; &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;letter&quot;&gt;水印文字&lt;&#x2F;param&gt; &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;color&quot;&gt;颜色&lt;&#x2F;param&gt; &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;location&quot;&gt;水印位置&lt;&#x2F;param&gt; public static string LetterWatermark(string path, int size, string letter, Color color, string location) &#123; #region string kz_name &#x3D; Path.GetExtension(path); if (kz_name &#x3D;&#x3D; &quot;.jpg&quot; || kz_name &#x3D;&#x3D; &quot;.bmp&quot; || kz_name &#x3D;&#x3D; &quot;.jpeg&quot;) &#123; DateTime time &#x3D; DateTime.Now; string filename &#x3D; &quot;&quot; + time.Year.ToString() + time.Month.ToString() + time.Day.ToString() + time.Hour.ToString() + time.Minute.ToString() + time.Second.ToString() + time.Millisecond.ToString(); Image img &#x3D; Bitmap.FromFile(path); Graphics gs &#x3D; Graphics.FromImage(img); ArrayList loca &#x3D; GetLocation(location, img, size, letter.Length); Font font &#x3D; new Font(&quot;宋体&quot;, size); Brush br &#x3D; new SolidBrush(color); gs.DrawString(letter, font, br, float.Parse(loca[0].ToString()), float.Parse(loca[1].ToString())); gs.Dispose(); string newpath &#x3D; Path.GetDirectoryName(path) + filename + kz_name; img.Save(newpath); img.Dispose(); File.Copy(newpath, path, true); if (File.Exists(newpath)) &#123; File.Delete(newpath); &#125; &#125; return path; #endregion &#125; &#x2F;&#x2F;&#x2F; &lt;summary&gt; &#x2F;&#x2F;&#x2F; 文字水印位置的方法 &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt; &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;location&quot;&gt;位置代码&lt;&#x2F;param&gt; &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;img&quot;&gt;图片对象&lt;&#x2F;param&gt; &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;width&quot;&gt;宽(当水印类型为文字时,传过来的就是字体的大小)&lt;&#x2F;param&gt; &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;height&quot;&gt;高(当水印类型为文字时,传过来的就是字符的长度)&lt;&#x2F;param&gt; private static ArrayList GetLocation(string location, Image img, int width, int height) &#123; #region ArrayList loca &#x3D; new ArrayList(); &#x2F;&#x2F;定义数组存储位置 float x &#x3D; 10; float y &#x3D; 10; if (location &#x3D;&#x3D; &quot;LT&quot;) &#123; loca.Add(x); loca.Add(y); &#125; else if (location &#x3D;&#x3D; &quot;T&quot;) &#123; x &#x3D; img.Width &#x2F; 2 - (width * height) &#x2F; 2; loca.Add(x); loca.Add(y); &#125; else if (location &#x3D;&#x3D; &quot;RT&quot;) &#123; x &#x3D; img.Width - width * height; &#125; else if (location &#x3D;&#x3D; &quot;LC&quot;) &#123; y &#x3D; img.Height &#x2F; 2; &#125; else if (location &#x3D;&#x3D; &quot;C&quot;) &#123; x &#x3D; img.Width &#x2F; 2 - (width * height) &#x2F; 2; y &#x3D; img.Height &#x2F; 2; &#125; else if (location &#x3D;&#x3D; &quot;RC&quot;) &#123; x &#x3D; img.Width - height; y &#x3D; img.Height &#x2F; 2; &#125; else if (location &#x3D;&#x3D; &quot;LB&quot;) &#123; y &#x3D; img.Height - width - 5; &#125; else if (location &#x3D;&#x3D; &quot;B&quot;) &#123; x &#x3D; img.Width &#x2F; 2 - (width * height) &#x2F; 2; y &#x3D; img.Height - width - 5; &#125; else &#123; x &#x3D; img.Width - width * height; y &#x3D; img.Height - width - 5; &#125; loca.Add(x); loca.Add(y); return loca; #endregion &#125; #endregion #region 调整光暗 &#x2F;&#x2F;&#x2F; &lt;summary&gt; &#x2F;&#x2F;&#x2F; 调整光暗 &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt; &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;mybm&quot;&gt;原始图片&lt;&#x2F;param&gt; &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;width&quot;&gt;原始图片的长度&lt;&#x2F;param&gt; &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;height&quot;&gt;原始图片的高度&lt;&#x2F;param&gt; &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;val&quot;&gt;增加或减少的光暗值&lt;&#x2F;param&gt; public Bitmap LDPic(Bitmap mybm, int width, int height, int val) &#123; Bitmap bm &#x3D; new Bitmap(width, height);&#x2F;&#x2F;初始化一个记录经过处理后的图片对象 int x, y, resultR, resultG, resultB;&#x2F;&#x2F;x、y是循环次数，后面三个是记录红绿蓝三个值的 Color pixel; for (x &#x3D; 0; x &lt; width; x++) &#123; for (y &#x3D; 0; y &lt; height; y++) &#123; pixel &#x3D; mybm.GetPixel(x, y);&#x2F;&#x2F;获取当前像素的值 resultR &#x3D; pixel.R + val;&#x2F;&#x2F;检查红色值会不会超出[0, 255] resultG &#x3D; pixel.G + val;&#x2F;&#x2F;检查绿色值会不会超出[0, 255] resultB &#x3D; pixel.B + val;&#x2F;&#x2F;检查蓝色值会不会超出[0, 255] bm.SetPixel(x, y, Color.FromArgb(resultR, resultG, resultB));&#x2F;&#x2F;绘图 &#125; &#125; return bm; &#125; #endregion #region 反色处理 &#x2F;&#x2F;&#x2F; &lt;summary&gt; &#x2F;&#x2F;&#x2F; 反色处理 &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt; &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;mybm&quot;&gt;原始图片&lt;&#x2F;param&gt; &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;width&quot;&gt;原始图片的长度&lt;&#x2F;param&gt; &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;height&quot;&gt;原始图片的高度&lt;&#x2F;param&gt; public Bitmap RePic(Bitmap mybm, int width, int height) &#123; Bitmap bm &#x3D; new Bitmap(width, height);&#x2F;&#x2F;初始化一个记录处理后的图片的对象 int x, y, resultR, resultG, resultB; Color pixel; for (x &#x3D; 0; x &lt; width; x++) &#123; for (y &#x3D; 0; y &lt; height; y++) &#123; pixel &#x3D; mybm.GetPixel(x, y);&#x2F;&#x2F;获取当前坐标的像素值 resultR &#x3D; 255 - pixel.R;&#x2F;&#x2F;反红 resultG &#x3D; 255 - pixel.G;&#x2F;&#x2F;反绿 resultB &#x3D; 255 - pixel.B;&#x2F;&#x2F;反蓝 bm.SetPixel(x, y, Color.FromArgb(resultR, resultG, resultB));&#x2F;&#x2F;绘图 &#125; &#125; return bm; &#125; #endregion #region 浮雕处理 &#x2F;&#x2F;&#x2F; &lt;summary&gt; &#x2F;&#x2F;&#x2F; 浮雕处理 &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt; &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;oldBitmap&quot;&gt;原始图片&lt;&#x2F;param&gt; &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;Width&quot;&gt;原始图片的长度&lt;&#x2F;param&gt; &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;Height&quot;&gt;原始图片的高度&lt;&#x2F;param&gt; public Bitmap FD(Bitmap oldBitmap, int Width, int Height) &#123; Bitmap newBitmap &#x3D; new Bitmap(Width, Height); Color color1, color2; for (int x &#x3D; 0; x &lt; Width - 1; x++) &#123; for (int y &#x3D; 0; y &lt; Height - 1; y++) &#123; int r &#x3D; 0, g &#x3D; 0, b &#x3D; 0; color1 &#x3D; oldBitmap.GetPixel(x, y); color2 &#x3D; oldBitmap.GetPixel(x + 1, y + 1); r &#x3D; Math.Abs(color1.R - color2.R + 128); g &#x3D; Math.Abs(color1.G - color2.G + 128); b &#x3D; Math.Abs(color1.B - color2.B + 128); if (r &gt; 255) r &#x3D; 255; if (r &lt; 0) r &#x3D; 0; if (g &gt; 255) g &#x3D; 255; if (g &lt; 0) g &#x3D; 0; if (b &gt; 255) b &#x3D; 255; if (b &lt; 0) b &#x3D; 0; newBitmap.SetPixel(x, y, Color.FromArgb(r, g, b)); &#125; &#125; return newBitmap; &#125; #endregion #region 拉伸图片 &#x2F;&#x2F;&#x2F; &lt;summary&gt; &#x2F;&#x2F;&#x2F; 拉伸图片 &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt; &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;bmp&quot;&gt;原始图片&lt;&#x2F;param&gt; &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;newW&quot;&gt;新的宽度&lt;&#x2F;param&gt; &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;newH&quot;&gt;新的高度&lt;&#x2F;param&gt; public static Bitmap ResizeImage(Bitmap bmp, int newW, int newH) &#123; try &#123; Bitmap bap &#x3D; new Bitmap(newW, newH); Graphics g &#x3D; Graphics.FromImage(bap); g.InterpolationMode &#x3D; System.Drawing.Drawing2D.InterpolationMode.HighQualityBicubic; g.DrawImage(bap, new Rectangle(0, 0, newW, newH), new Rectangle(0, 0, bap.Width, bap.Height), GraphicsUnit.Pixel); g.Dispose(); return bap; &#125; catch &#123; return null; &#125; &#125; #endregion #region 滤色处理 &#x2F;&#x2F;&#x2F; &lt;summary&gt; &#x2F;&#x2F;&#x2F; 滤色处理 &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt; &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;mybm&quot;&gt;原始图片&lt;&#x2F;param&gt; &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;width&quot;&gt;原始图片的长度&lt;&#x2F;param&gt; &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;height&quot;&gt;原始图片的高度&lt;&#x2F;param&gt; public Bitmap FilPic(Bitmap mybm, int width, int height) &#123; Bitmap bm &#x3D; new Bitmap(width, height);&#x2F;&#x2F;初始化一个记录滤色效果的图片对象 int x, y; Color pixel; for (x &#x3D; 0; x &lt; width; x++) &#123; for (y &#x3D; 0; y &lt; height; y++) &#123; pixel &#x3D; mybm.GetPixel(x, y);&#x2F;&#x2F;获取当前坐标的像素值 bm.SetPixel(x, y, Color.FromArgb(0, pixel.G, pixel.B));&#x2F;&#x2F;绘图 &#125; &#125; return bm; &#125; #endregion #region 左右翻转 &#x2F;&#x2F;&#x2F; &lt;summary&gt; &#x2F;&#x2F;&#x2F; 左右翻转 &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt; &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;mybm&quot;&gt;原始图片&lt;&#x2F;param&gt; &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;width&quot;&gt;原始图片的长度&lt;&#x2F;param&gt; &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;height&quot;&gt;原始图片的高度&lt;&#x2F;param&gt; public Bitmap RevPicLR(Bitmap mybm, int width, int height) &#123; Bitmap bm &#x3D; new Bitmap(width, height); int x, y, z; &#x2F;&#x2F;x,y是循环次数,z是用来记录像素点的x坐标的变化的 Color pixel; for (y &#x3D; height - 1; y &gt;&#x3D; 0; y--) &#123; for (x &#x3D; width - 1, z &#x3D; 0; x &gt;&#x3D; 0; x--) &#123; pixel &#x3D; mybm.GetPixel(x, y);&#x2F;&#x2F;获取当前像素的值 bm.SetPixel(z++, y, Color.FromArgb(pixel.R, pixel.G, pixel.B));&#x2F;&#x2F;绘图 &#125; &#125; return bm; &#125; #endregion #region 上下翻转 &#x2F;&#x2F;&#x2F; &lt;summary&gt; &#x2F;&#x2F;&#x2F; 上下翻转 &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt; &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;mybm&quot;&gt;原始图片&lt;&#x2F;param&gt; &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;width&quot;&gt;原始图片的长度&lt;&#x2F;param&gt; &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;height&quot;&gt;原始图片的高度&lt;&#x2F;param&gt; public Bitmap RevPicUD(Bitmap mybm, int width, int height) &#123; Bitmap bm &#x3D; new Bitmap(width, height); int x, y, z; Color pixel; for (x &#x3D; 0; x &lt; width; x++) &#123; for (y &#x3D; height - 1, z &#x3D; 0; y &gt;&#x3D; 0; y--) &#123; pixel &#x3D; mybm.GetPixel(x, y);&#x2F;&#x2F;获取当前像素的值 bm.SetPixel(x, z++, Color.FromArgb(pixel.R, pixel.G, pixel.B));&#x2F;&#x2F;绘图 &#125; &#125; return bm; &#125; #endregion #region 压缩图片 &#x2F;&#x2F;&#x2F; &lt;summary&gt; &#x2F;&#x2F;&#x2F; 压缩到指定尺寸 &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt; &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;oldfile&quot;&gt;原文件&lt;&#x2F;param&gt; &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;newfile&quot;&gt;新文件&lt;&#x2F;param&gt; public bool Compress(string oldfile, string newfile) &#123; try &#123; System.Drawing.Image img &#x3D; System.Drawing.Image.FromFile(oldfile); System.Drawing.Imaging.ImageFormat thisFormat &#x3D; img.RawFormat; Size newSize &#x3D; new Size(100, 125); Bitmap outBmp &#x3D; new Bitmap(newSize.Width, newSize.Height); Graphics g &#x3D; Graphics.FromImage(outBmp); g.CompositingQuality &#x3D; CompositingQuality.HighQuality; g.SmoothingMode &#x3D; SmoothingMode.HighQuality; g.InterpolationMode &#x3D; InterpolationMode.HighQualityBicubic; g.DrawImage(img, new Rectangle(0, 0, newSize.Width, newSize.Height), 0, 0, img.Width, img.Height, GraphicsUnit.Pixel); g.Dispose(); EncoderParameters encoderParams &#x3D; new EncoderParameters(); long[] quality &#x3D; new long[1]; quality[0] &#x3D; 100; EncoderParameter encoderParam &#x3D; new EncoderParameter(System.Drawing.Imaging.Encoder.Quality, quality); encoderParams.Param[0] &#x3D; encoderParam; ImageCodecInfo[] arrayICI &#x3D; ImageCodecInfo.GetImageEncoders(); ImageCodecInfo jpegICI &#x3D; null; for (int x &#x3D; 0; x &lt; arrayICI.Length; x++) if (arrayICI[x].FormatDescription.Equals(&quot;JPEG&quot;)) &#123; jpegICI &#x3D; arrayICI[x]; &#x2F;&#x2F;设置JPEG编码 break; &#125; img.Dispose(); if (jpegICI !&#x3D; null) outBmp.Save(newfile, System.Drawing.Imaging.ImageFormat.Jpeg); outBmp.Dispose(); return true; &#125; catch &#123; return false; &#125; &#125; #endregion #region 图片灰度化 public Color Gray(Color c) &#123; int rgb &#x3D; Convert.ToInt32((double)(((0.3 * c.R) + (0.59 * c.G)) + (0.11 * c.B))); return Color.FromArgb(rgb, rgb, rgb); &#125; #endregion #region 转换为黑白图片 &#x2F;&#x2F;&#x2F; &lt;summary&gt; &#x2F;&#x2F;&#x2F; 转换为黑白图片 &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt; &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;mybt&quot;&gt;要进行处理的图片&lt;&#x2F;param&gt; &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;width&quot;&gt;图片的长度&lt;&#x2F;param&gt; &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;height&quot;&gt;图片的高度&lt;&#x2F;param&gt; public Bitmap BWPic(Bitmap mybm, int width, int height) &#123; Bitmap bm &#x3D; new Bitmap(width, height); int x, y, result; &#x2F;&#x2F;x,y是循环次数，result是记录处理后的像素值 Color pixel; for (x &#x3D; 0; x &lt; width; x++) &#123; for (y &#x3D; 0; y &lt; height; y++) &#123; pixel &#x3D; mybm.GetPixel(x, y);&#x2F;&#x2F;获取当前坐标的像素值 result &#x3D; (pixel.R + pixel.G + pixel.B) &#x2F; 3;&#x2F;&#x2F;取红绿蓝三色的平均值 bm.SetPixel(x, y, Color.FromArgb(result, result, result)); &#125; &#125; return bm; &#125; #endregion #region 获取图片中的各帧 &#x2F;&#x2F;&#x2F; &lt;summary&gt; &#x2F;&#x2F;&#x2F; 获取图片中的各帧 &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt; &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;pPath&quot;&gt;图片路径&lt;&#x2F;param&gt; &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;pSavePath&quot;&gt;保存路径&lt;&#x2F;param&gt; public void GetFrames(string pPath, string pSavedPath) &#123; Image gif &#x3D; Image.FromFile(pPath); FrameDimension fd &#x3D; new FrameDimension(gif.FrameDimensionsList[0]); int count &#x3D; gif.GetFrameCount(fd); &#x2F;&#x2F;获取帧数(gif图片可能包含多帧，其它格式图片一般仅一帧) for (int i &#x3D; 0; i &lt; count; i++) &#x2F;&#x2F;以Jpeg格式保存各帧 &#123; gif.SelectActiveFrame(fd, i); gif.Save(pSavedPath + &quot;\\\\frame_&quot; + i + &quot;.jpg&quot;, ImageFormat.Jpeg); &#125; &#125; #endregion &#125;&#125; 3.SqlHelper12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849using System;using System.Collections.Generic;using System.Configuration;using System.Linq;using System.Text;using System.Threading.Tasks;using System.Data;using System.Data.SqlClient;namespace CZBK.ItcastProject.DAL&#123; public class SqlHelper &#123; private static readonly string connStr &#x3D; ConfigurationManager.ConnectionStrings[&quot;connStr&quot;].ConnectionString; public static DataTable GetDataTable(string sql,CommandType type,params SqlParameter[]pars) &#123; using (SqlConnection conn &#x3D; new SqlConnection(connStr)) &#123; using (SqlDataAdapter apter &#x3D; new SqlDataAdapter(sql, conn)) &#123; if (pars !&#x3D; null) &#123; apter.SelectCommand.Parameters.AddRange(pars); &#125; apter.SelectCommand.CommandType &#x3D; type; DataTable da &#x3D; new DataTable(); apter.Fill(da); return da; &#125; &#125; &#125; public static int ExecuteNonquery(string sql, CommandType type, params SqlParameter[] pars) &#123; using (SqlConnection conn &#x3D; new SqlConnection(connStr)) &#123; using (SqlCommand cmd &#x3D; new SqlCommand(sql, conn)) &#123; if (pars !&#x3D; null) &#123; cmd.Parameters.AddRange(pars); &#125; cmd.CommandType &#x3D; type; conn.Open(); return cmd.ExecuteNonQuery(); &#125; &#125; &#125; &#125;&#125;","categories":[{"name":"Geek","slug":"Geek","permalink":"https://casuor.top/categories/Geek/"}],"tags":[]},{"title":"Java Notes","slug":"geek_learningjava","date":"2018-03-24T16:00:00.000Z","updated":"2020-10-28T09:58:54.884Z","comments":true,"path":"2018/03/25/geek_learningjava/","link":"","permalink":"https://casuor.top/2018/03/25/geek_learningjava/","excerpt":"","text":"JavaEETomcattomcat启动问题1.一闪而过 未找到jdk%JAVA_HOME% 2.报错-端口占用cmd netstat -ano 找到8080进程pid 在任务管理器中关掉 修改配置部署方式wabapps目录下 __/项目文件 1.简化部署-项目打包成war包复制到目录下,会自动解压缩 2.配置server.xml 1&lt;Context docbase&#x3D;&quot;原项目路径&quot; path&#x3D;&quot;虚拟路径(随便写)&quot;&#x2F;&gt; 缺点:多个项目,配置不安全 3.在F:\\Develop_Apache\\apache-tomcat-8.5.45-windows-x64\\apache-tomcat-8.5.45\\conf\\Catalina\\localhost目录下创建任意名的xml文件 键入 1&lt;Context docbase&#x3D;&quot;原项目路径&quot;&#x2F;&gt; 则项目的虚拟路径为/xml的文件名 静态项目和动态项目的目录结构IDEA配置Tomcatrun-&gt; edit configurations-&gt;tomcatserver Servlet和Http请求协议Servlet简介-server applet 1）作用：规范了浏览器与服务器(代码编写的一个可以根据用户请求实时的调用执行对应的逻辑代码的一个容器)的数据交互；格式：key:value;2）特点：简单快速；灵活：允许传输任何数据对象，有Content-Type加以标记。无连接：HTTP1.1后支持可持续连接无状态：对于事物处理没有记忆能力3）HTTP交互流程：建立连接发送数据响应客户端4）请求格式：请求头：请求行：空行：请求数据5）get与post的区别6）响应格式及状态码（三个十进制数字组成，第一个定义了状态码的类型，后两个数组没有分类的作用）HTTP状态码分类： demo112345678910111213141516171819202122232425262728293031package com.web.servlet;import javax.servlet.*;import java.io.IOException;public class servlet implements Servlet &#123; @Override public void init(ServletConfig servletConfig) throws ServletException &#123; &#125; @Override public ServletConfig getServletConfig() &#123; return null; &#125; @Override public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException &#123; System.out.println(\"hello servlet\"); &#125; @Override public String getServletInfo() &#123; return null; &#125; @Override public void destroy() &#123; &#125;&#125; web.xml 12345678&lt;servlet&gt; &lt;servlet-name&gt;demo01&lt;/servlet-name&gt; &lt;servlet-class&gt;com.web.servlet.servlet&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;demo01&lt;/servlet-name&gt; &lt;url-pattern&gt;/demo01&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; Servlet技术Servlet 是什么？ Java Servlet 是运行在 Web 服务器或应用服务器上的程序，它是作为来自 Web 浏览器或其他 HTTP 客户端的请求和 HTTP 服务器上的数据库或应用程序之间的中间层。 使用 Servlet，您可以收集来自网页表单的用户输入，呈现来自数据库或者其他源的记录，还可以动态创建网页。 Java Servlet 通常情况下与使用 CGI（Common Gateway Interface，公共网关接口）实现的程序可以达到异曲同工的效果。但是相比于 CGI，Servlet 有以下几点优势： 性能明显更好。Servlet 在 Web 服务器的地址空间内执行。这样它就没有必要再创建一个单独的进程来处理每个客户端请求。Servlet 是独立于平台的，因为它们是用 Java 编写的。服务器上的 Java 安全管理器执行了一系列限制，以保护服务器计算机上的资源。因此，Servlet 是可信的。Java 类库的全部功能对 Servlet 来说都是可用的。它可以通过 sockets 和 RMI 机制与 applets、数据库或其他软件进行交互。 Servlet 任务 Servlet 执行以下主要任务： 读取客户端（浏览器）发送的显式的数据。这包括网页上的 HTML 表单，或者也可以是来自 applet 或自定义的 HTTP 客户端程序的表单。读取客户端（浏览器）发送的隐式的 HTTP 请求数据。这包括 cookies、媒体类型和浏览器能理解的压缩格式等等。处理数据并生成结果。这个过程可能需要访问数据库，执行 RMI 或 CORBA 调用，调用 Web 服务，或者直接计算得出对应的响应。发送显式的数据（即文档）到客户端（浏览器）。该文档的格式可以是多种多样的，包括文本文件（HTML 或 XML）、二进制文件（GIF 图像）、Excel 等。发送隐式的 HTTP 响应到客户端（浏览器）。这包括告诉浏览器或其他客户端被返回的文档类型（例如 HTML），设置 cookies 和缓存参数，以及其他类似的任务。 Servlet使用流程： 1、创建普通Java类，并继承HttpServlet2、覆写service方法3、在service方法中书写逻辑代码4、在webroot下的web-inf文件夹下的web.xml文件中配置servlet(demo1) ​ servlet3.0注解配置 在类上使用@webservlet(&quot;资源路径&quot;)不需要web.xml配置 Servlet访问流程 输入URL 1服务器地址：端口号&#x2F;project&#x2F;要执行的servlet的ul-pattern-&gt;classname-&gt;methodname Tomcat将全类名对应的字节码文件加载进内存Class.forname() 创建class对象.newInstance() 调用service方法 servlet接口的实现 1、实现 Servlet 接口 因为是实现 Servlet 接口，所以我们需要实现接口里的方法。 Servlet生命周期 Servlet的生命周期:从Servlet被创建到Servlet被销毁的过程 特点: 一次创建，到处服务一个Servlet只会有一个对象，服务所有的请求 1.实例化（使用构造方法创建对象） 指定servlet的创建时机 在servlet标签下配置load-on-startup &lt;load-on-startup&gt;负整数&lt;/load-on-startup&gt;//第一次访问时 1234 * &lt;load-on-startup&gt;正整数&lt;/load-on-startup&gt;//服务器启动时 12345678 * 2.初始化 执行init方法* 3.服务 执行service方法* 4.销毁 执行destroy方法 public class ServletDemo1 implements Servlet { //public ServletDemo1(){} //生命周期方法:当Servlet第一次被创建对象时执行该方法,该方法在整个生命周期中只执行一次,Servlet在内存中只存在一个对象,多个用户访问时存在线程安全问题,so,尽量不要在Servlet中定义变量,即使定义了不要修改. public void init(ServletConfig arg0) throws ServletException { System.out.println(&quot;=======init=========&quot;); } //生命周期方法:对客户端响应的方法,该方法会被执行多次，每次请求该servlet都会执行该方法 public void service(ServletRequest arg0, ServletResponse arg1) throws ServletException, IOException { System.out.println(&quot;hehe&quot;);} //生命周期方法:当Servlet被销毁时执行该方法 public void destroy() { System.out.println(&quot;******destroy**********&quot;);} //当停止tomcat时也就销毁的servlet。public ServletConfig getServletConfig() { return null; }//获取Servlet信息 public String getServletInfo() { return null; } } 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455 2、继承 GenericServlet 类它实现了 Servlet 接口除了 service 的方法，不过这种方法我们极少用。public class ServletDemo2 extends GenericServlet &#123; @Override public void service(ServletRequest arg0, ServletResponse arg1) throws ServletException, IOException &#123; System.out.println(&quot;heihei&quot;); &#125;&#125;3、继承 HttpServlet 方法public class ServletDemo3 extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; System.out.println(&quot;haha&quot;); &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; System.out.println(&quot;ee&quot;); doGet(req,resp); &#125;&#125;**关于 HttpServlet、GenericServlet 和 Servlet 的关系**&gt;&gt; 对于一个 Servlet 类，我们日常最常用的方法是继承自 HttpServlet 类，提供了 Http 相关的方 HttpServlet 扩展了 GenericServlet 类，而 GenericServlet 类又实现了 Servlet 类和 ServletConfig 类。&gt;**Servlet方法**&gt; Servlet类提供了五个方法，其中三个生命周期方法和两个普通方法，关于 Servlet类的方法，不再赘述，我主要补充一下另外两个类的实现思路。&gt;**GenericServlet**GenericServlet 是一个抽象类，实现了 Servlet 接口，并且对其中的 init() 和 destroy() 和 service() 提供了默认实现。在 GenericServlet 中，主要完成了以下任务：&gt; 将 init() 中的 ServletConfig 赋给一个类级变量，可以由 getServletConfig 获得；&gt; 为 Servlet 所有方法提供默认实现；&gt; 可以直接调用 ServletConfig 中的方法；基本的结构如下： abstract class GenericServlet implements Servlet,ServletConfig{ //GenericServlet通过将ServletConfig赋给类级变量 private trServletConfig servletConfig; public void init(ServletConfig servletConfig) throws ServletException { this.servletConfig=servletConfig; /*自定义init()的原因是：如果子类要初始化必须覆盖父类的init() 而使它无效 这样 this.servletConfig=servletConfig不起作用 这样就会导致空指针异常 这样如果子类要初始化， 可以直接覆盖不带参数的init()方法 */ this.init(); } //自定义的init()方法，可以由子类覆盖 //init()不是生命周期方法 public void init(){ } //实现service()空方法，并且声明为抽象方法，强制子类必须实现service()方法 public abstract void service(ServletRequest request,ServletResponse response) throws ServletException,java.io.IOException{ } //实现空的destroy方法 public void destroy(){ }} 123456以上就是 GenericServlet 的大致实现思想，可以看到如果继承这个类的话，我们必须重写 service() 方法来对处理请求。**HttpServlet**HttpServlet 也是一个抽象类，它进一步继承并封装了 GenericServlet，使得使用更加简单方便，由于是扩展了 Http 的内容，所以还需要使用 HttpServletRequest 和 HttpServletResponse，这两个类分别是 ServletRequest 和 ServletResponse 的子类。代码如下： abstract class HttpServlet extends GenericServlet{ //HttpServlet中的service() protected void service(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse){ //该方法通过httpServletRequest.getMethod()判断请求类型调用doGet() doPost() } //必须实现父类的service()方法 public void service(ServletRequest servletRequest,ServletResponse servletResponse){ HttpServletRequest request; HttpServletResponse response; try{ request=(HttpServletRequest)servletRequest; response=(HttpServletResponse)servletResponse; }catch(ClassCastException){ throw new ServletException(“non-http request or response”); } //调用service()方法 this.service(request,response); }} 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465我们可以看到，HttpServlet 中对原始的 Servlet 中的方法都进行了默认的操作，不需要显式的销毁初始化以及 service()，在 HttpServlet 中，自定义了一个新的 service() 方法，其中通过 getMethod() 方法判断请求的类型，从而调用 doGet() 或者 doPost() 处理 get,post 请求，使用者只需要继承 HttpServlet，然后重写 doPost() 或者 doGet() 方法处理请求即可。PS:IDEA与Tomcat配置&#96;IDEA会为每一个tomcat部署的项目单独创建一份配置文件&#96;控制台log:using CATALINA_BASE:&#96;工作空间项目和tomcat部署的web项目&#96;- tomcat真正访问的是&quot;tomcat部署的web项目&quot;,&quot;tomcat部署的web项目&quot;对应者工作空间项目下的所有资源.- WEB-INF目录下的资源不能被浏览器直接访问. ------ ### Http协议* 概念：Hyper Text Transfer Protocol 超文本传输协议 * 传输协议：定义了，客户端和服务器端通信时，发送数据的格式 * 特点： 1. 基于TCP&#x2F;IP的高级协议 2. 默认端口号:80 3. 基于请求&#x2F;响应模型的:一次请求对应一次响应 4. 无状态的：每次请求之间相互独立，不能交互数据 * 历史版本： * 1.0：每一次请求响应都会建立新的连接 * 1.1：复用连接* 请求消息数据格式 1. 请求行 请求方式 请求url 请求协议&#x2F;版本 GET &#x2F;login.html HTTP&#x2F;1.1 * 请求方式： * HTTP协议有7中请求方式，常用的有2种 * GET： 1. 请求参数在请求行中，在url后。 2. 请求的url长度有限制的 3. 不太安全 * POST： 1. 请求参数在请求体中 2. 请求的url长度没有限制的 3. 相对安全 2. 请求头：客户端浏览器告诉服务器一些信息 请求头名称: 请求头值 * 常见的请求头： 1. User-Agent：浏览器告诉服务器，我访问你使用的浏览器版本信息 * 可以在服务器端获取该头的信息，解决浏览器的兼容性问题 2. Referer：http:&#x2F;&#x2F;localhost&#x2F;login.html * 告诉服务器，我(当前请求)从哪里来？ * 作用： 1. 防盗链： 2. 统计工作： 3. 请求空行 空行，就是用于分割POST请求的请求头，和请求体的。 4. 请求体(正文)： * 封装POST请求消息的请求参数的 * 字符串格式： POST /login.html HTTP/1.1 Host: localhost User-Agent: Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:60.0) Gecko/20100101 Firefox/60.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2 Accept-Encoding: gzip, deflate Referer: http://localhost/login.html Connection: keep-alive Upgrade-Insecure-Requests: 1 username=zhangsan 12345678910111213141516171819202122 ------ ### Request## JSTLJava Server Pages Tag Library----JSP标准标签库是由Apache免费提供的用于简化和替换jsp页面上的java代码使用步骤:1.导包2.引入标签库taglib指令&lt;%@ taglib %&gt;3.使用常用标签:if &#96;&#96;&#96;jsp&lt;%@taglib prefix&#x3D;&quot;c&quot; uri&#x3D;&quot;http:&#x2F;&#x2F;java.sun.com&#x2F;jsp&#x2F;jstl&#x2F;core&quot; %&gt;&lt;%--c:if--%&gt;&lt;%--test 必须属性,接收boolean表达式,如果为真显示标签的内容,false不显示一般这个属性值结合EL表达式使用--%&gt;choose 123456&lt;%--c:chooseswitch when __case otherwis default--%&gt; foreach 1234567891011121314151617&lt;%--c:foreach--%&gt;&lt;c:forEach begin&#x3D;&quot;0&quot; end&#x3D;&quot;10&quot; step&#x3D;&quot;1&quot; var&#x3D;&quot;i&quot; &gt;$&#123;i&#125;&lt;&#x2F;c:forEach&gt;&lt;% List list&#x3D;new ArrayList(); list.add(&quot;aaa&quot;); list.add(&quot;bbb&quot;); list.add(&quot;ccc&quot;); request.setAttribute(&quot;list&quot;, list);%&gt;&lt;c:forEach items&#x3D;&quot;$&#123;list&#125;&quot; varStatus&#x3D;&quot;s&quot; var&#x3D;&quot;str&quot;&gt;$&#123;s.count&#125;$&#123;s.index&#125;&lt;&#x2F;c:forEach&gt;","categories":[{"name":"Geek","slug":"Geek","permalink":"https://casuor.top/categories/Geek/"}],"tags":[]},{"title":"操作系统原理（待整理）","slug":"geek_操作系统原理","date":"2018-02-21T16:00:00.000Z","updated":"2021-03-16T10:40:21.941Z","comments":true,"path":"2018/02/22/geek_操作系统原理/","link":"","permalink":"https://casuor.top/2018/02/22/geek_%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/","excerpt":"","text":"第一章 基础原理篇1.什么是操作系统？请用一句话描述你对操作系统的理解。2.你对操作系统和用户程序之间的关系有何看法？阐述你的想法。3.简要列出操作系统覆盖的范畴及每个范畴的核心内容。4.你为什么要学习操作系统？与本书列出的理由相同吗？简要阐述你的动机。5.操作系统要对不同的部件进行管理，请论述这些管理之间的异同点。6.设备管理要达到的目的是什么？7.有人说设备管理软件（设备驱动程序）因为经常由第三方提供，因此不应该作为操作系统的一部分。你对此有何看法？你认为应该如何判断一个软件是否属于操作系统？8.请列出程序执行过程中操作系统的介入情况。9.说操作系统是人造学科，根据是什么？10.人造学科的特点是什么？它对我们学习操作系统有何帮助？11.OS需要编译器来编译，而编译器的运行需要OS来支持，那到底是谁先出现谁后出现呢？","categories":[{"name":"Geek","slug":"Geek","permalink":"https://casuor.top/categories/Geek/"}],"tags":[]},{"title":"WIFI 傻瓜书(未完)","slug":"geek_Wifi傻瓜书","date":"2017-09-24T16:00:00.000Z","updated":"2020-10-28T09:58:54.880Z","comments":true,"path":"2017/09/25/geek_Wifi傻瓜书/","link":"","permalink":"https://casuor.top/2017/09/25/geek_Wifi%E5%82%BB%E7%93%9C%E4%B9%A6/","excerpt":"","text":"术语SSID 即Service Set Identifier,服务集标识符，一个唯一标识符，我们的无线客户端用它与接入点进行通信。SSID可以是任何字符，最大长度为32。 WAP 即wireless application protocol，无线应用协议，开放式标准协议，利用它可以把网络上的信息传递到移动电话或其他无线通讯终端上。WAP能够运行于各种无线网络之上，如GSM,GPRS,CDMA等.WML是无线标记语言（wireless makeup language）的英文缩写，支持WAP技术的手机能浏览由WML描述的Internet内容。 AP ACCESS POINT,无线访问点或无线接入点。无线客户端需要连接无线接入点才能获得登录外部互联网的能力，无线接入点可以是一座大型无线接入设备，也可以是一台小型无线路由器。由于在有的资料中会把WAP（wireless ap）WAP(wireless application protocol)概念混淆，所以在本书中 ，都将使用该简化词汇AP来指代无线接入点。 WEP wired equivalent privacy,市面上常用的无线网络认证机制之一，他是802.11定义下的一种加密方式。简单来说，就是先在无线AP中设定一组密码，使用者要连上这个无线AP时，必须输入相同的密码才能联机。 WPA wifi protected access,市面上常用的无线网络认证机制之一分为企业和个人两种。 EAP extensible authentication protocol(扩充认证协议），一种用于验证网络设备身份分鉴权机制。 WIFI-MESH 一种新型公共无线局域网和城域网解决方案，其网络结构类似于渔网，从一个点到另一个点有很多路可以走，这样即使有个别站点故障，仍可以保障较好的覆盖。 正文关于WEPWEP及其漏洞WEP的改进高位WEP 动态WEP WPA简介","categories":[{"name":"Geek","slug":"Geek","permalink":"https://casuor.top/categories/Geek/"}],"tags":[]},{"title":"我的社交论","slug":"think-社交","date":"2017-06-28T16:00:00.000Z","updated":"2020-10-28T09:58:54.892Z","comments":true,"path":"2017/06/29/think-社交/","link":"","permalink":"https://casuor.top/2017/06/29/think-%E7%A4%BE%E4%BA%A4/","excerpt":"","text":"固然，有时也对人生怀有恐怖感，这也是理所当然！ 只是我并不将它作为前提条件来加以承认。 我要百分百地发挥自己的能力，不达到极限绝不罢休。 想拿的就拿，不想拿的就不拿，就这样生存下去。 如果不行，到不行的时候再另行考虑。 反过来想，不公平的社会同时也是大有用武之地的社会。 在本质上我是只对自己感兴趣的人，自己想什莫，自己感受什么，自己如何行动——除此之外对别的没有兴趣，所以才能把自己同别人分开来考虑。 “我不希望别人理解自己。”“这点与其他人不同，那些家伙无不蝇营狗苟地设法让周围人理解自己。 但我不那样，而觉得不被人理解也无关紧要。自己是自己，别人归别人。 然而也并不认为不被任何人理解也无所谓，希望互相理解的对象也是有的。 只不过对除此之外的人，觉得在某种程度上即使不被人理解也无可奈何，这是不可强求的事。 额,以上这段话具体摘自谁的我已然记不得了,当然一看就是灰色系的日本小说 社交呢,有则更好,没有还行,要说社交,不是所有人你都想过去搭话的,有思想的动物很奇怪呢 当时呢,读这个小说,可能是我玩游戏最疯的时候,现在明白:时间会让你赶不上,所以学习 long life ,and proper game!","categories":[{"name":"Thinking","slug":"Thinking","permalink":"https://casuor.top/categories/Thinking/"}],"tags":[]}],"categories":[{"name":"Geek","slug":"Geek","permalink":"https://casuor.top/categories/Geek/"},{"name":"Resource","slug":"Resource","permalink":"https://casuor.top/categories/Resource/"},{"name":"Reading","slug":"Reading","permalink":"https://casuor.top/categories/Reading/"},{"name":"Transfer","slug":"Transfer","permalink":"https://casuor.top/categories/Transfer/"},{"name":"Live","slug":"Live","permalink":"https://casuor.top/categories/Live/"},{"name":"Thinking","slug":"Thinking","permalink":"https://casuor.top/categories/Thinking/"}],"tags":[{"name":"Picture","slug":"Picture","permalink":"https://casuor.top/tags/Picture/"},{"name":"Reading","slug":"Reading","permalink":"https://casuor.top/tags/Reading/"}]}